<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Call - DialPro</title>
  <link rel="stylesheet" href="css/styles.css">
  <!-- Supabase JS SDK (local) -->
  <script src="js/supabase.min.js"></script>
  <script src="js/supabase-config.js"></script>
  <!-- Twilio Voice SDK (v2.x) - local copy -->
  <script src="js/twilio.min.js"></script>
  <style>
    /* Call-specific styles */
    .call-page {
      display: grid;
      grid-template-columns: 240px 320px 1fr;
      gap: var(--spacing-md);
      height: 100%;
      overflow: hidden;
    }

    /* Call Mode Toggle */
    .call-mode-toggle {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      padding: var(--spacing-sm) var(--spacing-md);
      background: var(--gray-100);
      border-radius: var(--radius-md);
      font-size: 0.75rem;
    }

    .call-mode-toggle .mode-label {
      font-weight: 500;
      color: var(--gray-700);
    }

    .call-mode-toggle .mode-status {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .call-mode-toggle .mode-status.basic {
      color: var(--gray-600);
    }

    .call-mode-toggle .mode-status.advanced {
      color: var(--primary);
    }

    .call-mode-toggle .mode-status.error {
      color: var(--danger);
    }

    .mode-indicator-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--gray-400);
    }

    .mode-indicator-dot.active {
      background: var(--success);
      animation: pulse 2s infinite;
    }

    .mode-indicator-dot.error {
      background: var(--danger);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Reconnecting overlay */
    .reconnecting-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .reconnecting-overlay.hidden {
      display: none;
    }

    .reconnecting-box {
      background: white;
      padding: var(--spacing-xl);
      border-radius: var(--radius-lg);
      text-align: center;
      max-width: 300px;
    }

    .reconnecting-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--gray-200);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto var(--spacing-md);
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Auto-Dialer Queue Panel */
    .queue-panel {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

    .queue-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--spacing-md);
      border-bottom: 1px solid var(--gray-200);
      background: var(--gray-50);
    }

    .queue-header h3 {
      font-size: 0.875rem;
      font-weight: 600;
      margin: 0;
    }

    .queue-controls {
      display: flex;
      gap: var(--spacing-xs);
    }

    .queue-stats {
      display: flex;
      gap: var(--spacing-md);
      padding: var(--spacing-sm) var(--spacing-md);
      background: var(--gray-100);
      font-size: 0.75rem;
    }

    .queue-stat {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .queue-stat-value {
      font-weight: 600;
    }

    .queue-list {
      flex: 1;
      overflow-y: auto;
      padding: var(--spacing-sm);
    }

    .queue-item {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all var(--transition-fast);
      margin-bottom: var(--spacing-xs);
    }

    .queue-item:hover {
      background: var(--gray-100);
    }

    .queue-item.active {
      background: var(--primary-light);
      border-left: 3px solid var(--primary);
    }

    .queue-item.completed {
      opacity: 0.6;
    }

    .queue-item.completed .queue-item-status {
      color: var(--success);
    }

    .queue-item.skipped .queue-item-status {
      color: var(--gray-400);
    }

    .queue-item-number {
      font-size: 0.875rem;
      font-weight: 500;
      flex: 1;
    }

    .queue-item-name {
      font-size: 0.75rem;
      color: var(--gray-500);
    }

    .queue-item-status {
      font-size: 0.75rem;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .queue-item-actions {
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity var(--transition-fast);
    }

    .queue-item:hover .queue-item-actions {
      opacity: 1;
    }

    .queue-action-btn {
      width: 24px;
      height: 24px;
      border: none;
      background: var(--gray-200);
      border-radius: var(--radius-sm);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
    }

    .queue-action-btn:hover {
      background: var(--gray-300);
    }

    .queue-empty {
      text-align: center;
      padding: var(--spacing-xl);
      color: var(--gray-500);
    }

    .queue-empty-icon {
      font-size: 2rem;
      margin-bottom: var(--spacing-sm);
    }

    .queue-add-section {
      padding: var(--spacing-md);
      border-top: 1px solid var(--gray-200);
      background: var(--gray-50);
    }

    .queue-add-input {
      display: flex;
      gap: var(--spacing-xs);
    }

    .queue-add-input input {
      flex: 1;
    }

    .auto-dial-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--spacing-sm) var(--spacing-md);
      background: linear-gradient(135deg, var(--primary-light), #e0e7ff);
      border-radius: var(--radius-md);
      margin: var(--spacing-sm);
    }

    .auto-dial-toggle label {
      font-size: 0.875rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      cursor: pointer;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
      position: absolute;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--gray-300);
      transition: 0.3s;
      border-radius: 24px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    .toggle-switch input:checked + .toggle-slider {
      background-color: var(--primary);
    }

    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(20px);
    }

    .delay-setting {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-xs) var(--spacing-md);
      font-size: 0.75rem;
      color: var(--gray-600);
    }

    .delay-setting select {
      padding: 2px 6px;
      font-size: 0.75rem;
      border-radius: var(--radius-sm);
    }

    .call-sidebar {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-lg);
      overflow-y: auto;
      padding-bottom: var(--spacing-lg);
    }

    /* Ensure dial pad card shows all content */
    .call-sidebar .card {
      overflow: visible;
      flex-shrink: 0;
    }

    .call-sidebar .card-body {
      padding-bottom: var(--spacing-xl);
    }

    .call-main {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--spacing-md);
      height: 100%;
      overflow: hidden;
    }

    /* AI Coaching Panel (Left) */
    .ai-coaching-panel {
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--gray-50);
      border-radius: var(--radius-lg);
      border: 1px solid var(--gray-200);
    }

    .ai-coaching-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-md);
      border-bottom: 1px solid var(--gray-200);
      background: var(--gray-100);
    }

    .ai-coaching-header h3 {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--gray-900);
    }

    .ai-coaching-header h3 .ai-icon {
      font-size: 1.1rem;
    }

    .knowledge-base-select {
      font-size: 0.75rem;
      padding: 4px 8px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--gray-300);
      background: white;
    }

    .ai-coaching-content {
      flex: 1;
      overflow-y: auto;
      padding: var(--spacing-md);
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
    }

    .ai-tip-card {
      padding: var(--spacing-md);
      border-radius: var(--radius-md);
      border-left: 4px solid var(--primary);
      background: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .ai-tip-card.suggestion {
      border-left-color: #f59e0b;
      background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
    }

    .ai-tip-card.objection {
      border-left-color: #ef4444;
      background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
    }

    .ai-tip-card.success {
      border-left-color: #22c55e;
      background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
    }

    .ai-tip-card.signal {
      border-left-color: #8b5cf6;
      background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%);
    }

    .ai-tip-header {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: var(--spacing-xs);
      color: var(--gray-600);
    }

    .ai-tip-card.suggestion .ai-tip-header { color: #b45309; }
    .ai-tip-card.objection .ai-tip-header { color: #dc2626; }
    .ai-tip-card.success .ai-tip-header { color: #16a34a; }
    .ai-tip-card.signal .ai-tip-header { color: #7c3aed; }

    .ai-tip-text {
      font-size: 0.875rem;
      line-height: 1.5;
      color: var(--gray-800);
    }

    .ai-tip-script {
      margin-top: var(--spacing-sm);
      padding: var(--spacing-sm);
      background: rgba(0,0,0,0.05);
      border-radius: var(--radius-sm);
      font-size: 0.8rem;
      font-style: italic;
      color: var(--gray-700);
    }

    .ai-empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--gray-500);
      text-align: center;
      padding: var(--spacing-xl);
    }

    .ai-empty-state .ai-empty-icon {
      font-size: 2.5rem;
      margin-bottom: var(--spacing-md);
    }

    /* Script Match Cards */
    .ai-tip-card.script-match {
      border-left-color: #10b981;
      background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
      padding: 0;
      overflow: hidden;
    }

    .ai-tip-card.script-match.story {
      border-left-color: #3b82f6;
      background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
    }

    .ai-tip-card.script-match.close {
      border-left-color: #8b5cf6;
      background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%);
    }

    .ai-tip-card.script-match.opener {
      border-left-color: #f59e0b;
      background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
    }

    /* ========================================
       SAY THIS NOW Card Styles
       ======================================== */
    .say-this-now-card {
      background: white;
      border-radius: var(--radius-lg);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      overflow: hidden;
      border: 2px solid #f59e0b;
      animation: slideIn 0.3s ease-out, pulse-border 2s ease-in-out infinite;
    }

    @keyframes pulse-border {
      0%, 100% { box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3); }
      50% { box-shadow: 0 4px 20px rgba(245, 158, 11, 0.5); }
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .stn-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-sm) var(--spacing-md);
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      color: white;
    }

    .stn-title {
      font-size: 0.8rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
    }

    .stn-badge {
      display: inline-flex;
      align-items: center;
      gap: var(--spacing-xs);
      background: rgba(255,255,255,0.25);
      padding: 3px 10px;
      border-radius: 20px;
      font-size: 0.7rem;
      font-weight: 600;
    }

    .stn-badge-icon {
      font-size: 0.85rem;
    }

    .stn-progress {
      padding: var(--spacing-xs) var(--spacing-md);
      background: #fef3c7;
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
      font-size: 0.75rem;
      color: #92400e;
      border-bottom: 1px solid #fcd34d;
    }

    .progress-dots {
      display: flex;
      gap: 5px;
    }

    .progress-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #fcd34d;
      transition: background 0.2s ease;
    }

    .progress-dot.active {
      background: #f59e0b;
      transform: scale(1.2);
    }

    .progress-dot.completed {
      background: #22c55e;
    }

    .stn-body {
      padding: var(--spacing-md);
    }

    .stn-script {
      font-size: 1rem;
      line-height: 1.6;
      color: var(--gray-900);
      margin-bottom: var(--spacing-md);
      padding: var(--spacing-md);
      background: var(--gray-50);
      border-radius: var(--radius-md);
      border: 1px dashed var(--gray-300);
      position: relative;
    }

    .stn-copy-btn {
      position: absolute;
      top: var(--spacing-sm);
      right: var(--spacing-sm);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .stn-copy-btn:hover {
      background: var(--primary-dark, #4338ca);
      transform: scale(1.05);
    }

    .stn-copy-btn.copied {
      background: #22c55e;
    }

    .stn-tip {
      display: flex;
      align-items: flex-start;
      gap: var(--spacing-sm);
      padding: var(--spacing-sm) var(--spacing-md);
      background: #dbeafe;
      border-radius: var(--radius-md);
      font-size: 0.8rem;
      color: #1e40af;
      margin-bottom: var(--spacing-md);
    }

    .stn-tip-icon {
      flex-shrink: 0;
    }

    .stn-story {
      margin-bottom: var(--spacing-md);
    }

    .stn-story-toggle {
      display: inline-flex;
      align-items: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-xs) var(--spacing-sm);
      background: transparent;
      border: 1px solid var(--gray-300);
      border-radius: var(--radius-sm);
      font-size: 0.75rem;
      color: var(--gray-600);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .stn-story-toggle:hover {
      background: var(--gray-100);
    }

    .stn-story-content {
      margin-top: var(--spacing-sm);
      padding: var(--spacing-md);
      background: #f0f9ff;
      border-radius: var(--radius-md);
      border-left: 3px solid #3b82f6;
      font-size: 0.85rem;
      color: var(--gray-700);
      line-height: 1.5;
    }

    .stn-story-content.hidden {
      display: none;
    }

    .stn-listen-for {
      border-top: 1px solid var(--gray-200);
      padding-top: var(--spacing-md);
    }

    .stn-listen-label {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--gray-500);
      margin-bottom: var(--spacing-sm);
    }

    .stn-responses {
      display: flex;
      flex-wrap: wrap;
      gap: var(--spacing-xs);
    }

    .stn-response-chip {
      display: inline-flex;
      align-items: center;
      padding: 5px 12px;
      background: var(--gray-100);
      border: 1px solid var(--gray-300);
      border-radius: 20px;
      font-size: 0.75rem;
      color: var(--gray-700);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .stn-response-chip:hover {
      background: #e0e7ff;
      border-color: var(--primary);
      color: var(--primary);
    }

    .stn-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-sm) var(--spacing-md);
      background: var(--gray-50);
      border-top: 1px solid var(--gray-200);
    }

    .stn-feedback {
      display: flex;
      gap: var(--spacing-xs);
    }

    .stn-feedback-btn {
      display: inline-flex;
      align-items: center;
      gap: var(--spacing-xs);
      padding: 5px 10px;
      background: white;
      border: 1px solid var(--gray-300);
      border-radius: var(--radius-sm);
      font-size: 0.7rem;
      color: var(--gray-600);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .stn-feedback-btn:hover {
      background: var(--gray-100);
    }

    .stn-feedback-btn.used {
      background: #dcfce7;
      border-color: #22c55e;
      color: #166534;
    }

    .stn-feedback-btn.helpful-yes {
      background: #dbeafe;
      border-color: #3b82f6;
      color: #1e40af;
    }

    .stn-feedback-btn.helpful-no {
      background: #fee2e2;
      border-color: #ef4444;
      color: #dc2626;
    }

    .stn-flow-info {
      font-size: 0.65rem;
      color: var(--gray-400);
    }

    /* Category-specific colors for SAY THIS NOW */
    .say-this-now-card.price { border-color: #f59e0b; }
    .say-this-now-card.price .stn-header { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); }

    .say-this-now-card.timing { border-color: #3b82f6; }
    .say-this-now-card.timing .stn-header { background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); }
    .say-this-now-card.timing .stn-progress { background: #dbeafe; border-color: #93c5fd; color: #1e40af; }
    .say-this-now-card.timing .progress-dot { background: #93c5fd; }
    .say-this-now-card.timing .progress-dot.active { background: #3b82f6; }

    .say-this-now-card.authority { border-color: #8b5cf6; }
    .say-this-now-card.authority .stn-header { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); }
    .say-this-now-card.authority .stn-progress { background: #ede9fe; border-color: #c4b5fd; color: #5b21b6; }
    .say-this-now-card.authority .progress-dot { background: #c4b5fd; }
    .say-this-now-card.authority .progress-dot.active { background: #8b5cf6; }

    .say-this-now-card.trust { border-color: #ec4899; }
    .say-this-now-card.trust .stn-header { background: linear-gradient(135deg, #ec4899 0%, #db2777 100%); }
    .say-this-now-card.trust .stn-progress { background: #fce7f3; border-color: #f9a8d4; color: #9d174d; }
    .say-this-now-card.trust .progress-dot { background: #f9a8d4; }
    .say-this-now-card.trust .progress-dot.active { background: #ec4899; }

    .say-this-now-card.competitor { border-color: #14b8a6; }
    .say-this-now-card.competitor .stn-header { background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%); }
    .say-this-now-card.competitor .stn-progress { background: #ccfbf1; border-color: #5eead4; color: #115e59; }
    .say-this-now-card.competitor .progress-dot { background: #5eead4; }
    .say-this-now-card.competitor .progress-dot.active { background: #14b8a6; }

    .say-this-now-card.no_need { border-color: #6b7280; }
    .say-this-now-card.no_need .stn-header { background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); }
    .say-this-now-card.no_need .stn-progress { background: #f3f4f6; border-color: #d1d5db; color: #374151; }
    .say-this-now-card.no_need .progress-dot { background: #d1d5db; }
    .say-this-now-card.no_need .progress-dot.active { background: #6b7280; }

    /* Dimmed previous cards */
    .say-this-now-card.previous {
      opacity: 0.5;
      animation: none;
      border-width: 1px;
    }

    .say-this-now-card.previous .stn-header {
      background: var(--gray-400);
    }

    .script-header {
      display: flex;
      flex-direction: column;
      gap: 2px;
      padding: var(--spacing-sm) var(--spacing-md);
      background: rgba(0,0,0,0.05);
      border-bottom: 1px solid rgba(0,0,0,0.1);
    }

    .script-category {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      color: #059669;
    }

    .script-match.story .script-category { color: #2563eb; }
    .script-match.close .script-category { color: #7c3aed; }
    .script-match.opener .script-category { color: #d97706; }

    .script-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--gray-800);
    }

    .script-body {
      padding: var(--spacing-md);
    }

    .script-text-box {
      position: relative;
      background: white;
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
      padding-right: calc(var(--spacing-md) + 32px);
      border: 1px solid rgba(0,0,0,0.1);
    }

    .script-text {
      font-size: 0.9rem;
      line-height: 1.6;
      color: var(--gray-800);
      margin: 0;
    }

    .copy-script-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 28px;
      height: 28px;
      border: none;
      background: var(--gray-100);
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }

    .copy-script-btn:hover {
      background: var(--gray-200);
    }

    .copy-script-btn.copied {
      background: #10b981;
      color: white;
    }

    .script-story {
      margin-top: var(--spacing-sm);
    }

    .story-toggle {
      background: none;
      border: 1px dashed var(--gray-300);
      padding: var(--spacing-xs) var(--spacing-sm);
      border-radius: var(--radius-sm);
      font-size: 0.75rem;
      color: var(--gray-600);
      cursor: pointer;
      width: 100%;
      text-align: left;
    }

    .story-toggle:hover {
      background: rgba(0,0,0,0.03);
    }

    .story-content {
      margin-top: var(--spacing-sm);
      padding: var(--spacing-sm);
      background: rgba(59, 130, 246, 0.1);
      border-radius: var(--radius-sm);
      font-size: 0.8rem;
      line-height: 1.5;
      color: var(--gray-700);
      font-style: italic;
    }

    .story-content p {
      margin: 0;
    }

    .script-tips {
      margin-top: var(--spacing-sm);
      padding: var(--spacing-sm);
      background: rgba(245, 158, 11, 0.1);
      border-radius: var(--radius-sm);
      font-size: 0.75rem;
      color: var(--gray-700);
    }

    .tips-label {
      font-weight: 600;
    }

    .script-feedback {
      display: flex;
      gap: var(--spacing-xs);
      padding: var(--spacing-sm) var(--spacing-md);
      background: rgba(0,0,0,0.03);
      border-top: 1px solid rgba(0,0,0,0.05);
    }

    .feedback-btn {
      flex: 1;
      padding: var(--spacing-xs) var(--spacing-sm);
      border: 1px solid var(--gray-300);
      background: white;
      border-radius: var(--radius-sm);
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .feedback-btn:hover {
      background: var(--gray-100);
    }

    .feedback-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .feedback-btn.used.active {
      background: #10b981;
      border-color: #10b981;
    }

    .feedback-btn.helpful.active {
      background: #22c55e;
      border-color: #22c55e;
    }

    .feedback-btn.not-helpful.active {
      background: #ef4444;
      border-color: #ef4444;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Transcript Panel (Right) */
    .transcript-panel {
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--gray-50);
      border-radius: var(--radius-lg);
      border: 1px solid var(--gray-200);
    }

    .transcript-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-md);
      border-bottom: 1px solid var(--gray-200);
      background: var(--gray-100);
    }

    .transcript-header h3 {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--gray-900);
    }

    .transcript-search {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-xs) var(--spacing-md);
      border-bottom: 1px solid var(--gray-200);
    }

    .transcript-search input {
      flex: 1;
      border: none;
      background: white;
      padding: var(--spacing-xs) var(--spacing-sm);
      border-radius: var(--radius-sm);
      font-size: 0.8rem;
    }

    .transcript-search input:focus {
      outline: 2px solid var(--primary);
    }

    .transcript-scroll {
      flex: 1;
      overflow-y: auto;
      padding: var(--spacing-md);
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
    }

    .transcript-message {
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--radius-md);
      font-size: 0.875rem;
      line-height: 1.5;
      position: relative;
    }

    .transcript-message.rep {
      background: #e0f2fe;
      border-left: 3px solid #3b82f6;
      margin-right: 20%;
    }

    .transcript-message.customer {
      background: #f3e8ff;
      border-left: 3px solid #8b5cf6;
      margin-right: 20%;
    }

    .transcript-message .speaker-label {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 2px;
    }

    .transcript-message.rep .speaker-label {
      color: #2563eb;
    }

    .transcript-message.customer .speaker-label {
      color: #7c3aed;
    }

    .transcript-time {
      font-size: 0.65rem;
      color: var(--gray-500);
      margin-top: 4px;
    }

    .search-highlight {
      background: #fef08a;
      padding: 0 2px;
      border-radius: 2px;
    }

    .speaking-indicator {
      background: var(--gray-100);
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--radius-md);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      font-size: 0.875rem;
      color: var(--gray-600);
    }

    .speaking-indicator .dots {
      display: flex;
      gap: 3px;
    }

    .speaking-indicator .dot {
      width: 6px;
      height: 6px;
      background: var(--primary);
      border-radius: 50%;
      animation: bounce 1.4s infinite ease-in-out both;
    }

    .speaking-indicator .dot:nth-child(1) { animation-delay: -0.32s; }
    .speaking-indicator .dot:nth-child(2) { animation-delay: -0.16s; }

    @keyframes bounce {
      0%, 80%, 100% { transform: scale(0); }
      40% { transform: scale(1); }
    }

    .outcome-panel {
      background: var(--gray-50);
      border-top: 1px solid var(--gray-200);
      padding: var(--spacing-lg);
    }

    .outcome-buttons {
      display: flex;
      gap: var(--spacing-sm);
      flex-wrap: wrap;
      margin-bottom: var(--spacing-md);
    }

    .outcome-btn {
      flex: 1;
      min-width: 120px;
      padding: var(--spacing-md);
      border: 2px solid var(--gray-200);
      border-radius: var(--radius-md);
      background: white;
      cursor: pointer;
      text-align: center;
      transition: all var(--transition-fast);
    }

    .outcome-btn:hover {
      border-color: var(--primary);
    }

    .outcome-btn.selected {
      border-color: var(--primary);
      background: var(--primary-light);
    }

    .outcome-btn .icon {
      font-size: 1.5rem;
      margin-bottom: var(--spacing-xs);
    }

    .outcome-btn .label {
      font-size: 0.75rem;
      font-weight: 500;
    }

    .customer-info-card {
      background: var(--gray-50);
    }

    .scripts-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--spacing-xs);
    }

    @media (max-width: 1200px) {
      .call-page {
        grid-template-columns: 280px 1fr;
      }

      .call-sidebar {
        display: none;
      }
    }

    @media (max-width: 900px) {
      .call-page {
        grid-template-columns: 1fr;
      }

      .queue-panel {
        display: none;
      }
    }

    /* Queue panel collapsed state */
    .queue-panel.collapsed {
      width: 48px;
      min-width: 48px;
    }

    .queue-panel.collapsed .queue-header h3,
    .queue-panel.collapsed .queue-stats,
    .queue-panel.collapsed .queue-list,
    .queue-panel.collapsed .queue-add-section,
    .queue-panel.collapsed .auto-dial-toggle,
    .queue-panel.collapsed .delay-setting {
      display: none;
    }

    /* =====================================================
       TIME TRACKING PANEL STYLES
       ===================================================== */
    .time-tracking-panel {
      background: white;
      border-radius: var(--radius-lg);
      border: 1px solid var(--gray-200);
      margin-bottom: var(--spacing-md);
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .time-tracking-panel.collapsed .time-tracking-body {
      display: none;
    }

    .time-tracking-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--spacing-sm) var(--spacing-md);
      background: linear-gradient(135deg, var(--primary-light), #e0e7ff);
      border-bottom: 1px solid var(--gray-200);
      cursor: pointer;
    }

    .time-tracking-header:hover {
      background: linear-gradient(135deg, #ddd6fe, #c7d2fe);
    }

    .time-tracking-title {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--gray-800);
    }

    .time-tracking-title .session-status {
      font-size: 0.75rem;
      padding: 2px 8px;
      border-radius: var(--radius-full);
      font-weight: 500;
    }

    .time-tracking-title .session-status.active {
      background: var(--success-light);
      color: var(--success);
    }

    .time-tracking-title .session-status.paused {
      background: var(--warning-light);
      color: #b45309;
    }

    .time-tracking-title .session-status.inactive {
      background: var(--gray-100);
      color: var(--gray-500);
    }

    .time-tracking-collapse-btn {
      background: none;
      border: none;
      font-size: 0.75rem;
      color: var(--gray-500);
      cursor: pointer;
      padding: 4px;
      transition: transform 0.2s;
    }

    .time-tracking-panel.collapsed .time-tracking-collapse-btn {
      transform: rotate(180deg);
    }

    .time-tracking-body {
      padding: var(--spacing-md);
    }

    /* Main Timer Display */
    .session-main-timer {
      text-align: center;
      padding: var(--spacing-md) 0;
      border-bottom: 1px solid var(--gray-100);
      margin-bottom: var(--spacing-md);
    }

    .session-main-timer .timer-label {
      font-size: 0.75rem;
      color: var(--gray-500);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }

    .session-main-timer .timer-value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--gray-900);
      font-variant-numeric: tabular-nums;
      font-family: ui-monospace, monospace;
    }

    .session-main-timer .timer-value.on-call {
      color: var(--success);
    }

    /* Session Stats Grid */
    .session-stats-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-md);
    }

    .session-stat-item {
      text-align: center;
      padding: var(--spacing-sm);
      background: var(--gray-50);
      border-radius: var(--radius-md);
    }

    .session-stat-item .stat-value {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--gray-900);
      font-variant-numeric: tabular-nums;
    }

    .session-stat-item .stat-value.talk-time {
      color: var(--success);
    }

    .session-stat-item .stat-value.idle-time {
      color: var(--warning);
    }

    .session-stat-item .stat-value.break-time {
      color: var(--gray-500);
    }

    .session-stat-item .stat-label {
      font-size: 0.625rem;
      color: var(--gray-500);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Productivity Bar */
    .productivity-bar-container {
      margin-bottom: var(--spacing-md);
    }

    .productivity-bar-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: var(--gray-500);
      margin-bottom: 4px;
    }

    .productivity-bar {
      height: 8px;
      background: var(--gray-200);
      border-radius: var(--radius-full);
      overflow: hidden;
      display: flex;
    }

    .productivity-segment {
      height: 100%;
      transition: width 0.3s ease;
    }

    .productivity-segment.talk {
      background: var(--success);
    }

    .productivity-segment.idle {
      background: var(--warning);
    }

    .productivity-segment.break {
      background: var(--gray-400);
    }

    /* Call Metrics Row */
    .call-metrics-row {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--spacing-sm);
      padding-top: var(--spacing-sm);
      border-top: 1px solid var(--gray-100);
      margin-bottom: var(--spacing-md);
    }

    .call-metric {
      text-align: center;
    }

    .call-metric .metric-value {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--gray-900);
    }

    .call-metric .metric-label {
      font-size: 0.625rem;
      color: var(--gray-500);
      text-transform: uppercase;
    }

    /* Session Controls */
    .session-controls {
      display: flex;
      gap: var(--spacing-sm);
    }

    .session-controls .btn {
      flex: 1;
      padding: var(--spacing-sm);
      font-size: 0.75rem;
    }

    .session-controls .btn-pause {
      background: var(--warning-light);
      color: #b45309;
      border: 1px solid #fcd34d;
    }

    .session-controls .btn-pause:hover {
      background: #fde68a;
    }

    .session-controls .btn-end {
      background: var(--danger-light);
      color: var(--danger);
      border: 1px solid #fecaca;
    }

    .session-controls .btn-end:hover {
      background: #fee2e2;
    }

    /* Break Warning Modal */
    .break-warning-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .break-warning-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .break-warning-modal {
      background: white;
      border-radius: var(--radius-xl);
      padding: var(--spacing-xl);
      text-align: center;
      max-width: 320px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    .break-warning-icon {
      font-size: 3rem;
      margin-bottom: var(--spacing-md);
    }

    .break-warning-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--gray-900);
      margin-bottom: var(--spacing-sm);
    }

    .break-warning-text {
      font-size: 0.875rem;
      color: var(--gray-500);
      margin-bottom: var(--spacing-lg);
    }

    .break-warning-actions {
      display: flex;
      gap: var(--spacing-sm);
    }

    .break-warning-actions .btn {
      flex: 1;
    }

    /* Incoming Call Modal */
    .incoming-call-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .incoming-call-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .incoming-call-modal {
      background: white;
      border-radius: var(--radius-xl);
      padding: var(--spacing-xl);
      text-align: center;
      max-width: 320px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .incoming-call-overlay.active .incoming-call-modal {
      transform: scale(1);
    }

    .incoming-call-icon {
      width: 80px;
      height: 80px;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto var(--spacing-lg);
      animation: ring-pulse 1.5s ease-in-out infinite;
    }

    .incoming-call-icon svg {
      width: 40px;
      height: 40px;
      color: white;
      animation: ring-shake 0.5s ease-in-out infinite;
    }

    @keyframes ring-pulse {
      0%, 100% {
        box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4);
      }
      50% {
        box-shadow: 0 0 0 20px rgba(16, 185, 129, 0);
      }
    }

    @keyframes ring-shake {
      0%, 100% { transform: rotate(-10deg); }
      50% { transform: rotate(10deg); }
    }

    .incoming-call-label {
      font-size: 0.875rem;
      color: var(--gray-500);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: var(--spacing-xs);
    }

    .incoming-call-number {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--gray-900);
      margin-bottom: var(--spacing-lg);
    }

    .incoming-call-actions {
      display: flex;
      gap: var(--spacing-md);
      justify-content: center;
    }

    .incoming-call-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .incoming-call-btn svg {
      width: 28px;
      height: 28px;
      color: white;
    }

    .incoming-call-btn.answer {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    }

    .incoming-call-btn.answer:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4);
    }

    .incoming-call-btn.decline {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    }

    .incoming-call-btn.decline:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 20px rgba(239, 68, 68, 0.4);
    }

    .incoming-call-btn-label {
      font-size: 0.75rem;
      color: var(--gray-600);
      margin-top: var(--spacing-xs);
    }

    .incoming-call-btn-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* =====================================================
       DESIGN 6 - NEW STYLES
       ===================================================== */

    /* Session Stats Mini Bar (at top of queue column) */
    .session-stats-mini {
      background: linear-gradient(135deg, #e0f2fe, #bae6fd);
      border: 1px solid #7dd3fc;
      border-radius: var(--radius-md);
      padding: 10px 12px;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: var(--spacing-sm);
    }

    .session-stats-mini:hover {
      background: linear-gradient(135deg, #bae6fd, #7dd3fc);
    }

    .session-stats-mini .stats-collapsed {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .session-stats-mini .stat-group {
      display: flex;
      gap: 16px;
    }

    .session-stats-mini .stat {
      text-align: center;
    }

    .session-stats-mini .stat-value {
      font-size: 1rem;
      font-weight: 700;
      color: #0369a1;
      font-variant-numeric: tabular-nums;
    }

    .session-stats-mini .stat-label {
      font-size: 0.6rem;
      color: #0c4a6e;
      text-transform: uppercase;
    }

    .session-stats-mini .expand-icon {
      color: #0369a1;
      font-size: 0.8rem;
      transition: transform 0.2s;
    }

    .session-stats-mini.expanded .expand-icon {
      transform: rotate(180deg);
    }

    .session-stats-mini .stats-expanded {
      display: none;
      padding-top: 12px;
      margin-top: 12px;
      border-top: 1px solid #7dd3fc;
    }

    .session-stats-mini.expanded .stats-expanded {
      display: block;
    }

    .session-stats-mini .mini-stats-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-bottom: 12px;
    }

    .session-stats-mini .mini-stat-box {
      background: white;
      padding: 8px;
      border-radius: var(--radius-sm);
      text-align: center;
    }

    .session-stats-mini .mini-stat-box .value {
      font-size: 1rem;
      font-weight: 700;
    }

    .session-stats-mini .mini-stat-box .value.talk { color: #16a34a; }
    .session-stats-mini .mini-stat-box .value.idle { color: #d97706; }
    .session-stats-mini .mini-stat-box .value.break { color: #6b7280; }

    .session-stats-mini .mini-stat-box .label {
      font-size: 0.6rem;
      color: #666;
      text-transform: uppercase;
    }

    .session-stats-mini .mini-productivity {
      background: white;
      padding: 8px;
      border-radius: var(--radius-sm);
      margin-bottom: 8px;
    }

    .session-stats-mini .mini-productivity .bar-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.7rem;
      margin-bottom: 4px;
    }

    .session-stats-mini .mini-productivity .bar {
      height: 6px;
      background: #e5e7eb;
      border-radius: 3px;
      overflow: hidden;
      display: flex;
    }

    .session-stats-mini .mini-productivity .bar-segment {
      height: 100%;
    }

    .session-stats-mini .mini-productivity .bar-segment.talk { background: #16a34a; }
    .session-stats-mini .mini-productivity .bar-segment.idle { background: #d97706; }
    .session-stats-mini .mini-productivity .bar-segment.break { background: #6b7280; }

    .session-stats-mini .mini-controls {
      display: flex;
      gap: 6px;
    }

    .session-stats-mini .mini-controls button {
      flex: 1;
      padding: 6px;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 0.7rem;
      font-weight: 500;
      cursor: pointer;
    }

    .session-stats-mini .mini-controls .btn-break {
      background: #fef3c7;
      color: #92400e;
    }

    .session-stats-mini .mini-controls .btn-break:hover {
      background: #fde68a;
    }

    .session-stats-mini .mini-controls .btn-end {
      background: #fee2e2;
      color: #dc2626;
    }

    .session-stats-mini .mini-controls .btn-end:hover {
      background: #fecaca;
    }

    /* Queue Column Updates */
    .queue-column {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

    .queue-column .queue-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Center Column - Dialer + Customer */
    .center-column {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-md);
      height: 100%;
      overflow: hidden;
    }

    /* Compact Dialer */
    .compact-dialer {
      background: white;
      border-radius: var(--radius-lg);
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      overflow: hidden;
      flex-shrink: 0;
    }

    .compact-dialer .dialer-display {
      padding: 16px;
      text-align: center;
      background: linear-gradient(135deg, #fefce8, #fef9c3);
      border-bottom: 1px solid #fde047;
    }

    .compact-dialer .dialer-number {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--gray-900);
      letter-spacing: 0.5px;
    }

    .compact-dialer .dialer-number input {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--gray-900);
      letter-spacing: 0.5px;
      border: none;
      background: transparent;
      text-align: center;
      width: 100%;
      outline: none;
    }

    .compact-dialer .dialer-number input::placeholder {
      color: var(--gray-400);
    }

    .compact-dialer .dialer-status {
      font-size: 0.8rem;
      color: var(--gray-600);
      margin-top: 4px;
    }

    .compact-dialer .dialer-status.calling {
      color: var(--success);
      font-weight: 500;
    }

    .compact-dialer .dialer-status.ringing {
      color: var(--primary);
      font-weight: 500;
    }

    .compact-dialer .dialer-timer {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--success);
      margin-top: 4px;
      font-variant-numeric: tabular-nums;
      font-family: ui-monospace, monospace;
    }

    .compact-dialer .dialer-controls {
      display: flex;
      justify-content: center;
      gap: 12px;
      padding: 16px;
    }

    .compact-dialer .dialer-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 1.25rem;
      transition: transform 0.15s, box-shadow 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .compact-dialer .dialer-btn:hover {
      transform: scale(1.05);
    }

    .compact-dialer .dialer-btn.call {
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: white;
      box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
    }

    .compact-dialer .dialer-btn.end {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
    }

    .compact-dialer .dialer-btn.mute,
    .compact-dialer .dialer-btn.hold {
      background: var(--gray-100);
      color: var(--gray-700);
    }

    .compact-dialer .dialer-btn.mute:hover,
    .compact-dialer .dialer-btn.hold:hover {
      background: var(--gray-200);
    }

    .compact-dialer .dialer-btn.mute.active {
      background: #fef3c7;
      color: #d97706;
    }

    .compact-dialer .dialer-btn.hold.active {
      background: #dbeafe;
      color: #2563eb;
    }

    .compact-dialer .dialer-btn.transfer {
      background: linear-gradient(135deg, #8b5cf6, #7c3aed);
      color: white;
    }

    .compact-dialer .dialer-btn.transfer:hover {
      background: linear-gradient(135deg, #7c3aed, #6d28d9);
    }

    /* In-Call Control Bar */
    .in-call-controls {
      display: none;
      padding: 12px;
      background: linear-gradient(135deg, #1e293b, #334155);
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .in-call-controls.visible {
      display: block;
    }

    .call-controls-row {
      display: flex;
      justify-content: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .call-control-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      padding: 10px 14px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: var(--radius-md);
      color: white;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.15s;
      min-width: 56px;
    }

    .call-control-btn:hover {
      background: rgba(255,255,255,0.2);
      transform: translateY(-1px);
    }

    .call-control-btn .icon {
      font-size: 1.2rem;
    }

    .call-control-btn.mute.active {
      background: #fbbf24;
      color: #78350f;
      border-color: #fbbf24;
    }

    .call-control-btn.hold.active {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
    }

    .call-control-btn.end {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      border-color: #ef4444;
    }

    .call-control-btn.end:hover {
      background: linear-gradient(135deg, #dc2626, #b91c1c);
    }

    .call-control-btn.transfer {
      background: linear-gradient(135deg, #8b5cf6, #7c3aed);
      border-color: #8b5cf6;
    }

    .call-control-btn.transfer:hover {
      background: linear-gradient(135deg, #7c3aed, #6d28d9);
    }

    /* Transfer Modal */
    .transfer-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .transfer-modal.visible {
      display: flex;
    }

    .transfer-modal-content {
      background: white;
      border-radius: var(--radius-lg);
      padding: 24px;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.3);
    }

    .transfer-modal h3 {
      margin: 0 0 16px 0;
      font-size: 1.1rem;
      color: var(--gray-900);
    }

    .transfer-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 16px;
    }

    .transfer-option {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--gray-50);
      border: 1px solid var(--gray-200);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.15s;
    }

    .transfer-option:hover {
      background: var(--gray-100);
      border-color: var(--primary);
    }

    .transfer-option .icon {
      font-size: 1.3rem;
    }

    .transfer-option .label {
      flex: 1;
    }

    .transfer-option .label strong {
      display: block;
      font-size: 0.9rem;
      color: var(--gray-900);
    }

    .transfer-option .label span {
      font-size: 0.75rem;
      color: var(--gray-500);
    }

    .transfer-input-group {
      margin-bottom: 16px;
    }

    .transfer-input-group label {
      display: block;
      font-size: 0.8rem;
      color: var(--gray-600);
      margin-bottom: 6px;
    }

    .transfer-input-group input {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--gray-300);
      border-radius: var(--radius-md);
      font-size: 0.9rem;
    }

    .transfer-modal-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .transfer-modal-actions button {
      padding: 10px 20px;
      border-radius: var(--radius-md);
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .transfer-modal-actions .cancel-btn {
      background: var(--gray-100);
      border: 1px solid var(--gray-300);
      color: var(--gray-700);
    }

    .transfer-modal-actions .cancel-btn:hover {
      background: var(--gray-200);
    }

    .transfer-modal-actions .transfer-btn {
      background: linear-gradient(135deg, #8b5cf6, #7c3aed);
      border: none;
      color: white;
    }

    .transfer-modal-actions .transfer-btn:hover {
      background: linear-gradient(135deg, #7c3aed, #6d28d9);
    }

    /* Contact Search Bar */
    .contact-search-bar {
      padding: 10px 12px;
      border-bottom: 1px solid var(--gray-200);
      position: relative;
    }

    .contact-search-bar input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid var(--gray-300);
      border-radius: var(--radius-md);
      font-size: 0.85rem;
      background: var(--gray-50);
    }

    .contact-search-bar input:focus {
      outline: none;
      border-color: var(--primary);
      background: white;
    }

    .contact-search-bar .search-results {
      display: none;
      position: absolute;
      top: 100%;
      left: 12px;
      right: 12px;
      background: white;
      border: 1px solid var(--gray-200);
      border-radius: var(--radius-md);
      box-shadow: 0 10px 25px rgba(0,0,0,0.15);
      max-height: 250px;
      overflow-y: auto;
      z-index: 100;
    }

    .contact-search-bar .search-results.visible {
      display: block;
    }

    .contact-search-bar .search-result-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid var(--gray-100);
      transition: background 0.15s;
    }

    .contact-search-bar .search-result-item:last-child {
      border-bottom: none;
    }

    .contact-search-bar .search-result-item:hover {
      background: var(--gray-50);
    }

    .contact-search-bar .search-result-item .avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--primary);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      font-weight: 600;
    }

    .contact-search-bar .search-result-item .info {
      flex: 1;
    }

    .contact-search-bar .search-result-item .info .name {
      font-weight: 500;
      font-size: 0.85rem;
      color: var(--gray-900);
    }

    .contact-search-bar .search-result-item .info .phone {
      font-size: 0.75rem;
      color: var(--gray-500);
    }

    .contact-search-bar .search-result-item .call-btn {
      padding: 6px 10px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 0.7rem;
      cursor: pointer;
    }

    .contact-search-bar .no-results {
      padding: 16px;
      text-align: center;
      color: var(--gray-500);
      font-size: 0.85rem;
    }

    .compact-dialer .dialpad-toggle {
      text-align: center;
      padding: 8px;
      background: var(--gray-50);
      border-top: 1px solid var(--gray-200);
      font-size: 0.75rem;
      color: var(--gray-600);
      cursor: pointer;
      transition: background 0.15s;
    }

    .compact-dialer .dialpad-toggle:hover {
      background: var(--gray-100);
    }

    .compact-dialer .dialpad-grid {
      display: none;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      padding: 12px;
      background: var(--gray-50);
    }

    .compact-dialer .dialpad-grid.visible {
      display: grid;
    }

    .compact-dialer .dialpad-btn {
      padding: 12px;
      font-size: 1.1rem;
      font-weight: 500;
      background: white;
      border: 1px solid var(--gray-200);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: background 0.15s;
    }

    .compact-dialer .dialpad-btn:hover {
      background: var(--gray-100);
    }

    /* Customer Panel with Tabs */
    .customer-tabbed-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: white;
      border-radius: var(--radius-lg);
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      overflow: hidden;
    }

    .customer-tabbed-panel .customer-header {
      padding: 12px 16px;
      background: linear-gradient(135deg, #faf5ff, #f3e8ff);
      border-bottom: 1px solid #e9d5ff;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .customer-tabbed-panel .customer-avatar {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, #a855f7, #7c3aed);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 1.1rem;
      flex-shrink: 0;
    }

    .customer-tabbed-panel .customer-info {
      flex: 1;
      min-width: 0;
    }

    .customer-tabbed-panel .customer-info h3 {
      font-size: 1rem;
      color: var(--gray-900);
      margin: 0 0 2px 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .customer-tabbed-panel .customer-info .meta {
      font-size: 0.75rem;
      color: var(--gray-600);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .customer-tabbed-panel .customer-tags {
      display: flex;
      gap: 4px;
      flex-shrink: 0;
    }

    .customer-tabbed-panel .customer-tag {
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 0.65rem;
      font-weight: 500;
    }

    .customer-tabbed-panel .customer-tag.hot { background: #fee2e2; color: #dc2626; }
    .customer-tabbed-panel .customer-tag.source { background: #dbeafe; color: #1d4ed8; }
    .customer-tabbed-panel .customer-tag.new { background: #dcfce7; color: #166534; }

    /* Tab Navigation */
    .customer-tabbed-panel .tab-nav {
      display: flex;
      border-bottom: 1px solid var(--gray-200);
      background: var(--gray-50);
    }

    .customer-tabbed-panel .tab-btn {
      flex: 1;
      padding: 10px 8px;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--gray-600);
      background: none;
      border: none;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.15s;
    }

    .customer-tabbed-panel .tab-btn:hover {
      color: var(--gray-700);
      background: var(--gray-100);
    }

    .customer-tabbed-panel .tab-btn.active {
      color: #7c3aed;
      border-bottom-color: #7c3aed;
      background: white;
    }

    /* Tab Content */
    .customer-tabbed-panel .tab-content {
      flex: 1;
      overflow-y: auto;
      padding: var(--spacing-md);
    }

    .customer-tabbed-panel .tab-pane {
      display: none;
    }

    .customer-tabbed-panel .tab-pane.active {
      display: block;
    }

    /* Profile Tab Styles */
    .profile-section {
      margin-bottom: 16px;
    }

    .profile-section h4 {
      font-size: 0.7rem;
      text-transform: uppercase;
      color: var(--gray-500);
      margin-bottom: 8px;
      letter-spacing: 0.5px;
    }

    .profile-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      font-size: 0.8rem;
      border-bottom: 1px solid var(--gray-100);
    }

    .profile-row .label {
      color: var(--gray-600);
    }

    .profile-row .value {
      color: var(--gray-900);
      font-weight: 500;
    }

    .profile-row .value a {
      color: var(--primary);
      text-decoration: none;
    }

    .profile-row .value a:hover {
      text-decoration: underline;
    }

    /* Tags Section Styles */
    .tags-section {
      border-top: 1px solid var(--gray-200);
      padding-top: 12px;
      margin-top: 8px;
    }

    .tags-container {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 10px;
      min-height: 28px;
    }

    .tags-container .no-tags {
      color: var(--gray-400);
      font-size: 0.8rem;
      font-style: italic;
    }

    .tags-container .contact-tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      background: linear-gradient(135deg, #e0f2fe, #bae6fd);
      border: 1px solid #7dd3fc;
      border-radius: 12px;
      font-size: 0.7rem;
      color: #0369a1;
      font-weight: 500;
    }

    .tags-container .contact-tag.hot {
      background: linear-gradient(135deg, #fee2e2, #fecaca);
      border-color: #f87171;
      color: #b91c1c;
    }

    .tags-container .contact-tag.vip {
      background: linear-gradient(135deg, #fef3c7, #fde68a);
      border-color: #fbbf24;
      color: #b45309;
    }

    .tags-container .contact-tag .remove-tag {
      cursor: pointer;
      font-size: 0.9rem;
      line-height: 1;
      opacity: 0.6;
      margin-left: 2px;
    }

    .tags-container .contact-tag .remove-tag:hover {
      opacity: 1;
    }

    .add-tag-row {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
    }

    .add-tag-row input {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid var(--gray-300);
      border-radius: var(--radius-md);
      font-size: 0.8rem;
    }

    .add-tag-row input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .add-tag-btn {
      padding: 6px 12px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s;
    }

    .add-tag-btn:hover {
      background: var(--primary-dark);
    }

    .suggested-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .suggested-tag {
      padding: 3px 8px;
      background: var(--gray-100);
      border: 1px dashed var(--gray-300);
      border-radius: 10px;
      font-size: 0.65rem;
      color: var(--gray-600);
      cursor: pointer;
      transition: all 0.15s;
    }

    .suggested-tag:hover {
      background: var(--gray-200);
      border-color: var(--gray-400);
      color: var(--gray-800);
    }

    /* Activity Tab Styles */
    .activity-item {
      display: flex;
      gap: 10px;
      padding: 10px 0;
      border-bottom: 1px solid var(--gray-100);
    }

    .activity-item .activity-icon {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      flex-shrink: 0;
    }

    .activity-item .activity-icon.call { background: #dcfce7; }
    .activity-item .activity-icon.sms { background: #dbeafe; }
    .activity-item .activity-icon.note { background: #fef3c7; }
    .activity-item .activity-icon.email { background: #f3e8ff; }
    .activity-item .activity-icon.created { background: #e0f2fe; }

    .activity-item .activity-content {
      flex: 1;
      min-width: 0;
    }

    .activity-item .activity-title {
      font-size: 0.8rem;
      font-weight: 500;
      color: var(--gray-900);
    }

    .activity-item .activity-desc {
      font-size: 0.75rem;
      color: var(--gray-600);
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .activity-item .activity-time {
      font-size: 0.65rem;
      color: var(--gray-500);
      margin-top: 4px;
    }

    /* Notes Tab Styles */
    .note-input-area {
      margin-bottom: 12px;
    }

    .note-input-area textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--gray-300);
      border-radius: var(--radius-md);
      font-size: 0.8rem;
      resize: none;
      font-family: inherit;
    }

    .note-input-area textarea:focus {
      outline: none;
      border-color: var(--primary);
    }

    .note-input-area button {
      margin-top: 6px;
      padding: 6px 12px;
      background: #7c3aed;
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 0.75rem;
      cursor: pointer;
    }

    .note-input-area button:hover {
      background: #6d28d9;
    }

    .note-item {
      padding: 10px;
      background: #fefce8;
      border-radius: var(--radius-md);
      margin-bottom: 8px;
      border-left: 3px solid #facc15;
    }

    .note-item .note-text {
      font-size: 0.8rem;
      color: var(--gray-900);
      line-height: 1.4;
    }

    .note-item .note-meta {
      font-size: 0.65rem;
      color: var(--gray-500);
      margin-top: 4px;
    }

    /* History Tab Styles */
    .history-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 0;
      border-bottom: 1px solid var(--gray-100);
    }

    .history-item .history-icon {
      font-size: 1rem;
    }

    .history-item .history-info {
      flex: 1;
    }

    .history-item .history-title {
      font-size: 0.8rem;
      font-weight: 500;
    }

    .history-item .history-date {
      font-size: 0.7rem;
      color: var(--gray-500);
    }

    .history-item .history-outcome {
      padding: 3px 8px;
      border-radius: var(--radius-sm);
      font-size: 0.65rem;
      font-weight: 500;
    }

    .history-item .history-outcome.connected { background: #dcfce7; color: #166534; }
    .history-item .history-outcome.no-answer { background: #fee2e2; color: #dc2626; }
    .history-item .history-outcome.callback { background: #dbeafe; color: #1d4ed8; }
    .history-item .history-outcome.booked { background: #d1fae5; color: #065f46; }

    /* Empty state for tabs */
    .tab-empty-state {
      text-align: center;
      padding: var(--spacing-xl);
      color: var(--gray-500);
    }

    .tab-empty-state .empty-icon {
      font-size: 2rem;
      margin-bottom: var(--spacing-sm);
    }

    /* Right Column - AI + Transcript */
    .call-main {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--spacing-md);
      height: 100%;
      overflow: hidden;
    }

    /* Hide old time tracking panel in new layout */
    .time-tracking-panel {
      display: none;
    }
  </style>
</head>
<body>
  <div class="app-layout">
    <!-- Sidebar Overlay (mobile) -->
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebar()"></div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <a href="dashboard.html" class="sidebar-logo">
          <div class="sidebar-logo-icon">AI</div>
          <span class="sidebar-logo-text">DialPro</span>
        </a>
        <button class="sidebar-toggle" onclick="toggleSidebar()" title="Toggle sidebar">
          <span></span>
        </button>
      </div>

      <nav class="sidebar-nav">
        <!-- Main Section -->
        <div class="sidebar-nav-section">
          <a href="dashboard.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">Dashboard</span>
          </a>
          <a href="newsfeed.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">Newsfeed</span>
          </a>
          <a href="activity.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">Activity</span>
          </a>
        </div>

        <!-- Contacts Section -->
        <div class="sidebar-nav-section">
          <div class="sidebar-nav-section-title">Contacts</div>
          <a href="contacts.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">All Contacts</span>
          </a>
          <a href="contacts-import.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">Import</span>
          </a>
        </div>

        <!-- Communication Section -->
        <div class="sidebar-nav-section">
          <div class="sidebar-nav-section-title">Communication</div>
          <a href="sms.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">SMS</span>
            <span class="sidebar-nav-badge">3</span>
          </a>
          <a href="call.html" class="sidebar-nav-item active">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">Make Call</span>
          </a>
          <a href="history.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">History</span>
          </a>
          <a href="callbacks.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">Callbacks</span>
          </a>
        </div>

        <!-- AI Agent Section -->
        <div class="sidebar-nav-section">
          <div class="sidebar-nav-section-title">AI Agent</div>
          <a href="agent-queue.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">Call Queue</span>
            <span class="sidebar-nav-badge" id="queueBadge">0</span>
          </a>
          <a href="agent-monitor.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">Live Monitor</span>
          </a>
        </div>

        <!-- Sales Section -->
        <div class="sidebar-nav-section">
          <div class="sidebar-nav-section-title">Sales</div>
          <a href="pipeline.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">Pipeline</span>
          </a>
        </div>

        <!-- Team Section -->
        <div class="sidebar-nav-section">
          <div class="sidebar-nav-section-title">Team</div>
          <a href="supervisor.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">Supervisor</span>
          </a>
          <a href="supervisor-mockup.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">Team Overview</span>
          </a>
        </div>

        <!-- Settings -->
        <div class="sidebar-nav-section" style="margin-top: auto;">
          <a href="coaching-lab.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">Coaching Lab</span>
          </a>
          <a href="settings.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon"></span>
            <span class="sidebar-nav-label">Settings</span>
          </a>
        </div>
      </nav>

      <!-- User Section -->
      <div class="sidebar-user">
        <div class="sidebar-user-avatar" id="userAvatar">SR</div>
        <div class="sidebar-user-info">
          <div class="sidebar-user-name">Sales Rep</div>
          <div class="sidebar-user-status" id="userStatus">
            <span class="status-dot"></span>
            <span id="connectionText">Connecting...</span>
          </div>
        </div>
      </div>
    </aside>

    <!-- Main Content Wrapper -->
    <div class="main-wrapper">
      <!-- Top Header -->
      <header class="top-header">
        <div class="top-header-left">
          <button class="mobile-menu-btn" onclick="openSidebar()"></button>
          <h1 class="page-title">Call</h1>
        </div>
        <div class="top-header-right">
          <!-- Call Mode Selector -->
          <div class="call-mode-toggle desktop-only">
            <span class="mode-label">Mode:</span>
            <select class="input" id="callModeSelect" style="width: 150px; font-size: 0.75rem;">
              <option value="basic">Basic (Post-call)</option>
              <option value="advanced">Deepgram (Live)</option>
              <option value="twilio-realtime">Twilio (Live)</option>
            </select>
          </div>
          <select class="input desktop-only" id="audioDevice" style="width: 180px; font-size: 0.75rem;">
            <option value="">Loading devices...</option>
          </select>
          <div class="connection-status disconnected" id="connectionStatus">
            <span class="connection-dot"></span>
            <span class="desktop-only">Disconnected</span>
          </div>
        </div>
      </header>

      <!-- Main Content Area -->
      <main class="main-content-area" style="padding: var(--spacing-md);">
        <div class="call-page">

        <!-- =====================================================
             COLUMN 1: QUEUE COLUMN (Session Stats + Queue)
             ===================================================== -->
        <div class="queue-column">
          <!-- Session Stats Mini Bar (Collapsible) -->
          <div class="session-stats-mini" id="sessionStatsMini" onclick="toggleSessionStatsMini()">
            <div class="stats-collapsed">
              <div class="stat-group">
                <div class="stat">
                  <div class="stat-value" id="miniSessionTime">0:00:00</div>
                  <div class="stat-label">Session</div>
                </div>
                <div class="stat">
                  <div class="stat-value" id="miniCallCount">0</div>
                  <div class="stat-label">Calls</div>
                </div>
              </div>
              <span class="expand-icon">&#9660;</span>
            </div>
            <div class="stats-expanded">
              <div class="mini-stats-grid">
                <div class="mini-stat-box">
                  <div class="value talk" id="miniTalkTime">0:00</div>
                  <div class="label">Talk</div>
                </div>
                <div class="mini-stat-box">
                  <div class="value idle" id="miniIdleTime">0:00</div>
                  <div class="label">Idle</div>
                </div>
                <div class="mini-stat-box">
                  <div class="value break" id="miniBreakTime">0:00</div>
                  <div class="label">Break</div>
                </div>
              </div>
              <div class="mini-productivity">
                <div class="bar-label">
                  <span>Productivity</span>
                  <span id="miniProductivityPercent">0%</span>
                </div>
                <div class="bar">
                  <div class="bar-segment talk" id="miniProductivityTalk" style="width: 0%"></div>
                  <div class="bar-segment idle" id="miniProductivityIdle" style="width: 0%"></div>
                  <div class="bar-segment break" id="miniProductivityBreak" style="width: 0%"></div>
                </div>
              </div>
              <div class="mini-controls">
                <button class="btn-break" onclick="event.stopPropagation(); toggleSessionPause()">
                  <span id="miniPauseBtnText">Break</span>
                </button>
                <button class="btn-end" onclick="event.stopPropagation(); endSession()">End</button>
              </div>
            </div>
          </div>

          <!-- Queue Panel -->
          <div class="card queue-panel" id="queuePanel">
            <div class="queue-header">
              <h3>Call Queue</h3>
              <div class="queue-controls">
                <button class="btn btn-sm btn-secondary" onclick="clearQueue()" title="Clear Queue">Clear</button>
              </div>
            </div>

            <!-- Auto-Dial Toggle -->
            <div class="auto-dial-toggle">
              <span id="autoDialLabel">Auto-Dial</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <button class="btn btn-sm" id="pauseBtn" onclick="togglePause()" style="display: none; padding: 4px 8px; font-size: 0.75rem;"> Pause</button>
                <label class="toggle-switch" for="autoDialToggle">
                  <input type="checkbox" id="autoDialToggle" onchange="handleAutoDialToggle(this.checked)">
                  <span class="toggle-slider"></span>
                </label>
              </div>
            </div>

            <div class="delay-setting">
              <span>Delay:</span>
              <select id="dialDelay">
                <option value="0">None</option>
                <option value="3" selected>3s</option>
                <option value="5">5s</option>
                <option value="10">10s</option>
              </select>
            </div>

            <!-- Queue Stats -->
            <div class="queue-stats">
              <div class="queue-stat">
                <span>Total:</span>
                <span class="queue-stat-value" id="queueTotal">0</span>
              </div>
              <div class="queue-stat">
                <span>Done:</span>
                <span class="queue-stat-value" id="queueCompleted">0</span>
              </div>
              <div class="queue-stat">
                <span>Left:</span>
                <span class="queue-stat-value" id="queueRemaining">0</span>
              </div>
            </div>

            <!-- Queue List -->
            <div class="queue-list" id="queueList">
              <div class="queue-empty">
                <div class="queue-empty-icon"></div>
                <div>No numbers in queue</div>
                <div style="font-size: 0.75rem; margin-top: 4px;">Add numbers below</div>
              </div>
            </div>

            <!-- Add to Queue Section -->
            <div class="queue-add-section">
              <div class="queue-add-input">
                <input type="tel" class="input input-sm" id="queuePhoneInput" placeholder="Add number...">
                <button class="btn btn-sm btn-primary" onclick="addToQueue()">+</button>
              </div>
              <div style="margin-top: var(--spacing-sm);">
                <button class="btn btn-sm btn-secondary" style="width: 100%;" onclick="showBulkAddModal()">
                  Bulk Add
                </button>
              </div>
            </div>
          </div>

          <!-- Hidden old time tracking panel for JS compatibility -->
          <div class="time-tracking-panel" id="timeTrackingPanel" style="display: none;">
            <div class="time-tracking-body">
              <div class="timer-value" id="sessionWorkingTime">0:00:00</div>
              <div class="stat-value" id="sessionTalkTime">0:00</div>
              <div class="stat-value" id="sessionIdleTime">0:00</div>
              <div class="stat-value" id="sessionBreakTime">0:00</div>
              <span id="productivityPercent">0%</span>
              <div id="productivityTalk"></div>
              <div id="productivityIdle"></div>
              <div id="productivityBreak"></div>
              <div id="sessionTotalCalls">0</div>
              <div id="sessionConnectedCalls">0</div>
              <div id="sessionCallsPerHour">0.0</div>
              <span id="sessionStatusBadge"></span>
              <span id="pauseBtnIcon"></span>
              <span id="pauseBtnText"></span>
            </div>
          </div>
        </div>

        <!-- =====================================================
             COLUMN 2: CENTER COLUMN (Compact Dialer + Customer Tabs)
             ===================================================== -->
        <div class="center-column">
          <!-- Compact Dialer -->
          <div class="compact-dialer">
            <!-- Contact Search -->
            <div class="contact-search-bar">
              <input type="text" id="contactSearchInput" placeholder="Search contacts..." oninput="searchContacts(this.value)">
              <div class="search-results" id="contactSearchResults"></div>
            </div>

            <div class="dialer-display">
              <div class="dialer-number">
                <input type="tel" id="phoneInput" placeholder="Enter number to call">
              </div>
              <div class="dialer-status" id="callState">Ready</div>
              <div class="dialer-timer" id="callTimer" style="display: none;">0:00</div>
              <!-- Hidden element for compatibility -->
              <div id="phoneNumber" style="display: none;">Enter number to call</div>
            </div>

            <div class="dialer-controls">
              <button class="dialer-btn call" id="callBtn" title="Call"></button>
            </div>

            <!-- In-Call Control Bar -->
            <div class="in-call-controls" id="inCallControls">
              <div class="call-controls-row">
                <button class="call-control-btn mute" id="callControlMute" onclick="toggleMute()" title="Mute">
                  <span class="icon"></span>
                  <span>Mute</span>
                </button>
                <button class="call-control-btn hold" id="callControlHold" onclick="toggleHold()" title="Hold">
                  <span class="icon"></span>
                  <span>Hold</span>
                </button>
                <button class="call-control-btn" onclick="toggleDialpad()" title="Keypad">
                  <span class="icon"></span>
                  <span>Keypad</span>
                </button>
                <button class="call-control-btn transfer" onclick="openTransferModal()" title="Transfer">
                  <span class="icon"></span>
                  <span>Transfer</span>
                </button>
                <button class="call-control-btn" onclick="addQuickNote()" title="Note">
                  <span class="icon"></span>
                  <span>Note</span>
                </button>
                <button class="call-control-btn end" id="callControlEnd" onclick="endCall()" title="End Call">
                  <span class="icon"></span>
                  <span>End</span>
                </button>
              </div>
            </div>

            <div class="dialpad-toggle" onclick="toggleDialpad()">
              <span id="dialpadToggleText">Show Keypad</span> 
            </div>

            <div class="dialpad-grid" id="dialpadGrid">
              <button class="dialpad-btn" onclick="dialDigit('1')">1</button>
              <button class="dialpad-btn" onclick="dialDigit('2')">2</button>
              <button class="dialpad-btn" onclick="dialDigit('3')">3</button>
              <button class="dialpad-btn" onclick="dialDigit('4')">4</button>
              <button class="dialpad-btn" onclick="dialDigit('5')">5</button>
              <button class="dialpad-btn" onclick="dialDigit('6')">6</button>
              <button class="dialpad-btn" onclick="dialDigit('7')">7</button>
              <button class="dialpad-btn" onclick="dialDigit('8')">8</button>
              <button class="dialpad-btn" onclick="dialDigit('9')">9</button>
              <button class="dialpad-btn" onclick="dialDigit('*')">*</button>
              <button class="dialpad-btn" onclick="dialDigit('0')">0</button>
              <button class="dialpad-btn" onclick="dialDigit('#')">#</button>
            </div>

            <!-- Hidden elements for compatibility -->
            <button class="dialer-btn mute hidden" id="muteBtn" title="Mute"></button>
            <button class="dialer-btn end hidden" id="endCallBtn" title="End Call"></button>
            <button class="dialer-btn hold hidden" id="holdBtn" title="Hold"></button>
          </div>

          <!-- Customer Tabbed Panel -->
          <div class="customer-tabbed-panel" id="customerTabbedPanel">
            <div class="customer-header">
              <div class="customer-avatar" id="customerAvatar">?</div>
              <div class="customer-info">
                <h3 id="customerName">No Contact Selected</h3>
                <div class="meta" id="customerMeta">Select a contact or enter a number</div>
              </div>
              <div class="customer-tags" id="customerTags">
                <!-- Tags will be inserted dynamically -->
              </div>
            </div>

            <div class="tab-nav">
              <button class="tab-btn active" onclick="switchCustomerTab('profile')">Profile</button>
              <button class="tab-btn" onclick="switchCustomerTab('activity')">Activity</button>
              <button class="tab-btn" onclick="switchCustomerTab('notes')">Notes</button>
              <button class="tab-btn" onclick="switchCustomerTab('history')">History</button>
            </div>

            <div class="tab-content">
              <!-- Profile Tab -->
              <div class="tab-pane active" id="tab-profile">
                <div class="profile-section">
                  <h4>Contact Details</h4>
                  <div class="profile-row">
                    <span class="label">Phone</span>
                    <span class="value" id="profilePhone">-</span>
                  </div>
                  <div class="profile-row">
                    <span class="label">Email</span>
                    <span class="value" id="profileEmail">-</span>
                  </div>
                  <div class="profile-row">
                    <span class="label">Company</span>
                    <span class="value" id="profileCompany">-</span>
                  </div>
                  <div class="profile-row">
                    <span class="label">Website</span>
                    <span class="value" id="profileWebsite">-</span>
                  </div>
                </div>
                <div class="profile-section">
                  <h4>Lead Info</h4>
                  <div class="profile-row">
                    <span class="label">Source</span>
                    <span class="value" id="profileSource">-</span>
                  </div>
                  <div class="profile-row">
                    <span class="label">Campaign</span>
                    <span class="value" id="profileCampaign">-</span>
                  </div>
                  <div class="profile-row">
                    <span class="label">Status</span>
                    <span class="value" id="profileStatus">-</span>
                  </div>
                  <div class="profile-row">
                    <span class="label">Value</span>
                    <span class="value" id="profileValue">-</span>
                  </div>
                  <div class="profile-row">
                    <span class="label">Created</span>
                    <span class="value" id="profileCreated">-</span>
                  </div>
                </div>

                <div class="profile-section tags-section">
                  <h4>Tags</h4>
                  <div class="tags-container" id="profileTags">
                    <span class="no-tags">No tags yet</span>
                  </div>
                  <div class="add-tag-row">
                    <input type="text" id="newTagInput" placeholder="Add a tag..." onkeypress="if(event.key==='Enter') addContactTag()">
                    <button class="add-tag-btn" onclick="addContactTag()">+</button>
                  </div>
                  <div class="suggested-tags" id="suggestedTags">
                    <span class="suggested-tag" onclick="addSuggestedTag('Hot Lead')">Hot Lead</span>
                    <span class="suggested-tag" onclick="addSuggestedTag('Follow Up')">Follow Up</span>
                    <span class="suggested-tag" onclick="addSuggestedTag('Interested')">Interested</span>
                    <span class="suggested-tag" onclick="addSuggestedTag('Not Interested')">Not Interested</span>
                    <span class="suggested-tag" onclick="addSuggestedTag('Call Back')">Call Back</span>
                    <span class="suggested-tag" onclick="addSuggestedTag('VIP')">VIP</span>
                  </div>
                </div>
              </div>

              <!-- Activity Tab -->
              <div class="tab-pane" id="tab-activity">
                <div id="activityList">
                  <div class="tab-empty-state">
                    <div class="empty-icon"></div>
                    <div>No activity yet</div>
                    <div style="font-size: 0.75rem; margin-top: 4px;">Activity will appear here once a contact is selected</div>
                  </div>
                </div>
              </div>

              <!-- Notes Tab -->
              <div class="tab-pane" id="tab-notes">
                <div class="note-input-area">
                  <textarea id="callNotes" rows="3" placeholder="Add a note about this customer..."></textarea>
                  <button onclick="saveCustomerNote()">Save Note</button>
                </div>
                <div id="notesList">
                  <!-- Notes will be inserted dynamically -->
                </div>
              </div>

              <!-- History Tab -->
              <div class="tab-pane" id="tab-history">
                <div id="historyList">
                  <div class="tab-empty-state">
                    <div class="empty-icon"></div>
                    <div>No call history</div>
                    <div style="font-size: 0.75rem; margin-top: 4px;">Previous calls will appear here</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- =====================================================
             COLUMN 3: RIGHT COLUMN (AI Coach + Transcript)
             ===================================================== -->
        <div class="call-main">
          <!-- AI Coaching Panel (Left - 50%) -->
          <div class="ai-coaching-panel" id="aiCoachingPanel">
            <div class="ai-coaching-header">
              <h3><span class="ai-icon"></span> AI Coach</h3>
              <select class="knowledge-base-select" id="knowledgeBaseSelect">
                <option value="general">General Sales</option>
                <option value="cleaning">Cleaning Services</option>
                <option value="solar">Solar Sales</option>
                <option value="insurance">Insurance</option>
              </select>
            </div>
            <div class="ai-coaching-content" id="aiCoachingContent">
              <div class="ai-empty-state" id="aiEmptyState">
                <div class="ai-empty-icon"></div>
                <div class="ai-empty-title">AI Coach Ready</div>
                <div class="ai-empty-text">Start a call to receive real-time coaching tips and objection handling suggestions.</div>
              </div>
            </div>
          </div>

          <!-- Transcript Panel (Right - 50%) -->
          <div class="transcript-panel">
            <div class="transcript-header">
              <h3>Live Transcript</h3>
              <div id="transcriptStatus" class="badge badge-info">Waiting for call</div>
            </div>
            <div class="transcript-search">
              <span></span>
              <input type="text" id="transcriptSearchInput" placeholder="Search transcript..." onkeyup="searchTranscript(this.value)">
            </div>
            <div class="transcript-scroll" id="transcriptContainer">
              <div class="empty-state">
                <div class="empty-state-icon"></div>
                <div class="empty-state-title">No transcript yet</div>
                <div class="empty-state-text">Start a call to see real-time transcription</div>
              </div>
            </div>

            <!-- Speaking Indicator -->
            <div class="speaking-indicator hidden" id="speakingIndicator">
              <div class="dots">
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
              </div>
              <span id="speakingText">Customer is speaking...</span>
            </div>
          </div>

          <!-- Call Outcome Panel (shown after call ends) -->
          <div class="outcome-panel hidden" id="outcomePanel">
            <h4 class="mb-3">How did this call go?</h4>
            <div class="outcome-buttons">
              <button class="outcome-btn" data-outcome="booked">
                <div class="icon"></div>
                <div class="label">Booked</div>
              </button>
              <button class="outcome-btn" data-outcome="callback">
                <div class="icon"></div>
                <div class="label">Callback</div>
              </button>
              <button class="outcome-btn" data-outcome="not_interested">
                <div class="icon"></div>
                <div class="label">Not Interested</div>
              </button>
              <button class="outcome-btn" data-outcome="no_answer">
                <div class="icon"></div>
                <div class="label">No Answer</div>
              </button>
            </div>

            <!-- Callback Scheduling -->
            <div class="hidden" id="callbackScheduler">
              <div class="grid-2 mb-3">
                <div class="form-group">
                  <label class="form-label">Date</label>
                  <input type="date" class="input" id="callbackDate">
                </div>
                <div class="form-group">
                  <label class="form-label">Time</label>
                  <input type="time" class="input" id="callbackTime">
                </div>
              </div>
              <div class="form-group">
                <label class="form-label">Reason</label>
                <input type="text" class="input" id="callbackReason" placeholder="e.g., Follow up on quote">
              </div>
            </div>

            <div class="form-group">
              <label class="form-label">Notes</label>
              <textarea class="input" id="outcomeNotes" rows="2" placeholder="Add notes about this call..."></textarea>
            </div>

            <div class="flex gap-2 justify-end">
              <button class="btn btn-secondary" onclick="skipOutcome()">Skip</button>
              <button class="btn btn-primary" onclick="saveOutcome()">Save & Close</button>
            </div>
          </div>
        </div>
      </div>
      </main>
    </div>

    <!-- Mobile Bottom Nav -->
    <nav class="mobile-bottom-nav">
      <div class="mobile-nav-items">
        <a href="dashboard.html" class="mobile-nav-item">
          <span class="mobile-nav-icon"></span>
          <span>Dashboard</span>
        </a>
        <a href="newsfeed.html" class="mobile-nav-item">
          <span class="mobile-nav-icon"></span>
          <span>Feed</span>
        </a>
        <a href="history.html" class="mobile-nav-item">
          <span class="mobile-nav-icon"></span>
          <span>History</span>
        </a>
        <a href="callbacks.html" class="mobile-nav-item">
          <span class="mobile-nav-icon"></span>
          <span>Callbacks</span>
        </a>
      </div>
    </nav>
  </div>

  <!-- Mobile Call Screen -->
  <div class="mobile-call-screen" id="mobileCallScreen">
    <div class="mobile-call-header">
      <button class="mobile-call-back" onclick="minimizeMobileCall()"></button>
      <span class="mobile-call-status" id="mobileCallStatus">Calling...</span>
      <button class="mobile-call-more"></button>
    </div>

    <div class="mobile-call-contact">
      <div class="mobile-call-avatar" id="mobileCallAvatar">?</div>
      <div class="mobile-call-name" id="mobileCallName">Unknown</div>
      <div class="mobile-call-number" id="mobileCallNumber"></div>
      <div class="mobile-call-timer" id="mobileCallTimer">0:00</div>
    </div>

    <!-- AI Coach -->
    <div class="mobile-ai-coach" id="mobileAiCoach" style="display: none;">
      <div class="mobile-ai-coach-header">AI Coach</div>
      <div class="mobile-ai-coach-text" id="mobileAiCoachText">Suggestion will appear here...</div>
    </div>

    <div class="mobile-call-actions">
      <div class="mobile-call-actions-grid">
        <button class="mobile-action-btn" onclick="toggleMobileMute(this)">
          <div class="icon-circle"></div>
          <span class="label">Mute</span>
        </button>
        <button class="mobile-action-btn" onclick="toggleMobileHold(this)">
          <div class="icon-circle"></div>
          <span class="label">Hold</span>
        </button>
        <button class="mobile-action-btn">
          <div class="icon-circle"></div>
          <span class="label">Speaker</span>
        </button>
        <button class="mobile-action-btn" onclick="showMobileKeypad()">
          <div class="icon-circle"></div>
          <span class="label">Keypad</span>
        </button>
        <button class="mobile-action-btn">
          <div class="icon-circle"></div>
          <span class="label">SMS</span>
        </button>
        <button class="mobile-action-btn">
          <div class="icon-circle"></div>
          <span class="label">Notes</span>
        </button>
      </div>
      <div class="mobile-call-main-actions">
        <button class="mobile-end-call" onclick="endMobileCall()"></button>
      </div>
    </div>
  </div>

  <!-- Bulk Add Modal -->
  <div class="modal-overlay" id="bulkAddModal">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">Bulk Add Numbers</h3>
        <button class="modal-close" onclick="closeBulkAddModal()">&times;</button>
      </div>
      <div class="modal-body">
        <p style="font-size: 0.875rem; color: var(--gray-600); margin-bottom: var(--spacing-md);">
          Enter phone numbers, one per line. You can also paste from a spreadsheet.
        </p>
        <textarea
          class="input"
          id="bulkNumbersInput"
          rows="10"
          placeholder="(555) 123-4567&#10;555-987-6543&#10;+1 555 456 7890"
          style="font-family: monospace;"
        ></textarea>
        <div style="margin-top: var(--spacing-md); display: flex; gap: var(--spacing-sm); justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeBulkAddModal()">Cancel</button>
          <button class="btn btn-primary" onclick="processBulkAdd()">Add to Queue</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Script Modal -->
  <div class="modal-overlay" id="scriptModal">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title" id="scriptTitle">Script</h3>
        <button class="modal-close" onclick="closeScriptModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div id="scriptContent"></div>
      </div>
    </div>
  </div>

  <!-- Transfer Call Modal -->
  <div class="transfer-modal" id="transferModal">
    <div class="transfer-modal-content">
      <h3>Transfer Call</h3>

      <div class="transfer-options">
        <div class="transfer-option" onclick="selectTransferType('blind')">
          <span class="icon"></span>
          <div class="label">
            <strong>Blind Transfer</strong>
            <span>Transfer immediately without announcing</span>
          </div>
        </div>
        <div class="transfer-option" onclick="selectTransferType('warm')">
          <span class="icon"></span>
          <div class="label">
            <strong>Warm Transfer</strong>
            <span>Announce caller before transferring</span>
          </div>
        </div>
      </div>

      <div class="transfer-input-group">
        <label>Transfer to:</label>
        <input type="tel" id="transferNumber" placeholder="Enter phone number or extension">
      </div>

      <div class="transfer-modal-actions">
        <button class="cancel-btn" onclick="closeTransferModal()">Cancel</button>
        <button class="transfer-btn" onclick="executeTransfer()">Transfer</button>
      </div>
    </div>
  </div>

  <!-- Quick Note Modal -->
  <div class="transfer-modal" id="quickNoteModal">
    <div class="transfer-modal-content">
      <h3>Add Quick Note</h3>

      <div class="transfer-input-group">
        <label>Note:</label>
        <textarea id="quickNoteText" rows="4" placeholder="Enter note about this call..." style="width: 100%; padding: 10px 12px; border: 1px solid var(--gray-300); border-radius: var(--radius-md); font-size: 0.9rem; resize: vertical;"></textarea>
      </div>

      <div class="transfer-modal-actions">
        <button class="cancel-btn" onclick="closeQuickNoteModal()">Cancel</button>
        <button class="transfer-btn" onclick="saveQuickNote()">Save Note</button>
      </div>
    </div>
  </div>

  <!-- Incoming Call Modal -->
  <div class="incoming-call-overlay" id="incomingCallModal">
    <div class="incoming-call-modal">
      <div class="incoming-call-icon">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z" />
        </svg>
      </div>
      <div class="incoming-call-label">Incoming Call</div>
      <div class="incoming-call-number" id="incomingCallNumber">Unknown</div>
      <div class="incoming-call-actions">
        <div class="incoming-call-btn-wrapper">
          <button class="incoming-call-btn decline" id="declineCallBtn" title="Decline">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
          <span class="incoming-call-btn-label">Decline</span>
        </div>
        <div class="incoming-call-btn-wrapper">
          <button class="incoming-call-btn answer" id="answerCallBtn" title="Answer">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z" />
            </svg>
          </button>
          <span class="incoming-call-btn-label">Answer</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Reconnecting Overlay -->
  <div class="reconnecting-overlay hidden" id="reconnectingOverlay">
    <div class="reconnecting-box">
      <div class="reconnecting-spinner"></div>
      <h4 id="reconnectingTitle">Reconnecting...</h4>
      <p id="reconnectingMessage" style="color: var(--gray-600); font-size: 0.875rem;">
        Attempting to restore connection. Please wait.
      </p>
      <button class="btn btn-secondary mt-3" onclick="cancelReconnect()">Switch to Basic Mode</button>
    </div>
  </div>

  <!-- Auto-Dial Countdown Overlay -->
  <div class="countdown-overlay hidden" id="countdownOverlay">
    <div class="countdown-box">
      <div class="countdown-circle">
        <span class="countdown-number" id="countdownNumber">3</span>
      </div>
      <h4 class="countdown-title">Next Call In...</h4>
      <p class="countdown-contact" id="countdownContact">Loading next contact...</p>
      <button class="btn btn-secondary" onclick="cancelCountdown()">Cancel Auto-Dial</button>
    </div>
  </div>

  <!-- Break Warning Modal -->
  <div class="break-warning-overlay" id="breakWarningModal">
    <div class="break-warning-modal">
      <div class="break-warning-icon">&#9749;</div>
      <div class="break-warning-title">Are you on a break?</div>
      <div class="break-warning-text">You've been idle for a while. Let us know if you're taking a break so we can track your time accurately.</div>
      <div class="break-warning-actions">
        <button class="btn btn-secondary" onclick="dismissBreakWarning()">Back to Work</button>
        <button class="btn btn-primary" onclick="confirmBreak()">Yes, On Break</button>
      </div>
    </div>
  </div>

  <style>
    .countdown-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    .countdown-overlay.hidden {
      display: none;
    }
    .countdown-box {
      background: var(--gray-900, #1a1a2e);
      border-radius: 16px;
      padding: 40px;
      text-align: center;
      border: 1px solid var(--gray-700, #333);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }
    .countdown-circle {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary, #6366f1), var(--primary-dark, #4f46e5));
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 20px;
      animation: pulse 1s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    .countdown-number {
      font-size: 48px;
      font-weight: bold;
      color: white;
    }
    .countdown-title {
      color: white;
      margin-bottom: 8px;
      font-size: 1.25rem;
    }
    .countdown-contact {
      color: var(--gray-400, #9ca3af);
      margin-bottom: 24px;
      font-size: 0.95rem;
    }
  </style>

  <script>
    // State
    let device = null;
    let connection = null;
    let callStartTime = null;
    let timerInterval = null;
    let ws = null;
    let currentCallSid = null;
    let selectedOutcome = null;
    // Use fixed identity so incoming calls can reach this browser
    const repIdentity = 'sales-rep';

    // Supabase State
    let currentUser = null;
    let companyId = null;
    let currentCallRecordId = null;  // ID of the call record in Supabase
    let currentContactId = null;     // ID of the contact being called

    // Advanced Mode State
    let advancedModeEnabled = false;  // Whether user wants advanced mode
    let advancedModeActive = false;   // Whether it's actually working
    let wsReconnectAttempts = 0;
    let wsReconnectTimer = null;
    let wsMaxReconnectAttempts = 5;
    let wsReconnectDelay = 2000;  // Start with 2 seconds
    let wsLastConnectedTime = null;
    let fallbackToBasicMode = false;

    // Advanced Mode Features
    const ADVANCED_FEATURES = {
      liveTranscription: true,
      aiCoaching: true,
      speakingIndicator: true
    };

    // Knowledge Base State
    let selectedKnowledgeBaseId = null;
    let knowledgeBases = [];

    // Lead Source State
    let leadSourceData = {
      source: null,
      customSource: null,
      category: null,
      campaignName: null,
      adName: null
    };
    let leadSourceEditMode = false;

    // Queue State
    let callQueue = [];
    let currentQueueIndex = -1;
    let autoDialEnabled = false;
    let autoDialPaused = false;
    let autoDialTimeout = null;
    let countdownInterval = null;
    let pausedSecondsRemaining = 0;
    let pausedNextContact = null;

    // =====================================================
    // SESSION TRACKER - Time Tracking for Sales Reps
    // =====================================================
    const sessionTracker = {
      // Session state
      sessionId: null,
      status: 'inactive', // inactive, active, paused, completed
      startedAt: null,

      // Time tracking (in seconds)
      totalDuration: 0,
      talkTime: 0,
      idleTime: 0,
      breakTime: 0,

      // Call metrics
      totalCalls: 0,
      connectedCalls: 0,
      bookedCalls: 0,

      // Internal timers
      updateInterval: null,
      currentMode: 'idle', // 'talk', 'idle', 'break'
      modeStartTime: null,
      lastActivityAt: null,

      // Settings
      breakDetectionEnabled: false,
      breakDetectionMinutes: 5,
      breakWarningShown: false,

      // Initialize the tracker
      async init() {
        console.log('SessionTracker: Initializing...');
        await this.loadSettings();
        await this.recoverSession();
        this.updateUI();
      },

      // Load company settings for break detection
      async loadSettings() {
        try {
          const { data: { user } } = await supabase.auth.getUser();
          if (!user) return;

          // Get company_id from company_members
          const { data: memberData } = await supabase
            .from('company_members')
            .select('company_id')
            .eq('user_id', user.id)
            .limit(1)
            .maybeSingle();

          if (memberData?.company_id) {
            const { data: settings } = await supabase
              .from('company_settings')
              .select('break_detection_enabled, break_detection_minutes')
              .eq('company_id', memberData.company_id)
              .limit(1)
              .maybeSingle();

            if (settings) {
              this.breakDetectionEnabled = settings.break_detection_enabled || false;
              this.breakDetectionMinutes = settings.break_detection_minutes || 5;
            }
          }
        } catch (error) {
          console.error('SessionTracker: Error loading settings', error);
        }
      },

      // Recover session from localStorage (for page refresh resilience)
      async recoverSession() {
        try {
          const saved = localStorage.getItem('sessionTracker');
          if (!saved) return;

          const data = JSON.parse(saved);

          // Check if session is from today
          const savedDate = new Date(data.startedAt).toDateString();
          const today = new Date().toDateString();

          if (savedDate !== today) {
            // Session from previous day, clear it
            localStorage.removeItem('sessionTracker');
            return;
          }

          // Restore state
          this.sessionId = data.sessionId;
          this.status = data.status;
          this.startedAt = new Date(data.startedAt);
          this.totalDuration = data.totalDuration || 0;
          this.talkTime = data.talkTime || 0;
          this.idleTime = data.idleTime || 0;
          this.breakTime = data.breakTime || 0;
          this.totalCalls = data.totalCalls || 0;
          this.connectedCalls = data.connectedCalls || 0;
          this.bookedCalls = data.bookedCalls || 0;
          this.currentMode = data.currentMode || 'idle';
          this.lastActivityAt = data.lastActivityAt ? new Date(data.lastActivityAt) : null;

          // If session was active, resume it
          if (this.status === 'active') {
            // Calculate time passed since last save
            const lastSaveTime = new Date(data.savedAt);
            const elapsedSeconds = Math.floor((Date.now() - lastSaveTime.getTime()) / 1000);

            // Add elapsed time to appropriate category
            if (this.currentMode === 'talk') {
              this.talkTime += elapsedSeconds;
            } else if (this.currentMode === 'break') {
              this.breakTime += elapsedSeconds;
            } else {
              this.idleTime += elapsedSeconds;
            }

            // Recalculate total duration
            this.totalDuration = Math.floor((Date.now() - this.startedAt.getTime()) / 1000);

            this.startUpdateLoop();
            console.log('SessionTracker: Recovered session', this.sessionId);
          }
        } catch (error) {
          console.error('SessionTracker: Error recovering session', error);
          localStorage.removeItem('sessionTracker');
        }
      },

      // Save session to localStorage
      saveToLocalStorage() {
        const data = {
          sessionId: this.sessionId,
          status: this.status,
          startedAt: this.startedAt?.toISOString(),
          totalDuration: this.totalDuration,
          talkTime: this.talkTime,
          idleTime: this.idleTime,
          breakTime: this.breakTime,
          totalCalls: this.totalCalls,
          connectedCalls: this.connectedCalls,
          bookedCalls: this.bookedCalls,
          currentMode: this.currentMode,
          lastActivityAt: this.lastActivityAt?.toISOString(),
          savedAt: new Date().toISOString()
        };
        localStorage.setItem('sessionTracker', JSON.stringify(data));
      },

      // Auto-start session when first call is made
      async startSession() {
        if (this.status === 'active') return; // Already active

        console.log('SessionTracker: Starting new session');

        try {
          const { data: { user } } = await supabase.auth.getUser();
          if (!user) {
            console.error('SessionTracker: No user for session start');
            return;
          }

          // Get company_id
          const { data: memberData } = await supabase
            .from('company_members')
            .select('company_id')
            .eq('user_id', user.id)
            .limit(1)
            .maybeSingle();

          const companyId = memberData?.company_id;

          // Create session in database
          const { data: session, error } = await supabase
            .from('rep_sessions')
            .insert({
              rep_id: user.id,
              company_id: companyId,
              status: 'active',
              started_at: new Date().toISOString()
            })
            .select('id')
            .single();

          if (error) {
            console.error('SessionTracker: Error creating session', error);
            return;
          }

          this.sessionId = session.id;
          this.status = 'active';
          this.startedAt = new Date();
          this.currentMode = 'idle';
          this.modeStartTime = Date.now();
          this.lastActivityAt = new Date();

          // Log session start event
          await this.logEvent('session_start');

          this.startUpdateLoop();
          this.updateUI();
          this.saveToLocalStorage();

          console.log('SessionTracker: Session started', this.sessionId);
        } catch (error) {
          console.error('SessionTracker: Error starting session', error);
        }
      },

      // Called when a call starts (dialing)
      async onCallStarted() {
        // Auto-start session if not already active
        if (this.status !== 'active') {
          await this.startSession();
        }

        this.totalCalls++;
        this.lastActivityAt = new Date();
        this.breakWarningShown = false;

        // Switch to talk mode
        this.switchMode('talk');

        await this.logEvent('call_start');
        this.updateUI();
        this.saveToLocalStorage();
      },

      // Called when a call connects
      async onCallConnected() {
        this.connectedCalls++;
        this.lastActivityAt = new Date();

        await this.logEvent('call_connected');
        this.updateUI();
        this.saveToLocalStorage();
      },

      // Called when a call ends
      async onCallEnded(callSid) {
        // Calculate call duration for the event
        let callDuration = 0;
        if (this.currentMode === 'talk' && this.modeStartTime) {
          callDuration = Math.floor((Date.now() - this.modeStartTime) / 1000);
        }

        // Switch to idle mode
        this.switchMode('idle');
        this.lastActivityAt = new Date();

        await this.logEvent('call_end', { call_sid: callSid, duration_seconds: callDuration });
        this.updateUI();
        this.saveToLocalStorage();
      },

      // Called when a booking is made
      onBooking() {
        this.bookedCalls++;
        this.updateUI();
        this.saveToLocalStorage();
      },

      // Switch between modes (talk, idle, break)
      switchMode(newMode) {
        if (this.currentMode === newMode) return;

        // Calculate time spent in current mode
        if (this.modeStartTime) {
          const elapsed = Math.floor((Date.now() - this.modeStartTime) / 1000);

          if (this.currentMode === 'talk') {
            this.talkTime += elapsed;
          } else if (this.currentMode === 'idle') {
            this.idleTime += elapsed;
          } else if (this.currentMode === 'break') {
            this.breakTime += elapsed;
          }
        }

        this.currentMode = newMode;
        this.modeStartTime = Date.now();
      },

      // Toggle pause/break
      async togglePause() {
        if (this.status === 'active' && this.currentMode !== 'break') {
          // Start break
          this.status = 'paused';
          this.switchMode('break');
          await this.logEvent('session_pause');
        } else if (this.status === 'paused' || this.currentMode === 'break') {
          // End break
          this.status = 'active';
          this.switchMode('idle');
          await this.logEvent('session_resume');
          this.breakWarningShown = false;
        }

        this.updateUI();
        this.saveToLocalStorage();
      },

      // End the session
      async endSession() {
        if (this.status !== 'active' && this.status !== 'paused') return;

        console.log('SessionTracker: Ending session');

        // Stop update loop
        this.stopUpdateLoop();

        // Finalize any current mode time
        this.switchMode('idle');

        // Calculate final total duration
        this.totalDuration = Math.floor((Date.now() - this.startedAt.getTime()) / 1000);

        // Update database
        try {
          const { data: { user } } = await supabase.auth.getUser();
          if (!user) return;

          // Validate session exists and user owns it
          const { data: existingSession } = await supabase
            .from('rep_sessions')
            .select('id, rep_id')
            .eq('id', this.sessionId)
            .eq('rep_id', user.id)
            .limit(1)
            .maybeSingle();

          if (!existingSession) {
            console.error('SessionTracker: Session not found or not owned by user');
            return;
          }

          await supabase
            .from('rep_sessions')
            .update({
              status: 'completed',
              ended_at: new Date().toISOString(),
              total_duration_seconds: this.totalDuration,
              talk_time_seconds: this.talkTime,
              idle_time_seconds: this.idleTime,
              break_time_seconds: this.breakTime,
              total_calls: this.totalCalls,
              connected_calls: this.connectedCalls,
              booked_calls: this.bookedCalls,
              updated_at: new Date().toISOString()
            })
            .eq('id', this.sessionId);

          await this.logEvent('session_end');
        } catch (error) {
          console.error('SessionTracker: Error ending session', error);
        }

        // Reset state
        this.status = 'completed';
        localStorage.removeItem('sessionTracker');

        // Show summary
        this.showEndSessionSummary();

        // Reset for new session
        this.resetState();
        this.updateUI();
      },

      // Reset state for new session
      resetState() {
        this.sessionId = null;
        this.status = 'inactive';
        this.startedAt = null;
        this.totalDuration = 0;
        this.talkTime = 0;
        this.idleTime = 0;
        this.breakTime = 0;
        this.totalCalls = 0;
        this.connectedCalls = 0;
        this.bookedCalls = 0;
        this.currentMode = 'idle';
        this.modeStartTime = null;
        this.lastActivityAt = null;
        this.breakWarningShown = false;
      },

      // Show end session summary
      showEndSessionSummary() {
        const hours = Math.floor(this.totalDuration / 3600);
        const mins = Math.floor((this.totalDuration % 3600) / 60);
        const talkPercent = this.totalDuration > 0
          ? Math.round((this.talkTime / this.totalDuration) * 100)
          : 0;
        const callsPerHour = this.totalDuration > 0
          ? (this.totalCalls / (this.totalDuration / 3600)).toFixed(1)
          : 0;

        const message = `Session Complete!\n\n` +
          `Duration: ${hours}h ${mins}m\n` +
          `Calls Made: ${this.totalCalls}\n` +
          `Connected: ${this.connectedCalls}\n` +
          `Bookings: ${this.bookedCalls}\n` +
          `Talk Time: ${talkPercent}%\n` +
          `Calls/Hour: ${callsPerHour}`;

        alert(message);
      },

      // Log event to database
      async logEvent(eventType, metadata = {}) {
        if (!this.sessionId) return;

        try {
          const { data: { user } } = await supabase.auth.getUser();
          if (!user) return;

          // Get company_id
          const { data: memberData } = await supabase
            .from('company_members')
            .select('company_id')
            .eq('user_id', user.id)
            .limit(1)
            .maybeSingle();

          await supabase
            .from('rep_session_events')
            .insert({
              session_id: this.sessionId,
              rep_id: user.id,
              company_id: memberData?.company_id,
              event_type: eventType,
              call_sid: metadata.call_sid || null,
              duration_seconds: metadata.duration_seconds || null,
              metadata: metadata
            });
        } catch (error) {
          console.error('SessionTracker: Error logging event', error);
        }
      },

      // Save current state to database (periodic sync)
      async syncToDatabase() {
        if (!this.sessionId || this.status === 'inactive') return;

        try {
          const { data: { user } } = await supabase.auth.getUser();
          if (!user) return;

          await supabase
            .from('rep_sessions')
            .update({
              total_duration_seconds: this.totalDuration,
              talk_time_seconds: this.talkTime,
              idle_time_seconds: this.idleTime,
              break_time_seconds: this.breakTime,
              total_calls: this.totalCalls,
              connected_calls: this.connectedCalls,
              booked_calls: this.bookedCalls,
              last_activity_at: this.lastActivityAt?.toISOString(),
              updated_at: new Date().toISOString()
            })
            .eq('id', this.sessionId)
            .eq('rep_id', user.id);
        } catch (error) {
          console.error('SessionTracker: Error syncing to database', error);
        }
      },

      // Start the update loop
      startUpdateLoop() {
        if (this.updateInterval) return;

        this.updateInterval = setInterval(() => {
          this.tick();
        }, 1000);
      },

      // Stop the update loop
      stopUpdateLoop() {
        if (this.updateInterval) {
          clearInterval(this.updateInterval);
          this.updateInterval = null;
        }
      },

      // Tick function called every second
      tick() {
        if (this.status !== 'active' && this.status !== 'paused') return;

        // Update total duration
        this.totalDuration = Math.floor((Date.now() - this.startedAt.getTime()) / 1000);

        // Update current mode time
        if (this.modeStartTime) {
          const elapsed = Math.floor((Date.now() - this.modeStartTime) / 1000);

          // Calculate running totals (base + current mode elapsed)
          const runningTalkTime = this.currentMode === 'talk'
            ? this.talkTime + elapsed
            : this.talkTime;
          const runningIdleTime = this.currentMode === 'idle'
            ? this.idleTime + elapsed
            : this.idleTime;
          const runningBreakTime = this.currentMode === 'break'
            ? this.breakTime + elapsed
            : this.breakTime;

          // Update UI with running totals
          this.updateUIWithTimes(runningTalkTime, runningIdleTime, runningBreakTime);
        }

        // Check for break warning
        this.checkBreakWarning();

        // Save to localStorage every 5 seconds
        if (this.totalDuration % 5 === 0) {
          this.saveToLocalStorage();
        }

        // Sync to database every 30 seconds
        if (this.totalDuration % 30 === 0) {
          this.syncToDatabase();
        }
      },

      // Check if we should show break warning
      checkBreakWarning() {
        if (!this.breakDetectionEnabled) return;
        if (this.breakWarningShown) return;
        if (this.currentMode !== 'idle') return;
        if (this.status !== 'active') return;

        const idleMinutes = Math.floor((Date.now() - this.modeStartTime) / 60000);

        if (idleMinutes >= this.breakDetectionMinutes) {
          this.breakWarningShown = true;
          showBreakWarning();
        }
      },

      // Update UI with specific times (for running display)
      updateUIWithTimes(talkTime, idleTime, breakTime) {
        // Working time (with null checks for redesigned UI)
        const workingTimeEl = document.getElementById('sessionWorkingTime');
        if (workingTimeEl) {
          workingTimeEl.textContent = this.formatDuration(this.totalDuration);
          // Add on-call class when in talk mode
          if (this.currentMode === 'talk') {
            workingTimeEl.classList.add('on-call');
          } else {
            workingTimeEl.classList.remove('on-call');
          }
        }

        // Time stats (with null checks)
        const talkTimeEl = document.getElementById('sessionTalkTime');
        const idleTimeEl = document.getElementById('sessionIdleTime');
        const breakTimeEl = document.getElementById('sessionBreakTime');
        if (talkTimeEl) talkTimeEl.textContent = this.formatDurationShort(talkTime);
        if (idleTimeEl) idleTimeEl.textContent = this.formatDurationShort(idleTime);
        if (breakTimeEl) breakTimeEl.textContent = this.formatDurationShort(breakTime);

        // Productivity bar
        const total = talkTime + idleTime + breakTime;
        if (total > 0) {
          const talkPercent = (talkTime / total) * 100;
          const idlePercent = (idleTime / total) * 100;
          const breakPercent = (breakTime / total) * 100;

          const prodTalk = document.getElementById('productivityTalk');
          const prodIdle = document.getElementById('productivityIdle');
          const prodBreak = document.getElementById('productivityBreak');
          const prodPercent = document.getElementById('productivityPercent');
          if (prodTalk) prodTalk.style.width = talkPercent + '%';
          if (prodIdle) prodIdle.style.width = idlePercent + '%';
          if (prodBreak) prodBreak.style.width = breakPercent + '%';
          if (prodPercent) prodPercent.textContent = Math.round(talkPercent) + '%';
        }

        // Call metrics (with null checks)
        const totalCallsEl = document.getElementById('sessionTotalCalls');
        const connectedCallsEl = document.getElementById('sessionConnectedCalls');
        if (totalCallsEl) totalCallsEl.textContent = this.totalCalls;
        if (connectedCallsEl) connectedCallsEl.textContent = this.connectedCalls;

        // Calls per hour
        const hours = this.totalDuration / 3600;
        const callsPerHour = hours > 0 ? (this.totalCalls / hours).toFixed(1) : '0.0';
        const callsPerHourEl = document.getElementById('sessionCallsPerHour');
        if (callsPerHourEl) callsPerHourEl.textContent = callsPerHour;
      },

      // Update UI
      updateUI() {
        // Status badge
        const statusBadge = document.getElementById('sessionStatusBadge');
        if (statusBadge) {
          if (this.status === 'active') {
            statusBadge.textContent = 'Active';
            statusBadge.className = 'session-status active';
          } else if (this.status === 'paused') {
            statusBadge.textContent = 'On Break';
            statusBadge.className = 'session-status paused';
          } else {
            statusBadge.textContent = 'Not Started';
            statusBadge.className = 'session-status inactive';
          }
        }

        // Pause button (may not exist in redesigned UI)
        const pauseBtn = document.getElementById('sessionPauseBtn');
        const pauseBtnIcon = document.getElementById('pauseBtnIcon');
        const pauseBtnText = document.getElementById('pauseBtnText');

        if (this.status === 'paused' || this.currentMode === 'break') {
          if (pauseBtnIcon) pauseBtnIcon.innerHTML = '&#9658;'; // Play icon
          if (pauseBtnText) pauseBtnText.textContent = 'Resume';
          pauseBtn?.classList.remove('btn-pause');
          pauseBtn?.classList.add('btn-primary');
        } else {
          if (pauseBtnIcon) pauseBtnIcon.innerHTML = '&#9616;&#9616;'; // Pause icon
          if (pauseBtnText) pauseBtnText.textContent = 'Break';
          pauseBtn?.classList.add('btn-pause');
          pauseBtn?.classList.remove('btn-primary');
        }

        // Update times
        this.updateUIWithTimes(this.talkTime, this.idleTime, this.breakTime);

        // Update mini session stats (Design 6)
        if (typeof updateMiniSessionStats === 'function') {
          updateMiniSessionStats();
        }
      },

      // Format duration as H:MM:SS
      formatDuration(seconds) {
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = seconds % 60;
        return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
      },

      // Format duration as M:SS
      formatDurationShort(seconds) {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m}:${s.toString().padStart(2, '0')}`;
      }
    };

    // Time Tracking Panel UI Functions
    function toggleTimeTrackingPanel() {
      const panel = document.getElementById('timeTrackingPanel');
      panel.classList.toggle('collapsed');
    }

    function toggleSessionPause() {
      sessionTracker.togglePause();
    }

    async function endSession() {
      if (confirm('Are you sure you want to end your session? This will save your stats.')) {
        await sessionTracker.endSession();
      }
    }

    // Break Warning Functions
    function showBreakWarning() {
      document.getElementById('breakWarningModal').classList.add('active');
    }

    function hideBreakWarning() {
      document.getElementById('breakWarningModal').classList.remove('active');
    }

    function dismissBreakWarning() {
      hideBreakWarning();
      sessionTracker.lastActivityAt = new Date();
      sessionTracker.breakWarningShown = false;
    }

    function confirmBreak() {
      hideBreakWarning();
      sessionTracker.togglePause();
    }

    // Pause/Resume functions
    function togglePause() {
      if (!autoDialEnabled) return;

      const pauseBtn = document.getElementById('pauseBtn');
      const label = document.getElementById('autoDialLabel');

      if (autoDialPaused) {
        // Resume
        autoDialPaused = false;
        pauseBtn.textContent = ' Pause';
        pauseBtn.style.background = '';
        label.textContent = 'Auto-Dial: ON';
        label.style.color = 'var(--success, #22c55e)';

        // Resume the countdown if we have time remaining
        if (pausedSecondsRemaining > 0 && pausedNextContact) {
          showCountdown(pausedSecondsRemaining, pausedNextContact);
          autoDialTimeout = setTimeout(() => {
            hideCountdown();
            dialNextInQueue();
          }, pausedSecondsRemaining * 1000);
        } else if (callQueue.some(i => i.status === 'pending')) {
          // No countdown was active, start fresh
          dialNextInQueue();
        }

        showNotification('Auto-dial resumed', 'info');
      } else {
        // Pause
        autoDialPaused = true;
        pauseBtn.textContent = ' Resume';
        pauseBtn.style.background = 'var(--warning, #f59e0b)';
        label.textContent = 'Auto-Dial: PAUSED';
        label.style.color = 'var(--warning, #f59e0b)';

        // Save current countdown state
        const countdownEl = document.getElementById('countdownNumber');
        if (countdownEl && !document.getElementById('countdownOverlay').classList.contains('hidden')) {
          pausedSecondsRemaining = parseInt(countdownEl.textContent) || 0;
          pausedNextContact = callQueue.find(i => i.status === 'pending');
        }

        // Clear timeout and hide countdown
        if (autoDialTimeout) {
          clearTimeout(autoDialTimeout);
          autoDialTimeout = null;
        }
        hideCountdown();

        showNotification('Auto-dial paused - click Resume to continue', 'warning');
      }
    }

    function updatePauseButtonVisibility() {
      const pauseBtn = document.getElementById('pauseBtn');
      if (autoDialEnabled) {
        pauseBtn.style.display = 'inline-block';
      } else {
        pauseBtn.style.display = 'none';
        autoDialPaused = false;
        pausedSecondsRemaining = 0;
        pausedNextContact = null;
      }
    }

    // Countdown overlay functions
    function showCountdown(seconds, nextContact) {
      // Don't show countdown if paused
      if (autoDialPaused) return;

      console.log('showCountdown called:', seconds, nextContact);
      const overlay = document.getElementById('countdownOverlay');
      const numberEl = document.getElementById('countdownNumber');
      const contactEl = document.getElementById('countdownContact');

      // Set initial values
      numberEl.textContent = seconds;
      contactEl.textContent = nextContact ? `Calling: ${nextContact.name || nextContact.displayNumber}` : 'Next contact';

      // Show overlay
      overlay.classList.remove('hidden');

      // Clear any existing interval
      if (countdownInterval) {
        clearInterval(countdownInterval);
      }

      // Update countdown every second
      let remaining = seconds;
      countdownInterval = setInterval(() => {
        remaining--;
        console.log('Countdown:', remaining);
        if (remaining > 0) {
          numberEl.textContent = remaining;
        } else {
          numberEl.textContent = '0';
          clearInterval(countdownInterval);
          countdownInterval = null;
        }
      }, 1000);
    }

    function hideCountdown() {
      console.log('hideCountdown called');
      const overlay = document.getElementById('countdownOverlay');
      overlay.classList.add('hidden');

      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
    }

    function cancelCountdown() {
      console.log('cancelCountdown called');
      // Clear the timeout that would dial next
      if (autoDialTimeout) {
        clearTimeout(autoDialTimeout);
        autoDialTimeout = null;
      }

      // Hide the overlay
      hideCountdown();

      // Disable auto-dial
      autoDialEnabled = false;
      document.getElementById('autoDialToggle').checked = false;

      // Update visual feedback
      const toggleLabel = document.querySelector('.auto-dial-toggle span');
      if (toggleLabel) {
        toggleLabel.textContent = 'Auto-Dial';
        toggleLabel.style.color = '';
      }

      showNotification('Auto-dial cancelled', 'info');
    }

    // Auto-dial toggle handler (inline for reliability)
    function handleAutoDialToggle(checked) {
      console.log('Auto-dial toggled:', checked);
      autoDialEnabled = checked;
      autoDialPaused = false; // Reset pause state when toggling

      // Update pause button visibility
      updatePauseButtonVisibility();

      // Visual feedback
      const toggleLabel = document.getElementById('autoDialLabel');
      if (toggleLabel) {
        toggleLabel.textContent = checked ? 'Auto-Dial: ON' : 'Auto-Dial';
        toggleLabel.style.color = checked ? 'var(--success, #22c55e)' : '';
      }

      // Reset pause button state
      const pauseBtn = document.getElementById('pauseBtn');
      if (pauseBtn) {
        pauseBtn.textContent = ' Pause';
        pauseBtn.style.background = '';
      }

      // Clear any existing timeout and hide countdown
      if (autoDialTimeout) {
        clearTimeout(autoDialTimeout);
        autoDialTimeout = null;
      }
      hideCountdown();

      // Start dialing if enabled and not in a call
      if (autoDialEnabled && !connection && callQueue.some(item => item.status === 'pending')) {
        const delay = parseInt(document.getElementById('dialDelay').value) * 1000;
        const delaySeconds = delay / 1000;

        // Find next pending contact for display
        const nextContact = callQueue.find(i => i.status === 'pending');

        if (delay > 0) {
          // Show countdown overlay
          showCountdown(delaySeconds, nextContact);
          autoDialTimeout = setTimeout(() => {
            hideCountdown();
            dialNextInQueue();
          }, delay);
        } else {
          dialNextInQueue();
        }
      }
    }

    // Scripts
    const scripts = {
      intro: {
        title: 'Introduction',
        content: `Hi, this is [Your Name] from [Company]. How are you doing today?

I'm calling because [reason for call]. Do you have a moment to chat?

Great! Let me tell you a little about what we offer...`
      },
      pricing: {
        title: 'Pricing Discussion',
        content: `Our pricing is based on [factors].

For your specific needs, I'd estimate around [price range].

This includes:
 [Feature 1]
 [Feature 2]
 [Feature 3]

How does that sound to you?`
      },
      objections: {
        title: 'Handling Objections',
        content: `"It's too expensive"
 I understand budget is important. Let me share how our customers typically see ROI within [timeframe]...

"I need to think about it"
 Of course! What specific aspects would you like to consider? I'd be happy to provide more information.

"I'm happy with my current provider"
 That's great to hear. Out of curiosity, what do you like most about them? Many of our customers actually switched from similar providers because...`
      },
      close: {
        title: 'Closing the Sale',
        content: `Based on what we've discussed, it sounds like [product/service] would be a great fit for you.

Would you like to move forward with [specific next step]?

I can get you started right now, and you'll [benefit].

What do you say?`
      }
    };

    // ==========================================
    // QUEUE MANAGEMENT FUNCTIONS
    // ==========================================

    function addToQueue(number = null, name = null) {
      const input = document.getElementById('queuePhoneInput');
      const phoneNumber = number || input.value.trim();

      if (!phoneNumber) return;

      // Clean the number
      let cleaned = phoneNumber.replace(/\D/g, '');
      if (cleaned.length < 10) {
        alert('Please enter a valid phone number');
        return;
      }

      // Format with country code
      if (cleaned.length === 10) {
        cleaned = '+1' + cleaned;
      } else if (!cleaned.startsWith('+')) {
        cleaned = '+' + cleaned;
      }

      // Check for duplicates
      if (callQueue.some(item => item.number === cleaned && item.status === 'pending')) {
        alert('This number is already in the queue');
        return;
      }

      callQueue.push({
        id: Date.now() + Math.random(),
        number: cleaned,
        displayNumber: formatPhoneNumber(cleaned),
        name: name || null,
        status: 'pending', // pending, calling, completed, skipped, no_answer
        outcome: null,
        addedAt: new Date()
      });

      input.value = '';
      renderQueue();
      updateQueueStats();
      saveQueueToStorage();
    }

    function removeFromQueue(id) {
      callQueue = callQueue.filter(item => item.id !== id);
      renderQueue();
      updateQueueStats();
      saveQueueToStorage();
    }

    function skipQueueItem(id) {
      const item = callQueue.find(i => i.id === id);
      if (item) {
        item.status = 'skipped';
        renderQueue();
        updateQueueStats();
        saveQueueToStorage();
      }
    }

    function retryQueueItem(id) {
      const item = callQueue.find(i => i.id === id);
      if (item) {
        item.status = 'pending';
        item.outcome = null;
        renderQueue();
        updateQueueStats();
        saveQueueToStorage();
        showNotification('Contact moved back to queue', 'info');
      }
    }

    function clearQueue() {
      if (callQueue.length === 0) return;
      if (confirm('Clear all numbers from the queue?')) {
        callQueue = [];
        currentQueueIndex = -1;
        renderQueue();
        updateQueueStats();
        saveQueueToStorage();
      }
    }

    function renderQueue() {
      const container = document.getElementById('queueList');

      if (callQueue.length === 0) {
        container.innerHTML = `
          <div class="queue-empty">
            <div class="queue-empty-icon"></div>
            <div>No numbers in queue</div>
            <div style="font-size: 0.75rem; margin-top: 4px;">Add numbers below to get started</div>
          </div>
        `;
        return;
      }

      container.innerHTML = callQueue.map((item, index) => {
        let statusIcon = '';
        let statusClass = '';

        switch (item.status) {
          case 'calling':
            statusIcon = '';
            statusClass = 'active';
            break;
          case 'completed':
            statusIcon = item.outcome === 'booked' ? '' : item.outcome === 'callback' ? '' : '';
            statusClass = 'completed';
            break;
          case 'skipped':
            statusIcon = '';
            statusClass = 'skipped';
            break;
          case 'no_answer':
            statusIcon = '';
            statusClass = 'completed';
            break;
          default:
            statusIcon = '';
        }

        // Determine which action buttons to show
        let actionButtons = '';
        if (item.status === 'pending') {
          actionButtons = `
            <div class="queue-item-actions">
              <button class="queue-action-btn" onclick="event.stopPropagation(); skipQueueItem(${item.id})" title="Skip"></button>
              <button class="queue-action-btn" onclick="event.stopPropagation(); removeFromQueue(${item.id})" title="Remove"></button>
            </div>
          `;
        } else if (item.status === 'skipped' || item.status === 'no_answer') {
          actionButtons = `
            <div class="queue-item-actions">
              <button class="queue-action-btn" onclick="event.stopPropagation(); retryQueueItem(${item.id})" title="Retry"></button>
              <button class="queue-action-btn" onclick="event.stopPropagation(); removeFromQueue(${item.id})" title="Remove"></button>
            </div>
          `;
        }

        return `
          <div class="queue-item ${statusClass}" data-id="${item.id}" onclick="callFromQueue(${item.id})">
            <div style="flex: 1;">
              <div class="queue-item-number">${item.displayNumber}</div>
              ${item.name ? `<div class="queue-item-name">${item.name}</div>` : ''}
            </div>
            <div class="queue-item-status">${statusIcon}</div>
            ${actionButtons}
          </div>
        `;
      }).join('');
    }

    function updateQueueStats() {
      const total = callQueue.length;
      const completed = callQueue.filter(i => ['completed', 'no_answer', 'skipped'].includes(i.status)).length;
      const remaining = callQueue.filter(i => i.status === 'pending').length;

      document.getElementById('queueTotal').textContent = total;
      document.getElementById('queueCompleted').textContent = completed;
      document.getElementById('queueRemaining').textContent = remaining;
    }

    function callFromQueue(id) {
      console.log('callFromQueue called with id:', id);
      const item = callQueue.find(i => i.id === id);
      if (!item) {
        console.log('callFromQueue: item not found');
        return;
      }

      // Allow calling pending, skipped, or no_answer items
      if (!['pending', 'skipped', 'no_answer'].includes(item.status)) {
        console.log('callFromQueue: item already completed', { status: item.status });
        return;
      }

      // Mark as calling
      item.status = 'calling';
      item.outcome = null; // Reset outcome for retry
      currentQueueIndex = callQueue.findIndex(i => i.id === id);
      renderQueue();

      // Load lead source data if exists for this queue item
      loadLeadSourceForQueueItem(item);

      // Set the phone input and make the call
      console.log('callFromQueue: Setting phone input to:', item.displayNumber);
      document.getElementById('phoneInput').value = item.displayNumber;
      makeCall();
    }

    function dialNextInQueue() {
      console.log('dialNextInQueue called, queue:', callQueue.map(i => ({ id: i.id, status: i.status })));
      const nextItem = callQueue.find(i => i.status === 'pending');
      if (nextItem) {
        console.log('Found next pending item:', nextItem.id, nextItem.displayNumber);
        callFromQueue(nextItem.id);
      } else {
        // Queue complete
        console.log('Queue complete, disabling auto-dial');
        autoDialEnabled = false;
        document.getElementById('autoDialToggle').checked = false;
        showNotification('Call queue completed!', 'info');
      }
    }

    function markCurrentQueueItemComplete(outcome) {
      if (currentQueueIndex >= 0 && currentQueueIndex < callQueue.length) {
        const item = callQueue[currentQueueIndex];
        item.status = outcome === 'no_answer' ? 'no_answer' : 'completed';
        item.outcome = outcome;
        renderQueue();
        updateQueueStats();
      }
    }

    // Bulk Add Functions
    function showBulkAddModal() {
      document.getElementById('bulkAddModal').classList.add('active');
      document.getElementById('bulkNumbersInput').focus();
    }

    function closeBulkAddModal() {
      document.getElementById('bulkAddModal').classList.remove('active');
      document.getElementById('bulkNumbersInput').value = '';
    }

    function processBulkAdd() {
      const input = document.getElementById('bulkNumbersInput').value;
      const lines = input.split('\n').filter(line => line.trim());

      let addedCount = 0;
      lines.forEach(line => {
        // Try to extract phone number and optional name
        // Format could be: "555-123-4567" or "John Doe, 555-123-4567" or "555-123-4567, John Doe"
        const cleaned = line.trim();
        if (cleaned) {
          // Extract numbers
          const numbers = cleaned.match(/[\d\s\-\(\)\+]+/g);
          if (numbers) {
            const phoneNumber = numbers.join('').replace(/\s/g, '');
            if (phoneNumber.replace(/\D/g, '').length >= 10) {
              // Try to get name (anything that's not the phone number)
              let name = cleaned.replace(phoneNumber, '').replace(/[,\-]/g, '').trim();
              addToQueue(phoneNumber, name || null);
              addedCount++;
            }
          }
        }
      });

      closeBulkAddModal();
      if (addedCount > 0) {
        console.log(`Added ${addedCount} numbers to queue`);
      }
    }

    // ==========================================
    // END QUEUE MANAGEMENT
    // ==========================================

    // ==========================================
    // LEAD SOURCE FUNCTIONS
    // ==========================================

    const sourceConfig = {
      facebook: { icon: '', label: 'Facebook', color: '#1877f2' },
      google: { icon: '', label: 'Google', color: '#ea4335' },
      instagram: { icon: '', label: 'Instagram', color: '#e4405f' },
      tiktok: { icon: '', label: 'TikTok', color: '#000000' },
      linkedin: { icon: '', label: 'LinkedIn', color: '#0077b5' },
      referral: { icon: '', label: 'Referral', color: '#10b981' },
      website: { icon: '', label: 'Website', color: '#2563eb' },
      'cold-call': { icon: '', label: 'Cold Call', color: '#f59e0b' },
      other: { icon: '', label: 'Other', color: '#6b7280' }
    };

    const categoryLabels = {
      ad: 'Paid Ad',
      organic: 'Organic',
      direct: 'Direct',
      retargeting: 'Retargeting',
      email: 'Email',
      sms: 'SMS'
    };

    function toggleLeadSourceEdit() {
      leadSourceEditMode = !leadSourceEditMode;

      const displayEl = document.getElementById('leadSourceDisplay');
      const editEl = document.getElementById('leadSourceEdit');
      const toggleBtn = document.getElementById('toggleLeadSourceBtn');

      // Skip if elements don't exist (UI redesign)
      if (!displayEl && !editEl && !toggleBtn) return;

      if (leadSourceEditMode) {
        displayEl?.classList.add('hidden');
        editEl?.classList.remove('hidden');
        if (toggleBtn) toggleBtn.textContent = 'Cancel';

        // Restore current values if any
        if (leadSourceData.source) {
          selectLeadSource(leadSourceData.source, false);
        }
        if (leadSourceData.category) {
          selectLeadCategory(leadSourceData.category, false);
        }
        if (leadSourceData.campaignName) {
          const el = document.getElementById('leadCampaignName');
          if (el) el.value = leadSourceData.campaignName;
        }
        if (leadSourceData.adName) {
          const el = document.getElementById('leadAdName');
          if (el) el.value = leadSourceData.adName;
        }
        if (leadSourceData.customSource) {
          const el = document.getElementById('customSourceName');
          if (el) el.value = leadSourceData.customSource;
        }
      } else {
        displayEl?.classList.remove('hidden');
        editEl?.classList.add('hidden');
        if (toggleBtn) toggleBtn.textContent = 'Edit';
      }
    }

    function selectLeadSource(source, clearOthers = true) {
      // Update buttons
      document.querySelectorAll('.lead-source-btn').forEach(btn => {
        btn.classList.remove('selected');
      });

      const selectedBtn = document.querySelector(`.lead-source-btn[data-source="${source}"]`);
      if (selectedBtn) {
        selectedBtn.classList.add('selected');
      }

      leadSourceData.source = source;

      // Show/hide custom source input
      const customInput = document.getElementById('customSourceInput');
      if (source === 'other') {
        customInput?.classList.remove('hidden');
        document.getElementById('customSourceName')?.focus();
      } else {
        customInput?.classList.add('hidden');
        leadSourceData.customSource = null;
      }
    }

    function selectLeadCategory(category, clearOthers = true) {
      // Update chips
      document.querySelectorAll('.lead-category-chip').forEach(chip => {
        chip.classList.remove('selected');
      });

      const selectedChip = document.querySelector(`.lead-category-chip[data-category="${category}"]`);
      if (selectedChip) {
        selectedChip.classList.add('selected');
      }

      leadSourceData.category = category;
    }

    function saveLeadSource() {
      // Get values
      leadSourceData.campaignName = document.getElementById('leadCampaignName').value.trim() || null;
      leadSourceData.adName = document.getElementById('leadAdName').value.trim() || null;

      if (leadSourceData.source === 'other') {
        leadSourceData.customSource = document.getElementById('customSourceName').value.trim() || null;
      }

      // Validate
      if (!leadSourceData.source) {
        alert('Please select a lead source');
        return;
      }

      // Update display
      updateLeadSourceDisplay();

      // Save to current queue item if applicable
      if (currentQueueIndex >= 0 && currentQueueIndex < callQueue.length) {
        callQueue[currentQueueIndex].leadSource = { ...leadSourceData };
        saveQueueToStorage();
      }

      // Exit edit mode
      toggleLeadSourceEdit();

      // Send to server if in a call
      if (currentCallSid) {
        sendLeadSourceToServer();
      }
    }

    function cancelLeadSourceEdit() {
      // Just toggle back without saving
      leadSourceEditMode = true; // Will be toggled to false
      toggleLeadSourceEdit();
    }

    function updateLeadSourceDisplay() {
      const summaryEl = document.getElementById('leadSourceSummary');
      if (!summaryEl) return; // Element not in current UI

      if (!leadSourceData.source) {
        summaryEl.innerHTML = `
          <span class="source-icon"></span>
          <div class="source-info">
            <div class="source-name">Not set</div>
            <div class="source-category">Click edit to set lead source</div>
          </div>
        `;
        return;
      }

      const config = sourceConfig[leadSourceData.source];
      const sourceName = leadSourceData.source === 'other' && leadSourceData.customSource
        ? leadSourceData.customSource
        : config.label;

      let categoryText = '';
      if (leadSourceData.category) {
        categoryText = categoryLabels[leadSourceData.category] || leadSourceData.category;
      }

      let campaignText = '';
      if (leadSourceData.campaignName) {
        campaignText = leadSourceData.campaignName;
        if (leadSourceData.adName) {
          campaignText += ` / ${leadSourceData.adName}`;
        }
      }

      summaryEl.innerHTML = `
        <span class="source-icon">${config.icon}</span>
        <div class="source-info">
          <div class="source-name">${sourceName}</div>
          ${categoryText ? `<div class="source-category">${categoryText}</div>` : ''}
          ${campaignText ? `<div class="source-campaign">${campaignText}</div>` : ''}
        </div>
      `;
    }

    function resetLeadSource() {
      leadSourceData = {
        source: null,
        customSource: null,
        category: null,
        campaignName: null,
        adName: null
      };

      // Reset UI (with null checks for redesigned UI)
      document.querySelectorAll('.lead-source-btn').forEach(btn => btn.classList.remove('selected'));
      document.querySelectorAll('.lead-category-chip').forEach(chip => chip.classList.remove('selected'));

      const leadCampaignName = document.getElementById('leadCampaignName');
      const leadAdName = document.getElementById('leadAdName');
      const customSourceName = document.getElementById('customSourceName');
      const customSourceInput = document.getElementById('customSourceInput');

      if (leadCampaignName) leadCampaignName.value = '';
      if (leadAdName) leadAdName.value = '';
      if (customSourceName) customSourceName.value = '';
      if (customSourceInput) customSourceInput.classList.add('hidden');

      updateLeadSourceDisplay();

      // Make sure we're in display mode
      if (leadSourceEditMode) {
        leadSourceEditMode = false;
        document.getElementById('leadSourceDisplay')?.classList.remove('hidden');
        document.getElementById('leadSourceEdit')?.classList.add('hidden');
        const toggleBtn = document.getElementById('toggleLeadSourceBtn');
        if (toggleBtn) toggleBtn.textContent = 'Edit';
      }
    }

    function loadLeadSourceForQueueItem(queueItem) {
      if (queueItem && queueItem.leadSource) {
        leadSourceData = { ...queueItem.leadSource };
        updateLeadSourceDisplay();
      } else {
        resetLeadSource();
      }
    }

    async function sendLeadSourceToServer() {
      if (!currentCallSid || !leadSourceData.source) return;

      // Update contact with lead source if not already set
      // Security: Filter by both id AND company_id to ensure ownership
      if (currentContactId && companyId) {
        try {
          await supabase
            .from('contacts')
            .update({
              lead_source: leadSourceData.source,
              updated_at: new Date().toISOString()
            })
            .eq('id', currentContactId)
            .eq('company_id', companyId)
            .is('lead_source', null);  // Only update if not already set
        } catch (error) {
          console.log('Could not update contact lead source:', error);
        }
      }

      // Also send to original API endpoint for backwards compatibility
      try {
        await fetch('/api/call-lead-source', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            callSid: currentCallSid,
            leadSource: leadSourceData
          })
        });
      } catch (error) {
        console.log('Could not save lead source to server:', error);
      }
    }

    // ==========================================
    // END LEAD SOURCE FUNCTIONS
    // ==========================================

    // ==========================================
    // SIDEBAR FUNCTIONS
    // ==========================================

    let sidebarCollapsed = false;

    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      sidebarCollapsed = !sidebarCollapsed;
      sidebar.classList.toggle('collapsed', sidebarCollapsed);
      localStorage.setItem('sidebarCollapsed', sidebarCollapsed);
    }

    function openSidebar() {
      document.getElementById('sidebar').classList.add('mobile-open');
      document.getElementById('sidebarOverlay').classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function closeSidebar() {
      document.getElementById('sidebar').classList.remove('mobile-open');
      document.getElementById('sidebarOverlay').classList.remove('active');
      document.body.style.overflow = '';
    }

    // Mobile call screen functions
    function showMobileCallScreen() {
      if (window.innerWidth <= 768) {
        const phoneInput = document.getElementById('phoneInput');
        document.getElementById('mobileCallNumber').textContent = formatPhoneNumber(phoneInput.value);
        document.getElementById('mobileCallScreen').classList.add('active');
      }
    }

    function minimizeMobileCall() {
      document.getElementById('mobileCallScreen').classList.remove('active');
    }

    function endMobileCall() {
      endCall();
      document.getElementById('mobileCallScreen').classList.remove('active');
    }

    function toggleMobileMute(btn) {
      btn.classList.toggle('active');
      toggleMute();
    }

    function toggleMobileHold(btn) {
      btn.classList.toggle('active');
      toggleHold();
    }

    function showMobileKeypad() {
      // Show keypad overlay
    }

    function updateMobileCallTimer() {
      const mobileTimer = document.getElementById('mobileCallTimer');
      const desktopTimer = document.getElementById('callTimer');
      if (mobileTimer && desktopTimer) {
        mobileTimer.textContent = desktopTimer.textContent;
      }
    }

    // =====================================================
    // DESIGN 6 - NEW UI FUNCTIONS
    // =====================================================

    // Toggle session stats mini bar expand/collapse
    function toggleSessionStatsMini() {
      const mini = document.getElementById('sessionStatsMini');
      if (mini) {
        mini.classList.toggle('expanded');
      }
    }

    // Toggle dialpad visibility
    function toggleDialpad() {
      const dialpad = document.getElementById('dialpadGrid');
      const toggleText = document.getElementById('dialpadToggleText');
      if (dialpad) {
        dialpad.classList.toggle('visible');
        if (toggleText) {
          toggleText.textContent = dialpad.classList.contains('visible') ? 'Hide Keypad' : 'Show Keypad';
        }
      }
    }

    // Add digit to phone input (for dialpad)
    function dialDigit(digit) {
      const phoneInput = document.getElementById('phoneInput');
      if (phoneInput) {
        phoneInput.value += digit;
        phoneInput.focus();
      }
    }

    // Switch between customer tabs
    function switchCustomerTab(tabId) {
      // Remove active from all tabs and panes
      document.querySelectorAll('.customer-tabbed-panel .tab-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      document.querySelectorAll('.customer-tabbed-panel .tab-pane').forEach(pane => {
        pane.classList.remove('active');
      });

      // Add active to clicked tab
      event.target.classList.add('active');
      const pane = document.getElementById('tab-' + tabId);
      if (pane) {
        pane.classList.add('active');
      }
    }

    // Save customer note
    async function saveCustomerNote() {
      const noteText = document.getElementById('callNotes')?.value?.trim();
      if (!noteText) return;

      // If we have a contact, save the note
      if (currentContactId && currentUser) {
        try {
          await supabase.from('contact_notes').insert({
            contact_id: currentContactId,
            user_id: currentUser.id,
            content: noteText,
            created_at: new Date().toISOString()
          });

          // Add to notes list UI
          const notesList = document.getElementById('notesList');
          if (notesList) {
            const noteItem = document.createElement('div');
            noteItem.className = 'note-item';
            noteItem.innerHTML = `
              <div class="note-text">${noteText}</div>
              <div class="note-meta">Just now</div>
            `;
            notesList.insertBefore(noteItem, notesList.firstChild);
          }

          // Clear input
          document.getElementById('callNotes').value = '';
        } catch (error) {
          console.error('Error saving note:', error);
        }
      } else {
        // No contact selected, just clear the input
        alert('Please select a contact first');
      }
    }

    // Update customer panel with contact data
    function updateCustomerPanel(contact) {
      if (!contact) {
        // Reset to default
        document.getElementById('customerAvatar').textContent = '?';
        document.getElementById('customerName').textContent = 'No Contact Selected';
        document.getElementById('customerMeta').textContent = 'Select a contact or enter a number';
        document.getElementById('customerTags').innerHTML = '';
        document.getElementById('profilePhone').textContent = '-';
        document.getElementById('profileEmail').textContent = '-';
        document.getElementById('profileCompany').textContent = '-';
        document.getElementById('profileWebsite').textContent = '-';
        document.getElementById('profileSource').textContent = '-';
        document.getElementById('profileCampaign').textContent = '-';
        document.getElementById('profileStatus').textContent = '-';
        document.getElementById('profileValue').textContent = '-';
        document.getElementById('profileCreated').textContent = '-';
        // Reset profile tags
        document.getElementById('profileTags').innerHTML = '<span class="no-tags">No tags yet</span>';
        return;
      }

      // Update avatar
      const initials = getInitials(contact.name || contact.first_name, contact.last_name);
      document.getElementById('customerAvatar').textContent = initials || '?';

      // Update name
      const displayName = contact.name || `${contact.first_name || ''} ${contact.last_name || ''}`.trim() || 'Unknown';
      document.getElementById('customerName').textContent = displayName;

      // Update meta
      const phone = contact.phone || contact.phone_number || '';
      const email = contact.email || '';
      document.getElementById('customerMeta').textContent = [phone, email].filter(Boolean).join(' | ') || 'No contact info';

      // Update tags
      const tagsContainer = document.getElementById('customerTags');
      tagsContainer.innerHTML = '';
      if (contact.lead_status === 'hot' || contact.status === 'hot') {
        tagsContainer.innerHTML += '<span class="customer-tag hot">Hot Lead</span>';
      }
      if (contact.lead_source || contact.source) {
        tagsContainer.innerHTML += `<span class="customer-tag source">${contact.lead_source || contact.source}</span>`;
      }

      // Update profile tab
      document.getElementById('profilePhone').textContent = phone || '-';
      document.getElementById('profileEmail').textContent = email || '-';
      document.getElementById('profileCompany').textContent = contact.company || contact.company_name || '-';
      document.getElementById('profileWebsite').textContent = contact.website || '-';
      document.getElementById('profileSource').textContent = contact.lead_source || contact.source || '-';
      document.getElementById('profileCampaign').textContent = contact.campaign || '-';
      document.getElementById('profileStatus').textContent = contact.status || contact.lead_status || '-';
      document.getElementById('profileValue').textContent = contact.value ? `$${contact.value.toLocaleString()}` : '-';
      document.getElementById('profileCreated').textContent = contact.created_at ? new Date(contact.created_at).toLocaleDateString() : '-';

      // Update profile tags
      updateProfileTags(contact.tags);

      // Load activity, notes, and history
      loadCustomerActivity(contact.id);
      loadCustomerNotes(contact.id);
      loadCustomerHistory(contact.id);
    }

    // Get initials from name
    function getInitials(firstName, lastName) {
      const first = (firstName || '').charAt(0).toUpperCase();
      const last = (lastName || '').charAt(0).toUpperCase();
      return first + last || '?';
    }

    // Load customer activity
    async function loadCustomerActivity(contactId) {
      const activityList = document.getElementById('activityList');
      if (!activityList || !contactId) return;

      try {
        // Get calls
        const { data: calls } = await supabase
          .from('calls')
          .select('*')
          .eq('contact_id', contactId)
          .order('created_at', { ascending: false })
          .limit(10);

        // Get SMS
        const { data: messages } = await supabase
          .from('sms_messages')
          .select('*')
          .eq('contact_id', contactId)
          .order('created_at', { ascending: false })
          .limit(10);

        // Combine and sort
        const activities = [
          ...(calls || []).map(c => ({ ...c, type: 'call', date: c.created_at })),
          ...(messages || []).map(m => ({ ...m, type: 'sms', date: m.created_at }))
        ].sort((a, b) => new Date(b.date) - new Date(a.date)).slice(0, 10);

        if (activities.length === 0) {
          activityList.innerHTML = `
            <div class="tab-empty-state">
              <div class="empty-icon"></div>
              <div>No activity yet</div>
            </div>
          `;
          return;
        }

        activityList.innerHTML = activities.map(a => `
          <div class="activity-item">
            <div class="activity-icon ${a.type}">${a.type === 'call' ? '' : ''}</div>
            <div class="activity-content">
              <div class="activity-title">${a.type === 'call' ? (a.direction === 'inbound' ? 'Inbound Call' : 'Outbound Call') : (a.direction === 'inbound' ? 'SMS Received' : 'SMS Sent')}</div>
              <div class="activity-desc">${a.type === 'sms' ? (a.body || a.content || '').substring(0, 50) + '...' : (a.outcome || a.status || 'No outcome')}</div>
              <div class="activity-time">${formatTimeAgo(a.date)}</div>
            </div>
          </div>
        `).join('');
      } catch (error) {
        console.error('Error loading activity:', error);
      }
    }

    // Tag Management Functions
    function updateProfileTags(tags) {
      const container = document.getElementById('profileTags');
      if (!container) return;

      // Parse tags - could be array, JSON string, or comma-separated string
      let tagArray = [];
      if (Array.isArray(tags)) {
        tagArray = tags;
      } else if (typeof tags === 'string' && tags.trim()) {
        try {
          tagArray = JSON.parse(tags);
        } catch {
          tagArray = tags.split(',').map(t => t.trim()).filter(Boolean);
        }
      }

      if (tagArray.length === 0) {
        container.innerHTML = '<span class="no-tags">No tags yet</span>';
        return;
      }

      container.innerHTML = tagArray.map(tag => {
        const tagClass = getTagClass(tag);
        return `
          <span class="contact-tag ${tagClass}">
            ${escapeHtml(tag)}
            <span class="remove-tag" onclick="removeContactTag('${escapeHtml(tag)}')">&times;</span>
          </span>
        `;
      }).join('');
    }

    function getTagClass(tag) {
      const tagLower = tag.toLowerCase();
      if (tagLower.includes('hot') || tagLower.includes('urgent')) return 'hot';
      if (tagLower.includes('vip') || tagLower.includes('priority')) return 'vip';
      return '';
    }

    async function addContactTag() {
      const input = document.getElementById('newTagInput');
      const tag = input.value.trim();
      if (!tag) return;

      if (!currentContact || !currentContact.id) {
        alert('No contact selected');
        return;
      }

      try {
        // Get current tags
        let currentTags = [];
        if (Array.isArray(currentContact.tags)) {
          currentTags = currentContact.tags;
        } else if (typeof currentContact.tags === 'string' && currentContact.tags.trim()) {
          try {
            currentTags = JSON.parse(currentContact.tags);
          } catch {
            currentTags = currentContact.tags.split(',').map(t => t.trim()).filter(Boolean);
          }
        }

        // Check if tag already exists
        if (currentTags.some(t => t.toLowerCase() === tag.toLowerCase())) {
          input.value = '';
          return;
        }

        // Add new tag
        currentTags.push(tag);

        // Update in database
        const { error } = await supabase
          .from('contacts')
          .update({ tags: currentTags })
          .eq('id', currentContact.id);

        if (error) throw error;

        // Update local state and UI
        currentContact.tags = currentTags;
        updateProfileTags(currentTags);
        input.value = '';

        console.log('Tag added:', tag);
      } catch (err) {
        console.error('Error adding tag:', err);
        alert('Failed to add tag');
      }
    }

    function addSuggestedTag(tag) {
      document.getElementById('newTagInput').value = tag;
      addContactTag();
    }

    async function removeContactTag(tagToRemove) {
      if (!currentContact || !currentContact.id) return;

      try {
        // Get current tags
        let currentTags = [];
        if (Array.isArray(currentContact.tags)) {
          currentTags = currentContact.tags;
        } else if (typeof currentContact.tags === 'string' && currentContact.tags.trim()) {
          try {
            currentTags = JSON.parse(currentContact.tags);
          } catch {
            currentTags = currentContact.tags.split(',').map(t => t.trim()).filter(Boolean);
          }
        }

        // Remove the tag
        currentTags = currentTags.filter(t => t !== tagToRemove);

        // Update in database
        const { error } = await supabase
          .from('contacts')
          .update({ tags: currentTags })
          .eq('id', currentContact.id);

        if (error) throw error;

        // Update local state and UI
        currentContact.tags = currentTags;
        updateProfileTags(currentTags);

        console.log('Tag removed:', tagToRemove);
      } catch (err) {
        console.error('Error removing tag:', err);
        alert('Failed to remove tag');
      }
    }

    // Load customer notes
    async function loadCustomerNotes(contactId) {
      const notesList = document.getElementById('notesList');
      if (!notesList || !contactId) return;

      try {
        const { data: notes } = await supabase
          .from('contact_notes')
          .select('*')
          .eq('contact_id', contactId)
          .order('created_at', { ascending: false })
          .limit(20);

        if (!notes || notes.length === 0) {
          notesList.innerHTML = '';
          return;
        }

        notesList.innerHTML = notes.map(n => `
          <div class="note-item">
            <div class="note-text">${n.content}</div>
            <div class="note-meta">${formatTimeAgo(n.created_at)}</div>
          </div>
        `).join('');
      } catch (error) {
        console.error('Error loading notes:', error);
      }
    }

    // Load customer call history
    async function loadCustomerHistory(contactId) {
      const historyList = document.getElementById('historyList');
      if (!historyList || !contactId) return;

      try {
        const { data: calls } = await supabase
          .from('calls')
          .select('*')
          .eq('contact_id', contactId)
          .order('created_at', { ascending: false })
          .limit(20);

        if (!calls || calls.length === 0) {
          historyList.innerHTML = `
            <div class="tab-empty-state">
              <div class="empty-icon"></div>
              <div>No call history</div>
            </div>
          `;
          return;
        }

        historyList.innerHTML = calls.map(c => {
          const outcomeClass = c.outcome === 'connected' || c.outcome === 'answered' ? 'connected' :
                               c.outcome === 'no_answer' ? 'no-answer' :
                               c.outcome === 'callback' ? 'callback' :
                               c.outcome === 'booked' ? 'booked' : '';
          return `
            <div class="history-item">
              <div class="history-icon"></div>
              <div class="history-info">
                <div class="history-title">${c.direction === 'inbound' ? 'Inbound Call' : 'Outbound Call'}</div>
                <div class="history-date">${new Date(c.created_at).toLocaleString()}</div>
              </div>
              <span class="history-outcome ${outcomeClass}">${c.outcome || 'Unknown'}</span>
            </div>
          `;
        }).join('');
      } catch (error) {
        console.error('Error loading history:', error);
      }
    }

    // Format time ago
    function formatTimeAgo(dateString) {
      const date = new Date(dateString);
      const now = new Date();
      const seconds = Math.floor((now - date) / 1000);

      if (seconds < 60) return 'Just now';
      if (seconds < 3600) return `${Math.floor(seconds / 60)} min ago`;
      if (seconds < 86400) return `${Math.floor(seconds / 3600)} hours ago`;
      if (seconds < 604800) return `${Math.floor(seconds / 86400)} days ago`;
      return date.toLocaleDateString();
    }

    // Update mini session stats (called by sessionTracker)
    function updateMiniSessionStats() {
      const tracker = sessionTracker;

      // Update mini display
      document.getElementById('miniSessionTime').textContent = formatDuration(tracker.totalDuration);
      document.getElementById('miniCallCount').textContent = tracker.totalCalls;

      // Update expanded stats
      document.getElementById('miniTalkTime').textContent = formatShortDuration(tracker.talkTime);
      document.getElementById('miniIdleTime').textContent = formatShortDuration(tracker.idleTime);
      document.getElementById('miniBreakTime').textContent = formatShortDuration(tracker.breakTime);

      // Update productivity bar
      const total = tracker.talkTime + tracker.idleTime + tracker.breakTime;
      if (total > 0) {
        const talkPercent = (tracker.talkTime / total * 100).toFixed(0);
        const idlePercent = (tracker.idleTime / total * 100).toFixed(0);
        const breakPercent = (tracker.breakTime / total * 100).toFixed(0);

        document.getElementById('miniProductivityPercent').textContent = talkPercent + '%';
        document.getElementById('miniProductivityTalk').style.width = talkPercent + '%';
        document.getElementById('miniProductivityIdle').style.width = idlePercent + '%';
        document.getElementById('miniProductivityBreak').style.width = breakPercent + '%';
      }

      // Update break button text
      const pauseText = tracker.status === 'paused' ? 'Resume' : 'Break';
      document.getElementById('miniPauseBtnText').textContent = pauseText;
    }

    // Format duration as H:MM:SS
    function formatDuration(seconds) {
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = seconds % 60;
      return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
    }

    // Format short duration as M:SS
    function formatShortDuration(seconds) {
      const m = Math.floor(seconds / 60);
      const s = seconds % 60;
      return `${m}:${String(s).padStart(2, '0')}`;
    }

    // Initialize
    async function init() {
      // Initialize page with auth check
      await initPage({
        requireAuth: true,
        onReady: async (user) => {
          currentUser = user;

          // Get company membership
          const { companyId: cId, error } = await getCompanyMembership();
          if (error) {
            console.error('Failed to get company membership:', error);
            showError('#main', 'Failed to load user data. Please refresh.');
            return;
          }
          companyId = cId;

          // Continue with original initialization
          await initializeCallPage();
        },
        onError: (error) => {
          console.error('Page initialization failed:', error);
        }
      });
    }

    async function initializeCallPage() {
      // Restore sidebar state
      const savedCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
      if (savedCollapsed && window.innerWidth > 1024) {
        sidebarCollapsed = true;
        document.getElementById('sidebar').classList.add('collapsed');
      }

      // Restore call mode preference
      const savedMode = localStorage.getItem('callMode') || 'basic';
      document.getElementById('callModeSelect').value = savedMode;
      advancedModeEnabled = savedMode === 'advanced' || savedMode === 'twilio-realtime';

      // Set up Call Mode selector listener
      setupCallModeSelector();

      // Load and set up knowledge bases
      await loadKnowledgeBases();
      setupKnowledgeBaseSelector();

      // Initialize based on mode
      if (advancedModeEnabled) {
        connectWebSocket();
      } else {
        updateAdvancedModeStatus('basic');
      }

      await initializeTwilioDevice();
      setupEventListeners();
      setupQueueEventListeners();
      checkUrlParams();
      loadQueueFromStorage();
      loadImportedContacts();

      // Initialize session tracker for time tracking
      await sessionTracker.init();
    }

    function setupCallModeSelector() {
      const select = document.getElementById('callModeSelect');

      select.addEventListener('change', (e) => {
        const selectedMode = e.target.value;
        advancedModeEnabled = selectedMode === 'advanced' || selectedMode === 'twilio-realtime';
        localStorage.setItem('callMode', selectedMode);

        if (advancedModeEnabled) {
          // Enable advanced mode
          fallbackToBasicMode = false;
          wsReconnectAttempts = 0;
          wsLastConnectedTime = null;
          connectWebSocket();
          showNotification('Advanced Mode enabled. Live transcription and AI coaching will be available.', 'info');
        } else {
          // Disable advanced mode
          disconnectWebSocket();
          updateAdvancedModeStatus('basic');
          showNotification('Basic Mode enabled. Calls will still be recorded with post-call analysis.', 'info');
        }
      });
    }

    // Load knowledge bases from API
    async function loadKnowledgeBases() {
      try {
        const response = await fetch('/api/knowledge-bases');
        const result = await response.json();

        if (result.success && result.knowledgeBases) {
          knowledgeBases = result.knowledgeBases;
          const select = document.getElementById('knowledgeBaseSelect');

          // Clear existing options and populate with real data
          select.innerHTML = knowledgeBases.map(kb =>
            `<option value="${kb.id}" ${kb.is_default ? 'selected' : ''}>${kb.name}</option>`
          ).join('');

          // Set the selected knowledge base ID
          const defaultKB = knowledgeBases.find(kb => kb.is_default) || knowledgeBases[0];
          if (defaultKB) {
            selectedKnowledgeBaseId = defaultKB.id;
            localStorage.setItem('selectedKnowledgeBaseId', selectedKnowledgeBaseId);
          }

          console.log('Knowledge bases loaded:', knowledgeBases.length);
        }
      } catch (error) {
        console.error('Failed to load knowledge bases:', error);
      }
    }

    // Set up knowledge base selector event listener
    function setupKnowledgeBaseSelector() {
      const select = document.getElementById('knowledgeBaseSelect');

      select.addEventListener('change', (e) => {
        selectedKnowledgeBaseId = e.target.value;
        localStorage.setItem('selectedKnowledgeBaseId', selectedKnowledgeBaseId);

        const selectedKB = knowledgeBases.find(kb => kb.id === selectedKnowledgeBaseId);
        console.log('Knowledge base changed to:', selectedKB?.name);

        // Notify server via WebSocket if connected
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'set_knowledge_base',
            knowledgeBaseId: selectedKnowledgeBaseId,
            callSid: currentCallSid
          }));
        }
      });

      // Restore saved selection
      const savedKBId = localStorage.getItem('selectedKnowledgeBaseId');
      if (savedKBId) {
        selectedKnowledgeBaseId = savedKBId;
        select.value = savedKBId;
      }
    }

    function setupQueueEventListeners() {
      // Auto-dial toggle is handled by inline onchange="handleAutoDialToggle(this.checked)"
      // which properly handles the delay setting

      // Enter key to add to queue
      document.getElementById('queuePhoneInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          addToQueue();
        }
      });

      // Save queue to localStorage on changes
      const originalRenderQueue = renderQueue;
      // Already handles this in addToQueue/removeFromQueue
    }

    function loadQueueFromStorage() {
      try {
        const saved = localStorage.getItem('callQueue');
        if (saved) {
          callQueue = JSON.parse(saved);
          // Reset any "calling" status to pending
          callQueue.forEach(item => {
            if (item.status === 'calling') {
              item.status = 'pending';
            }
          });
          renderQueue();
          updateQueueStats();
        }
      } catch (e) {
        console.log('Could not load queue from storage');
      }
    }

    // Load contacts imported from contacts page via URL params
    function loadImportedContacts() {
      try {
        const params = new URLSearchParams(window.location.search);
        const importData = params.get('import');
        if (!importData) return;

        const entries = decodeURIComponent(importData).split(',');
        let addedCount = 0;

        entries.forEach(entry => {
          const [phone, name] = entry.split('|');
          if (phone && !callQueue.some(item => item.number === phone && item.status === 'pending')) {
            callQueue.push({
              id: Date.now() + Math.random(),
              number: phone,
              displayNumber: formatPhoneNumber(phone),
              name: name || null,
              status: 'pending',
              outcome: null,
              addedAt: new Date()
            });
            addedCount++;
          }
        });

        if (addedCount > 0) {
          renderQueue();
          updateQueueStats();
          saveQueueToStorage();
          showNotification(`Added ${addedCount} contacts to your call queue`, 'success');
        }

        // Clear URL params to prevent re-import on refresh
        window.history.replaceState({}, document.title, '/call.html');

      } catch (e) {
        console.error('Error loading imported contacts:', e);
      }
    }

    function saveQueueToStorage() {
      try {
        localStorage.setItem('callQueue', JSON.stringify(callQueue));
      } catch (e) {
        console.log('Could not save queue to storage');
      }
    }

    // WebSocket Connection with Reconnection Logic
    async function connectWebSocket() {
      if (!advancedModeEnabled) {
        console.log('Advanced mode disabled, skipping WebSocket connection');
        return;
      }

      // Security: Get auth token for WebSocket connection
      const { data: { session } } = await supabase.auth.getSession();
      if (!session || !session.access_token) {
        console.error('No auth session for WebSocket connection');
        handleFallbackToBasicMode('Authentication required for live transcription');
        return;
      }

      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/browser?role=rep&identity=${repIdentity}&token=${encodeURIComponent(session.access_token)}`;

      console.log('Connecting to WebSocket with auth token');

      try {
        ws = new WebSocket(wsUrl);
      } catch (error) {
        console.error('WebSocket construction failed:', error);
        handleWebSocketError(error);
        return;
      }

      ws.onopen = () => {
        console.log('Connected to server (Advanced Mode)');
        wsReconnectAttempts = 0;
        wsReconnectDelay = 2000;
        wsLastConnectedTime = Date.now();
        advancedModeActive = true;
        fallbackToBasicMode = false;
        updateConnectionStatus(true);
        updateAdvancedModeStatus('connected');
        hideReconnectingOverlay();

        // Send current knowledge base selection to server
        if (selectedKnowledgeBaseId) {
          ws.send(JSON.stringify({
            type: 'set_knowledge_base',
            knowledgeBaseId: selectedKnowledgeBaseId,
            callSid: currentCallSid
          }));
        }
      };

      ws.onclose = (event) => {
        console.log('WebSocket closed:', event.code, event.reason);
        advancedModeActive = false;
        updateConnectionStatus(false);

        // Only attempt reconnect if advanced mode is still enabled
        if (advancedModeEnabled && !fallbackToBasicMode) {
          attemptReconnect();
        }
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        handleWebSocketError(error);
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          console.log('[WebSocket] Received message:', data.type, data);
          handleWebSocketMessage(data);
        } catch (e) {
          console.error('Failed to parse WebSocket message:', e);
        }
      };
    }

    function attemptReconnect() {
      if (wsReconnectAttempts >= wsMaxReconnectAttempts) {
        console.log('Max reconnection attempts reached, falling back to basic mode');
        handleFallbackToBasicMode('Connection failed after multiple attempts');
        return;
      }

      wsReconnectAttempts++;
      const delay = Math.min(wsReconnectDelay * Math.pow(1.5, wsReconnectAttempts - 1), 30000);

      console.log(`Reconnect attempt ${wsReconnectAttempts}/${wsMaxReconnectAttempts} in ${delay}ms`);

      showReconnectingOverlay(wsReconnectAttempts, wsMaxReconnectAttempts);
      updateAdvancedModeStatus('reconnecting');

      wsReconnectTimer = setTimeout(() => {
        connectWebSocket();
      }, delay);
    }

    function handleWebSocketError(error) {
      console.error('WebSocket error handler:', error);
      updateAdvancedModeStatus('error');

      // If we've never successfully connected and this is the first attempt,
      // fall back immediately
      if (!wsLastConnectedTime && wsReconnectAttempts === 0) {
        handleFallbackToBasicMode('Could not establish connection to live transcription service');
      }
    }

    function handleFallbackToBasicMode(reason) {
      console.log('Falling back to Basic Mode:', reason);
      fallbackToBasicMode = true;
      advancedModeActive = false;

      // Clear any pending reconnect
      if (wsReconnectTimer) {
        clearTimeout(wsReconnectTimer);
        wsReconnectTimer = null;
      }

      // Close websocket if open
      if (ws && ws.readyState !== WebSocket.CLOSED) {
        ws.close();
      }

      // Update UI
      updateAdvancedModeStatus('fallback');
      hideReconnectingOverlay();

      // Show notification
      showNotification(`Switched to Basic Mode: ${reason}. Call recording and post-call analysis still available.`, 'warning');

      // Update mode selector
      document.getElementById('callModeSelect').value = 'basic';
      advancedModeEnabled = false;
      localStorage.setItem('callMode', 'basic');
    }

    function cancelReconnect() {
      handleFallbackToBasicMode('User cancelled reconnection');
    }

    function showReconnectingOverlay(attempt, maxAttempts) {
      const overlay = document.getElementById('reconnectingOverlay');
      const message = document.getElementById('reconnectingMessage');
      message.textContent = `Attempt ${attempt} of ${maxAttempts}. Please wait...`;
      overlay.classList.remove('hidden');
    }

    function hideReconnectingOverlay() {
      document.getElementById('reconnectingOverlay').classList.add('hidden');
    }

    function updateAdvancedModeStatus(status) {
      const modeStatus = document.getElementById('callModeStatus');
      const modeIndicator = document.getElementById('modeIndicator');
      const modeText = document.getElementById('modeText');

      // Skip if elements don't exist (UI redesign may have removed them)
      if (!modeStatus && !modeIndicator && !modeText) {
        console.log('Mode status elements not found, skipping update');
        return;
      }

      // Remove all status classes
      modeStatus?.classList.remove('basic', 'advanced', 'error');
      modeIndicator?.classList.remove('active', 'error');

      switch (status) {
        case 'connected':
          modeStatus?.classList.add('advanced');
          modeIndicator?.classList.add('active');
          if (modeText) modeText.textContent = 'Advanced (Live AI)';
          break;
        case 'reconnecting':
          modeStatus?.classList.add('error');
          if (modeText) modeText.textContent = 'Reconnecting...';
          break;
        case 'error':
          modeStatus?.classList.add('error');
          modeIndicator?.classList.add('error');
          if (modeText) modeText.textContent = 'Connection Error';
          break;
        case 'fallback':
        case 'basic':
        default:
          modeStatus?.classList.add('basic');
          if (modeText) modeText.textContent = 'Basic';
          break;
      }
    }

    function showNotification(message, type = 'info') {
      // Simple notification - could be enhanced with a toast library
      const notification = document.createElement('div');
      notification.className = `notification notification-${type}`;
      notification.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        padding: 12px 20px;
        background: ${type === 'warning' ? 'var(--warning)' : type === 'error' ? 'var(--danger)' : 'var(--primary)'};
        color: ${type === 'warning' ? 'var(--gray-900)' : 'white'};
        border-radius: var(--radius-md);
        z-index: 10000;
        max-width: 350px;
        font-size: 0.875rem;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      `;
      notification.textContent = message;
      document.body.appendChild(notification);

      setTimeout(() => {
        notification.remove();
      }, 5000);
    }

    function disconnectWebSocket() {
      if (wsReconnectTimer) {
        clearTimeout(wsReconnectTimer);
        wsReconnectTimer = null;
      }
      if (ws) {
        ws.close();
        ws = null;
      }
      advancedModeActive = false;
      wsReconnectAttempts = 0;
    }

    function handleWebSocketMessage(data) {
      switch (data.type) {
        case 'transcript':
          console.log('[Transcript] Received:', data.speaker, data.isFinal ? 'FINAL' : 'interim', data.text);
          // Only show final transcripts to avoid fragmented one-word display
          if (data.isFinal) {
            addTranscriptMessage(data.speaker || 'customer', data.text, data.timestamp);
          } else {
            // Show interim results as a typing indicator (optional visual feedback)
            showInterimTranscript(data.speaker || 'customer', data.text);
          }
          break;
        case 'ai_coaching':
          // Handle different coaching response types
          if (data.coachingType === 'flow') {
            // Multi-step conversation flow - show SAY THIS NOW card
            showSayThisNowCard(data);
          } else if (data.coachingType === 'script') {
            // Single script match - show enhanced script card
            showEnhancedScriptCard(data);
          } else {
            // AI-generated suggestion
            showAICoachingSuggestion(data);
          }
          break;
        case 'speaking_started':
          showSpeakingIndicator(data.speaker);
          break;
        case 'speaking_stopped':
          hideSpeakingIndicator();
          break;
        case 'transcription_status':
          handleTranscriptionStatus(data);
          break;
        case 'call_started':
          console.log('Call started:', data.callSid);
          currentCallSid = data.callSid;
          break;
        case 'call_ended':
          console.log('Call ended:', data.callSid);
          // Clear any active flows
          activeFlowState = null;
          break;
      }
    }

    // Track active flow state
    let activeFlowState = null;

    // Show SAY THIS NOW card for conversation flows
    function showSayThisNowCard(data) {
      const container = document.getElementById('aiCoachingContent');

      // Remove empty state if present
      const emptyState = container.querySelector('.ai-empty-state');
      if (emptyState) emptyState.remove();

      // Dim previous SAY THIS NOW cards
      const previousCards = container.querySelectorAll('.say-this-now-card:not(.previous)');
      previousCards.forEach(card => card.classList.add('previous'));

      // Get category info
      const categoryName = data.category?.name || 'price';
      const categoryDisplay = data.category?.display_name || 'Objection';
      const categoryIcon = data.category?.icon || '';

      // Build progress dots
      const totalSteps = data.totalSteps || 4;
      const currentStep = data.stepNumber || 1;
      let progressDots = '';
      for (let i = 1; i <= totalSteps; i++) {
        const dotClass = i < currentStep ? 'completed' : (i === currentStep ? 'active' : '');
        progressDots += `<div class="progress-dot ${dotClass}"></div>`;
      }

      // Build expected responses chips
      let responseChips = '';
      if (data.expectedResponses && data.expectedResponses.length > 0) {
        responseChips = data.expectedResponses.map(response =>
          `<span class="stn-response-chip">${response}</span>`
        ).join('');
      }

      const cardDiv = document.createElement('div');
      cardDiv.className = `say-this-now-card ${categoryName}`;
      cardDiv.dataset.flowId = data.flowId;
      cardDiv.dataset.nodeId = data.nodeId;
      cardDiv.innerHTML = `
        <div class="stn-header">
          <span class="stn-title">SAY THIS NOW</span>
          <span class="stn-badge">
            <span class="stn-badge-icon">${categoryIcon}</span>
            ${categoryDisplay}
          </span>
        </div>
        <div class="stn-progress">
          <div class="progress-dots">${progressDots}</div>
          <span>${data.flowName || 'Flow'} - Step ${currentStep} of ${totalSteps}</span>
        </div>
        <div class="stn-body">
          <div class="stn-script">
            "${data.scriptText}"
            <button class="stn-copy-btn" onclick="copyStnScript(this)" title="Copy to clipboard"></button>
          </div>
          ${data.tips ? `
            <div class="stn-tip">
              <span class="stn-tip-icon"></span>
              <span>${data.tips}</span>
            </div>
          ` : ''}
          ${data.storyText ? `
            <div class="stn-story">
              <button class="stn-story-toggle" onclick="toggleStnStory(this)"> Show Story</button>
              <div class="stn-story-content hidden">${data.storyText}</div>
            </div>
          ` : ''}
          ${responseChips ? `
            <div class="stn-listen-for">
              <div class="stn-listen-label">Listen for:</div>
              <div class="stn-responses">${responseChips}</div>
            </div>
          ` : ''}
        </div>
        <div class="stn-footer">
          <div class="stn-feedback">
            <button class="stn-feedback-btn" onclick="markStnUsed(this, '${data.flowId}', '${data.nodeId}')"> Used</button>
            <button class="stn-feedback-btn" onclick="markStnHelpful(this, true)"></button>
            <button class="stn-feedback-btn" onclick="markStnHelpful(this, false)"></button>
          </div>
          <span class="stn-flow-info">${data.title || ''}</span>
        </div>
      `;

      // Add to top of container
      container.insertBefore(cardDiv, container.firstChild);

      // Update active flow state
      activeFlowState = {
        flowId: data.flowId,
        nodeId: data.nodeId,
        stepNumber: currentStep
      };

      // Keep only last 5 cards
      const allCards = container.querySelectorAll('.say-this-now-card, .ai-tip-card');
      if (allCards.length > 5) {
        for (let i = 5; i < allCards.length; i++) {
          allCards[i].remove();
        }
      }

      // Scroll to top
      container.scrollTop = 0;
    }

    // Show enhanced script card with category info
    function showEnhancedScriptCard(data) {
      const container = document.getElementById('aiCoachingContent');

      // Remove empty state if present
      const emptyState = container.querySelector('.ai-empty-state');
      if (emptyState) emptyState.remove();

      // Get category info
      const categoryName = data.category?.name || 'objection';
      const categoryDisplay = data.category?.display_name || data.category || 'Script';
      const categoryIcon = data.category?.icon || '';

      const cardDiv = document.createElement('div');
      cardDiv.className = `say-this-now-card ${categoryName}`;
      cardDiv.dataset.scriptId = data.scriptId;
      cardDiv.innerHTML = `
        <div class="stn-header">
          <span class="stn-title">TRY THIS</span>
          <span class="stn-badge">
            <span class="stn-badge-icon">${categoryIcon}</span>
            ${categoryDisplay}
          </span>
        </div>
        <div class="stn-body">
          <div class="stn-script">
            "${data.scriptText}"
            <button class="stn-copy-btn" onclick="copyStnScript(this)" title="Copy to clipboard"></button>
          </div>
          ${data.tips ? `
            <div class="stn-tip">
              <span class="stn-tip-icon"></span>
              <span>${data.tips}</span>
            </div>
          ` : ''}
          ${data.storyText ? `
            <div class="stn-story">
              <button class="stn-story-toggle" onclick="toggleStnStory(this)"> Show Story</button>
              <div class="stn-story-content hidden">${data.storyText}</div>
            </div>
          ` : ''}
        </div>
        <div class="stn-footer">
          <div class="stn-feedback">
            <button class="stn-feedback-btn" onclick="markScriptUsed('${data.scriptId}')"> Used</button>
            <button class="stn-feedback-btn" onclick="markScriptHelpful('${data.scriptId}', true)"></button>
            <button class="stn-feedback-btn" onclick="markScriptHelpful('${data.scriptId}', false)"></button>
          </div>
          <span class="stn-flow-info">${data.title || ''}</span>
        </div>
      `;

      // Add to top of container
      container.insertBefore(cardDiv, container.firstChild);

      // Keep only last 5 cards
      const allCards = container.querySelectorAll('.say-this-now-card, .ai-tip-card');
      if (allCards.length > 5) {
        for (let i = 5; i < allCards.length; i++) {
          allCards[i].remove();
        }
      }
    }

    // Show AI-generated coaching suggestion with category context
    function showAICoachingSuggestion(data) {
      const container = document.getElementById('aiCoachingContent');

      // Remove empty state if present
      const emptyState = container.querySelector('.ai-empty-state');
      if (emptyState) emptyState.remove();

      const categoryName = data.category?.name || '';
      const categoryDisplay = data.category?.display_name || 'AI Suggestion';
      const categoryIcon = data.category?.icon || '';

      const cardDiv = document.createElement('div');
      cardDiv.className = `ai-tip-card suggestion ${categoryName}`;
      cardDiv.innerHTML = `
        <div class="ai-tip-header">
          <span>${categoryIcon} ${categoryDisplay}</span>
        </div>
        <div class="ai-tip-text">${data.suggestion}</div>
      `;

      container.insertBefore(cardDiv, container.firstChild);

      // Keep only last 10 tips
      const tips = container.querySelectorAll('.ai-tip-card');
      if (tips.length > 10) {
        tips[tips.length - 1].remove();
      }
    }

    // Copy SAY THIS NOW script text
    async function copyStnScript(button) {
      const scriptDiv = button.closest('.stn-script');
      // Get text content without the button text
      const textContent = scriptDiv.textContent.replace('', '').trim();
      // Remove surrounding quotes if present
      const cleanText = textContent.replace(/^"|"$/g, '');

      try {
        await navigator.clipboard.writeText(cleanText);
        button.textContent = '';
        button.classList.add('copied');
        setTimeout(() => {
          button.textContent = '';
          button.classList.remove('copied');
        }, 2000);
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    }

    // Toggle story visibility in SAY THIS NOW card
    function toggleStnStory(button) {
      const storyContent = button.nextElementSibling;
      const isHidden = storyContent.classList.contains('hidden');

      storyContent.classList.toggle('hidden');
      button.textContent = isHidden ? ' Hide Story' : ' Show Story';
    }

    // Mark SAY THIS NOW card as used
    async function markStnUsed(button, flowId, nodeId) {
      button.classList.add('used');
      button.textContent = ' Used!';

      // Could send analytics to server here
      console.log(`Flow step used: flowId=${flowId}, nodeId=${nodeId}`);
    }

    // Mark SAY THIS NOW card as helpful/not helpful
    function markStnHelpful(button, helpful) {
      button.classList.add(helpful ? 'helpful-yes' : 'helpful-no');

      // Disable both buttons
      const feedback = button.closest('.stn-feedback');
      feedback.querySelectorAll('.stn-feedback-btn').forEach(btn => {
        if (btn !== button) btn.style.opacity = '0.5';
      });
    }

    // Handle transcription status updates from server
    function handleTranscriptionStatus(data) {
      console.log('[Transcription Status]', data);
      const transcriptStatus = document.getElementById('transcriptStatus');
      if (!transcriptStatus) return;

      switch (data.status) {
        case 'active':
          transcriptStatus.textContent = 'Live Transcription';
          transcriptStatus.className = 'badge badge-success';
          if (data.message && data.message.includes('reconnected')) {
            showNotification('Live transcription restored', 'info');
          }
          break;

        case 'reconnecting':
          transcriptStatus.textContent = `Reconnecting (${data.attempt}/${data.maxAttempts})`;
          transcriptStatus.className = 'badge badge-warning';
          break;

        case 'error':
          transcriptStatus.textContent = 'Transcription Issue';
          transcriptStatus.className = 'badge badge-warning';
          break;

        case 'failed':
          transcriptStatus.textContent = 'Recording Only';
          transcriptStatus.className = 'badge badge-secondary';
          showNotification(data.message || 'Live transcription unavailable. Call recording continues.', 'warning');

          // Update mode status to show degraded state
          const modeStatus = document.getElementById('callModeStatus');
          modeStatus?.classList.remove('advanced');
          modeStatus?.classList.add('error');
          const modeTextEl = document.getElementById('modeText');
          if (modeTextEl) modeTextEl.textContent = 'Degraded';
          break;
      }
    }

    // Twilio Device
    async function initializeTwilioDevice() {
      try {
        console.log('Fetching Twilio token for identity:', repIdentity);
        const response = await fetch(`/token?identity=${repIdentity}`);
        const data = await response.json();
        console.log('Token received, initializing device...');

        device = new Twilio.Device(data.token, {
          codecPreferences: ['opus', 'pcmu'],
          logLevel: 1 // Enable debug logging
        });

        device.on('registered', () => {
          console.log('Twilio device registered and ready');
          updateConnectionStatus(true);
          populateAudioDevices();
        });

        device.on('unregistered', () => {
          console.log('Twilio device unregistered');
          updateConnectionStatus(false);
        });

        device.on('error', (error) => {
          console.error('Twilio device error:', error.message || error);
          updateConnectionStatus(false);
        });

        device.on('incoming', handleIncomingCall);

        // Register the device to receive calls
        console.log('Registering Twilio device...');
        await device.register();
        console.log('Device registration complete');

      } catch (error) {
        console.error('Failed to initialize Twilio:', error);
        updateConnectionStatus(false);
      }
    }

    async function populateAudioDevices() {
      const select = document.getElementById('audioDevice');
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioOutputs = devices.filter(d => d.kind === 'audiooutput');

        select.innerHTML = audioOutputs.map(d =>
          `<option value="${d.deviceId}">${d.label || 'Speaker ' + d.deviceId.slice(0, 4)}</option>`
        ).join('');

        select.onchange = () => {
          if (device && device.audio) {
            device.audio.speakerDevices.set(select.value);
          }
        };
      } catch (error) {
        select.innerHTML = '<option>Default Speaker</option>';
      }
    }

    // Call Handling
    async function makeCall() {
      if (!device) {
        alert('Phone system not ready. Please wait and try again.');
        return;
      }

      const phoneInput = document.getElementById('phoneInput');
      let number = phoneInput.value.replace(/\D/g, '');

      if (number.length < 10) {
        alert('Please enter a valid phone number');
        return;
      }

      if (number.length === 10) {
        number = '+1' + number;
      } else if (!number.startsWith('+')) {
        number = '+' + number;
      }

      document.getElementById('phoneNumber').textContent = formatPhoneNumber(number);

      // Pass call mode to server - 'basic', 'advanced', or 'twilio-realtime'
      const callMode = document.getElementById('callModeSelect').value;

      // Warn if using live transcription on localhost (Twilio can't reach localhost)
      const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
      if (isLocalhost && (callMode === 'advanced' || callMode === 'twilio-realtime')) {
        console.warn('[Call] Live transcription modes require a publicly accessible server. Using ngrok? Make sure Twilio TwiML App uses your ngrok URL.');
        showNotification('Note: Live transcription requires ngrok or a public server URL. Call will proceed but live transcription may not work on localhost.', 'warning');
      }

      const params = {
        To: number,
        CallMode: callMode
      };

      console.log(`Making call in ${callMode} mode to ${number}`);
      updateCallState('Connecting...');
      showCallUI();

      try {
        // New SDK: connect returns a Call object via Promise
        connection = await device.connect({ params });

        // Get the CallSid immediately after connect
        currentCallSid = connection.parameters?.CallSid;
        console.log('Call initiated with SID:', currentCallSid);

        // Create call record immediately when call is initiated
        await createCallRecord(number);

        // Track call start for session tracking (auto-starts session if needed)
        await sessionTracker.onCallStarted();

        // Attach event handlers to the call
        connection.on('accept', () => {
          console.log('Call accept event fired');
          handleCallConnected(connection);
        });

        connection.on('disconnect', () => {
          handleCallDisconnected();
        });

        connection.on('error', (error) => {
          console.error('Call error:', error);
          // Log the error but don't block the UI with an alert
          // The call may still work despite some errors
          showNotification('Call issue: ' + (error.message || error), 'warning');
        });

        connection.on('cancel', () => {
          console.log('Call was cancelled');
          updateCallState('Cancelled');
          hideCallUI();
        });

        connection.on('reject', () => {
          console.log('Call was rejected');
          updateCallState('Rejected');
          hideCallUI();
        });

        // Listen for mute events to keep UI in sync
        connection.on('mute', (isMuted) => {
          console.log('[Mute Event] Connection mute state changed:', isMuted);
          document.getElementById('muteBtn')?.classList.toggle('active', isMuted);
          document.getElementById('callControlMute')?.classList.toggle('active', isMuted);
        });

      } catch (error) {
        console.error('Failed to make call:', error);
        showNotification('Failed to connect call: ' + (error.message || error), 'error');
        hideCallUI();
      }

      // Update transcript panel based on mode
      if (callMode === 'basic') {
        document.getElementById('transcriptStatus').textContent = 'Post-call transcript';
        document.getElementById('transcriptStatus').className = 'badge badge-info';
        document.getElementById('transcriptContainer').innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon"></div>
            <div class="empty-state-title">Basic Mode Active</div>
            <div class="empty-state-text">
              Transcript and AI analysis will be available after the call ends.
              <br><br>
              <small style="color: var(--gray-500);">
                Switch to Advanced Mode for live transcription and real-time AI coaching.
              </small>
            </div>
          </div>
        `;
      }
    }

    // Incoming call ringtone
    let ringtoneAudio = null;
    let pendingIncomingCall = null;

    function playRingtone() {
      // Create a pleasant two-tone ringtone using Web Audio API
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const gainNode = audioContext.createGain();
        gainNode.connect(audioContext.destination);
        gainNode.gain.value = 0;

        // Create two oscillators for a classic phone ring
        const osc1 = audioContext.createOscillator();
        const osc2 = audioContext.createOscillator();

        osc1.type = 'sine';
        osc2.type = 'sine';
        osc1.frequency.value = 440; // A4
        osc2.frequency.value = 480; // B4 (creates a pleasing interval)

        const mixer = audioContext.createGain();
        mixer.gain.value = 0.15;

        osc1.connect(mixer);
        osc2.connect(mixer);
        mixer.connect(gainNode);

        osc1.start();
        osc2.start();

        // Ring pattern: ring 1s, pause 2s (like a real phone)
        let isRinging = true;
        gainNode.gain.value = 1;

        // Use recursive setTimeout for alternating timing
        let ringTimeout;
        const scheduleRing = () => {
          const duration = isRinging ? 1000 : 2000; // Ring for 1s, pause for 2s
          ringTimeout = setTimeout(() => {
            isRinging = !isRinging;
            gainNode.gain.setTargetAtTime(isRinging ? 1 : 0, audioContext.currentTime, 0.02);
            scheduleRing();
          }, duration);
        };
        scheduleRing();

        ringtoneAudio = { osc1, osc2, gainNode, audioContext, ringTimeout };
      } catch (e) {
        console.log('Could not play ringtone:', e);
      }
    }

    function stopRingtone() {
      if (ringtoneAudio) {
        try {
          if (ringtoneAudio.ringTimeout) clearTimeout(ringtoneAudio.ringTimeout);
          if (ringtoneAudio.osc1) ringtoneAudio.osc1.stop();
          if (ringtoneAudio.osc2) ringtoneAudio.osc2.stop();
          ringtoneAudio.audioContext.close();
        } catch (e) {
          // Ignore errors when stopping
        }
        ringtoneAudio = null;
      }
    }

    function showIncomingCallModal(phoneNumber) {
      document.getElementById('incomingCallNumber').textContent = formatPhoneNumber(phoneNumber);
      document.getElementById('incomingCallModal').classList.add('active');
      playRingtone();
    }

    function hideIncomingCallModal() {
      document.getElementById('incomingCallModal').classList.remove('active');
      stopRingtone();
    }

    function answerIncomingCall() {
      hideIncomingCallModal();
      if (pendingIncomingCall) {
        pendingIncomingCall.accept();
        pendingIncomingCall = null;
      }
    }

    async function declineIncomingCall() {
      hideIncomingCallModal();
      if (pendingIncomingCall) {
        // Capture caller info before rejecting
        const callerNumber = pendingIncomingCall.parameters?.From || 'Unknown';

        // Create a call record for the declined call
        await createDeclinedCallRecord(callerNumber);

        pendingIncomingCall.reject();
        pendingIncomingCall = null;
        hideCallUI();
        updateCallState('READY');
      }
    }

    // Create call record for declined/missed incoming calls
    async function createDeclinedCallRecord(phoneNumber) {
      console.log('createDeclinedCallRecord: Logging declined call from:', phoneNumber);

      if (!companyId || !currentUser) {
        console.error('Cannot create declined call record: missing company or user');
        return;
      }

      try {
        // Find or create contact for the caller
        const contact = await findOrCreateContact(phoneNumber);
        const contactId = contact?.id || null;

        const insertData = {
          company_id: companyId,
          rep_id: currentUser.id,
          contact_id: contactId,
          phone_number: phoneNumber,
          direction: 'inbound',
          status: 'missed',  // Mark as missed since it was declined
          outcome: null,
          started_at: new Date().toISOString(),
          ended_at: new Date().toISOString(),
          duration_seconds: 0
        };

        const { data, error } = await supabase
          .from('calls')
          .insert(insertData)
          .select('id')
          .single();

        if (error) {
          console.error('createDeclinedCallRecord: Failed:', error);
        } else {
          console.log('createDeclinedCallRecord: SUCCESS - Declined call logged:', data.id);
        }
      } catch (error) {
        console.error('createDeclinedCallRecord: Exception:', error);
      }
    }

    function handleIncomingCall(call) {
      try {
        console.log('Incoming call received, handling...');
        connection = call;
        pendingIncomingCall = call;
        const from = call.parameters?.From || 'Unknown';

        const phoneNumberEl = document.getElementById('phoneNumber');
        if (phoneNumberEl) {
          phoneNumberEl.textContent = formatPhoneNumber(from);
        }

        updateCallState('Incoming call...');
        showCallUI();

        // Attach event handlers to the incoming call
        call.on('accept', () => {
          handleCallConnected(call);
        });

        call.on('disconnect', () => {
          handleCallDisconnected();
        });

        call.on('cancel', async () => {
          console.log('Incoming call cancelled (caller hung up)');
          try {
            const callerNumber = call.parameters?.From || 'Unknown';
            await createDeclinedCallRecord(callerNumber);
          } catch (err) {
            console.error('Error logging declined call:', err);
          }

          hideIncomingCallModal();
          hideCallUI();
          updateCallState('READY');
          pendingIncomingCall = null;
        });

        // Show the incoming call modal
        showIncomingCallModal(from);
      } catch (error) {
        console.error('Error handling incoming call:', error);
        // Try to show basic notification even if main handler fails
        try {
          alert('Incoming call from: ' + (call.parameters?.From || 'Unknown'));
        } catch (e) {}
      }
    }

    async function handleCallConnected(conn) {
      console.log('Call connected');
      currentCallSid = conn.parameters.CallSid;
      updateCallState('Connected');
      startTimer();

      // Track call connected for session tracking
      await sessionTracker.onCallConnected();

      document.getElementById('transcriptStatus').textContent = 'Recording';
      document.getElementById('transcriptStatus').className = 'badge badge-success';

      // Clear empty state
      document.getElementById('transcriptContainer').innerHTML = '';

      // Show customer info and scripts
      const customerInfoCard = document.getElementById('customerInfoCard');
      const scriptsCard = document.getElementById('scriptsCard');
      if (customerInfoCard) customerInfoCard.style.display = 'block';
      if (scriptsCard) scriptsCard.style.display = 'block';

      const phoneNumber = conn.parameters.To || conn.parameters.From;

      // For incoming calls, create the call record now (outbound calls already have one)
      if (!currentCallRecordId) {
        console.log('Creating call record for incoming call from:', phoneNumber);
        await createCallRecordForIncoming(phoneNumber);
      }

      // Load customer history from Supabase
      await loadCustomerHistory(phoneNumber);

      // Update call status to connected
      await updateCallRecord({ status: 'connected' });
    }

    // Create call record specifically for incoming calls
    async function createCallRecordForIncoming(phoneNumber) {
      console.log('createCallRecordForIncoming: Starting with phoneNumber:', phoneNumber);

      if (!companyId || !currentUser) {
        console.error('Cannot create call record: missing company or user', { companyId, userId: currentUser?.id });
        return;
      }

      try {
        // Find or create contact for the caller
        const contact = await findOrCreateContact(phoneNumber);
        currentContactId = contact?.id || null;
        console.log('createCallRecordForIncoming: contact found/created:', currentContactId);

        const insertData = {
          company_id: companyId,
          rep_id: currentUser.id,
          contact_id: currentContactId,
          phone_number: phoneNumber,
          direction: 'inbound',  // Key difference - this is an incoming call
          status: 'in_progress',
          external_call_id: currentCallSid,
          started_at: new Date().toISOString()
        };
        console.log('createCallRecordForIncoming: Inserting:', insertData);

        const { data, error } = await supabase
          .from('calls')
          .insert(insertData)
          .select('id')
          .single();

        if (error) {
          console.error('createCallRecordForIncoming: Failed to create call record:', error);
        } else {
          currentCallRecordId = data.id;
          console.log('createCallRecordForIncoming: SUCCESS - Call record created:', currentCallRecordId);
        }
      } catch (error) {
        console.error('createCallRecordForIncoming: Exception:', error);
      }
    }

    // ===========================================
    // SUPABASE DATA FUNCTIONS
    // ===========================================

    async function createCallRecord(phoneNumber) {
      console.log('createCallRecord: Starting with phoneNumber:', phoneNumber);
      console.log('createCallRecord: companyId:', companyId, 'currentUser:', currentUser?.id);

      if (!companyId || !currentUser) {
        console.error('Cannot create call record: missing company or user', { companyId, userId: currentUser?.id });
        return;
      }

      try {
        // First, try to find or create a contact for this phone number
        const contact = await findOrCreateContact(phoneNumber);
        currentContactId = contact?.id || null;
        console.log('createCallRecord: contact found/created:', currentContactId);

        const insertData = {
          company_id: companyId,
          rep_id: currentUser.id,
          contact_id: currentContactId,
          phone_number: phoneNumber,
          direction: 'outbound',
          status: 'in_progress',
          external_call_id: currentCallSid,
          started_at: new Date().toISOString()
        };
        console.log('createCallRecord: Inserting:', insertData);

        // Create the call record
        const { data, error } = await supabase
          .from('calls')
          .insert(insertData)
          .select('id')
          .single();

        if (error) {
          console.error('createCallRecord: Failed to create call record:', error);
        } else {
          currentCallRecordId = data.id;
          console.log('createCallRecord: SUCCESS - Call record created:', currentCallRecordId);
        }
      } catch (error) {
        console.error('createCallRecord: Exception:', error);
      }
    }

    async function findOrCreateContact(phoneNumber) {
      if (!companyId) return null;

      try {
        // Clean the phone number for searching
        const cleanedPhone = phoneNumber.replace(/\D/g, '');

        // Try to find existing contact
        const { data: existingContacts, error: searchError } = await supabase
          .from('contacts')
          .select('id, first_name, last_name, email, phone, business_name')
          .eq('company_id', companyId)
          .or(`phone.ilike.%${cleanedPhone}%,phone.ilike.%${phoneNumber}%`)
          .limit(1);

        if (searchError) {
          console.error('Error searching for contact:', searchError);
          return null;
        }

        if (existingContacts && existingContacts.length > 0) {
          return existingContacts[0];
        }

        // No existing contact found, create a new one
        const { data: newContact, error: insertError } = await supabase
          .from('contacts')
          .insert({
            company_id: companyId,
            phone: phoneNumber,
            first_name: 'Unknown',
            created_by: currentUser.id,
            lead_source: leadSourceData.source
          })
          .select('id, first_name, last_name, phone')
          .single();

        if (insertError) {
          console.error('Failed to create contact:', insertError);
          return null;
        }

        return newContact;
      } catch (error) {
        console.error('Error in findOrCreateContact:', error);
        return null;
      }
    }

    async function updateCallRecord(updates) {
      if (!currentCallRecordId || !companyId) return;

      try {
        // Security: Filter by both id AND company_id to ensure ownership
        const { error } = await supabase
          .from('calls')
          .update(updates)
          .eq('id', currentCallRecordId)
          .eq('company_id', companyId);

        if (error) {
          console.error('Failed to update call record:', error);
        }
      } catch (error) {
        console.error('Error updating call record:', error);
      }
    }

    async function saveCallbackToSupabase(callbackData) {
      console.log('saveCallbackToSupabase called with:', callbackData);
      console.log('Current state - companyId:', companyId, 'currentUser:', currentUser?.id);

      if (!companyId || !currentUser) {
        console.error('Cannot save callback: Missing companyId or currentUser');
        alert('Unable to save callback: You may need to log in again.');
        return null;
      }

      try {
        const scheduledFor = new Date(`${callbackData.date}T${callbackData.time}`);
        const phoneNumber = document.getElementById('phoneNumber').textContent || document.getElementById('phoneInput').value;

        console.log('Inserting callback with phone:', phoneNumber, 'scheduled for:', scheduledFor);

        const { data, error } = await supabase
          .from('callbacks')
          .insert({
            company_id: companyId,
            assigned_to: currentUser.id,
            contact_id: currentContactId,
            phone_number: phoneNumber,
            scheduled_at: scheduledFor.toISOString(),
            reason: callbackData.reason,
            status: 'pending',
            original_call_id: currentCallRecordId,
            priority: 'normal'
          })
          .select('id')
          .single();

        if (error) {
          console.error('Failed to save callback:', error);
          // Check for common errors
          if (error.code === '42P01') {
            alert('Callback table not found. Please check your database setup.');
          } else if (error.code === '42703') {
            alert('Callback table column mismatch. Please check your database schema.');
          } else {
            alert('Failed to save callback: ' + (error.message || 'Unknown error'));
          }
          return null;
        }

        console.log('Callback saved successfully:', data);
        alert('Callback scheduled successfully!');
        return data;
      } catch (error) {
        console.error('Error saving callback:', error);
        alert('Error saving callback: ' + error.message);
        return null;
      }
    }

    async function handleCallDisconnected() {
      console.log('Call disconnected');
      connection = null; // Clear connection so auto-dial can detect we're not in a call
      stopTimer();
      updateCallState('Call ended');

      // Hide call control buttons since call is over
      document.getElementById('endCallBtn')?.classList.add('hidden');
      document.getElementById('muteBtn')?.classList.add('hidden');
      document.getElementById('holdBtn')?.classList.add('hidden');

      // Calculate call duration
      const duration = callStartTime ? Math.floor((new Date() - callStartTime) / 1000) : 0;

      // Update call record in Supabase with end time and duration
      await updateCallRecord({
        status: 'completed',
        ended_at: new Date().toISOString(),
        duration_seconds: duration
      });

      // Track call ended for session tracking
      await sessionTracker.onCallEnded(currentCallSid);

      // Update status based on call mode
      const wasBasicMode = !advancedModeEnabled || fallbackToBasicMode;

      if (wasBasicMode) {
        document.getElementById('transcriptStatus').textContent = 'Processing transcript...';
        document.getElementById('transcriptStatus').className = 'badge badge-info';

        // Show processing message for Basic Mode
        document.getElementById('transcriptContainer').innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon"></div>
            <div class="empty-state-title">Processing Call</div>
            <div class="empty-state-text">
              Your call recording is being transcribed.<br>
              AI analysis will be available shortly in your call history.
            </div>
          </div>
        `;

        // After a delay, update to show completion
        setTimeout(() => {
          document.getElementById('transcriptStatus').textContent = 'Transcript pending';
          document.getElementById('transcriptStatus').className = 'badge badge-warning';
        }, 3000);
      } else {
        document.getElementById('transcriptStatus').textContent = 'Call ended';
        document.getElementById('transcriptStatus').className = 'badge badge-warning';
      }

      // Show outcome panel
      document.getElementById('outcomePanel')?.classList.remove('hidden');
      document.getElementById('dialPadContainer')?.classList.add('hidden');

      // If auto-dial is enabled and we're in a queue, prepare for next call
      // Note: Auto-dial will continue after outcome is saved (see saveOutcome)
      if (currentQueueIndex >= 0) {
        // The outcome panel will handle marking the current item complete
        // and triggering the next dial
      }
    }

    function endCall() {
      if (connection) {
        connection.disconnect();
      }
    }

    function toggleMute() {
      if (connection) {
        // In Twilio SDK v2, isMuted() is a method that returns the current state
        const isMuted = typeof connection.isMuted === 'function' ? connection.isMuted() : connection.isMuted;
        console.log('[Mute] Current muted state:', isMuted, '-> toggling to:', !isMuted);
        console.log('[Mute] Connection object:', connection);
        console.log('[Mute] connection.mute is:', typeof connection.mute);

        try {
          connection.mute(!isMuted);
          console.log('[Mute] mute() called successfully');

          // Update visual state - when we mute, button should show active
          const newMutedState = !isMuted;
          document.getElementById('muteBtn')?.classList.toggle('active', newMutedState);
          document.getElementById('callControlMute')?.classList.toggle('active', newMutedState);

          // Show notification
          showNotification(newMutedState ? 'Muted' : 'Unmuted', 'info');
        } catch (err) {
          console.error('[Mute] Error calling mute():', err);
          showNotification('Mute failed: ' + err.message, 'error');
        }
      } else {
        console.warn('[Mute] No active connection');
        showNotification('Cannot mute - no active call', 'warning');
      }
    }

    function toggleHold() {
      // Twilio Voice SDK doesn't have native hold - simulate with mute
      // In a production environment, hold would require server-side TwiML
      if (connection) {
        const holdBtn = document.getElementById('holdBtn');
        const callControlHold = document.getElementById('callControlHold');
        const isOnHold = holdBtn?.classList.contains('active');

        if (!isOnHold) {
          // Put on hold - mute the call
          connection.mute(true);
          holdBtn?.classList.add('active');
          callControlHold?.classList.add('active');
          updateCallState('On Hold');
        } else {
          // Resume from hold - unmute
          connection.mute(false);
          holdBtn?.classList.remove('active');
          callControlHold?.classList.remove('active');
          updateCallState('Connected');
          // Also update mute button state
          document.getElementById('muteBtn')?.classList.remove('active');
          document.getElementById('callControlMute')?.classList.remove('active');
        }
      }
    }

    // Transfer functions
    let transferType = 'blind';

    function openTransferModal() {
      document.getElementById('transferModal').classList.add('visible');
      document.getElementById('transferNumber').value = '';
      document.getElementById('transferNumber').focus();
    }

    function closeTransferModal() {
      document.getElementById('transferModal').classList.remove('visible');
    }

    function selectTransferType(type) {
      transferType = type;
      // Update UI to show selected
      document.querySelectorAll('.transfer-option').forEach(opt => {
        opt.style.borderColor = '';
        opt.style.background = '';
      });
      event.currentTarget.style.borderColor = 'var(--primary)';
      event.currentTarget.style.background = '#f0f9ff';
    }

    async function executeTransfer() {
      const transferTo = document.getElementById('transferNumber').value.trim();
      if (!transferTo) {
        alert('Please enter a number to transfer to');
        return;
      }

      if (!currentCallSid) {
        alert('No active call to transfer');
        closeTransferModal();
        return;
      }

      // Format phone number if needed
      let formattedNumber = transferTo;
      if (!transferTo.startsWith('+')) {
        // Assume US number if no country code
        formattedNumber = '+1' + transferTo.replace(/\D/g, '');
      }

      console.log(`Executing ${transferType} transfer to ${formattedNumber}`);

      // Show loading state
      const transferBtn = document.querySelector('.transfer-modal-actions .transfer-btn');
      const originalText = transferBtn.textContent;
      transferBtn.textContent = 'Transferring...';
      transferBtn.disabled = true;

      try {
        const response = await fetch('/api/call/transfer', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            callSid: currentCallSid,
            transferTo: formattedNumber,
            transferType: transferType
          })
        });

        const result = await response.json();

        if (result.success) {
          console.log('Transfer initiated:', result);

          if (transferType === 'blind') {
            // Blind transfer - call is handed off, we're done
            updateCallState('Transferred');
            setTimeout(() => {
              hideCallUI();
              updateCallState('Ready');
            }, 2000);
          } else {
            // Warm transfer - we're now in a conference
            // Store conference info for completing the transfer later
            window.currentTransferConference = result.conferenceName;
            updateCallState('Conference');

            // Show a notification that the transfer party is being called
            alert(`Calling ${transferTo}... You can speak with them before completing the transfer.`);
          }

          closeTransferModal();
        } else {
          throw new Error(result.error || 'Transfer failed');
        }
      } catch (error) {
        console.error('Transfer error:', error);
        alert('Transfer failed: ' + error.message);
      } finally {
        transferBtn.textContent = originalText;
        transferBtn.disabled = false;
      }
    }

    // Quick Note functions
    function addQuickNote() {
      document.getElementById('quickNoteModal').classList.add('visible');
      document.getElementById('quickNoteText').value = '';
      document.getElementById('quickNoteText').focus();
    }

    function closeQuickNoteModal() {
      document.getElementById('quickNoteModal').classList.remove('visible');
    }

    async function saveQuickNote() {
      const noteText = document.getElementById('quickNoteText').value.trim();
      if (!noteText) {
        alert('Please enter a note');
        return;
      }

      try {
        // Try to save to contact_notes if we have a contact
        if (currentContact && currentContact.id) {
          const { error } = await supabase
            .from('contact_notes')
            .insert({
              contact_id: currentContact.id,
              note: noteText,
              created_at: new Date().toISOString()
            });

          if (error) throw error;
          console.log('Quick note saved to contact');
          showNotification('Note saved to contact', 'success');
        }
        // Otherwise save to call record notes if we have an active call
        else if (currentCallRecordId) {
          const { error } = await supabase
            .from('calls')
            .update({
              notes: noteText
            })
            .eq('id', currentCallRecordId);

          if (error) throw error;
          console.log('Quick note saved to call record');
          showNotification('Note saved to call', 'success');
        }
        // No contact or call record - show error
        else {
          showNotification('Could not save note - no contact or call found', 'error');
          console.warn('No contact or call record to save note to');
        }
      } catch (err) {
        console.error('Error saving note:', err);
        showNotification('Failed to save note', 'error');
      }

      closeQuickNoteModal();
    }

    // Contact Search functions
    let searchTimeout = null;

    function searchContacts(query) {
      const resultsContainer = document.getElementById('contactSearchResults');

      if (!query || query.length < 2) {
        resultsContainer.classList.remove('visible');
        return;
      }

      // Debounce the search
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(async () => {
        try {
          // Search in Supabase - search by name, phone, and email
          const { data: contacts, error } = await supabase
            .from('contacts')
            .select('*')
            .or(`first_name.ilike.%${query}%,last_name.ilike.%${query}%,phone.ilike.%${query}%,email.ilike.%${query}%`)
            .limit(10);

          if (error) throw error;

          if (contacts && contacts.length > 0) {
            resultsContainer.innerHTML = contacts.map(contact => {
              const initials = (contact.first_name?.[0] || '') + (contact.last_name?.[0] || '');
              const name = `${contact.first_name || ''} ${contact.last_name || ''}`.trim() || 'Unknown';
              const subtitle = contact.phone || contact.email || 'No contact info';
              return `
                <div class="search-result-item" onclick="selectSearchContact(${JSON.stringify(contact).replace(/"/g, '&quot;')})">
                  <div class="avatar">${initials || '?'}</div>
                  <div class="info">
                    <div class="name">${name}</div>
                    <div class="phone">${subtitle}</div>
                  </div>
                  ${contact.phone ? `<button class="call-btn" onclick="event.stopPropagation(); callSearchContact('${contact.phone}')">Call</button>` : ''}
                </div>
              `;
            }).join('');
          } else {
            resultsContainer.innerHTML = '<div class="no-results">No contacts found</div>';
          }

          resultsContainer.classList.add('visible');
        } catch (err) {
          console.error('Search error:', err);
          resultsContainer.innerHTML = '<div class="no-results">Search error</div>';
          resultsContainer.classList.add('visible');
        }
      }, 300);
    }

    function selectSearchContact(contact) {
      // Update the phone input
      document.getElementById('phoneInput').value = contact.phone || '';
      // Clear search
      document.getElementById('contactSearchInput').value = '';
      document.getElementById('contactSearchResults').classList.remove('visible');
      // Update customer panel
      currentContact = contact;
      updateCustomerPanel(contact);
    }

    function callSearchContact(phone) {
      document.getElementById('phoneInput').value = phone;
      document.getElementById('contactSearchInput').value = '';
      document.getElementById('contactSearchResults').classList.remove('visible');
      // Trigger call
      makeCall();
    }

    // Close search results when clicking outside
    document.addEventListener('click', function(e) {
      const searchBar = document.querySelector('.contact-search-bar');
      if (searchBar && !searchBar.contains(e.target)) {
        document.getElementById('contactSearchResults').classList.remove('visible');
      }
    });

    // UI Updates
    function showCallUI() {
      document.getElementById('dialPadContainer')?.classList.add('hidden');
      document.getElementById('callBtn')?.classList.add('hidden');
      document.getElementById('muteBtn')?.classList.remove('hidden');
      document.getElementById('endCallBtn')?.classList.remove('hidden');
      document.getElementById('holdBtn')?.classList.remove('hidden');
      // Hide the dialer controls row (call button) and show in-call controls
      const dialerControls = document.querySelector('.compact-dialer .dialer-controls');
      if (dialerControls) dialerControls.style.display = 'none';
      document.getElementById('inCallControls')?.classList.add('visible');
      // Show call timer
      const timerEl = document.getElementById('callTimer');
      if (timerEl) timerEl.style.display = 'block';
    }

    function hideCallUI() {
      document.getElementById('dialPadContainer')?.classList.remove('hidden');
      document.getElementById('callBtn')?.classList.remove('hidden');
      document.getElementById('muteBtn')?.classList.add('hidden');
      document.getElementById('endCallBtn')?.classList.add('hidden');
      document.getElementById('holdBtn')?.classList.add('hidden');
      document.getElementById('outcomePanel')?.classList.add('hidden');
      // Show the dialer controls row and hide in-call controls
      const dialerControls = document.querySelector('.compact-dialer .dialer-controls');
      if (dialerControls) dialerControls.style.display = 'flex';
      document.getElementById('inCallControls')?.classList.remove('visible');
      document.getElementById('callControlMute')?.classList.remove('active');
      document.getElementById('callControlHold')?.classList.remove('active');
      // Hide call timer
      const timerEl = document.getElementById('callTimer');
      if (timerEl) timerEl.style.display = 'none';
    }

    function updateCallState(state) {
      const stateEl = document.getElementById('callState');
      stateEl.textContent = state;
      stateEl.className = 'call-state';

      if (state === 'Connected') {
        stateEl.classList.add('connected');
      } else if (state === 'Connecting...' || state === 'Incoming call...') {
        stateEl.classList.add('ringing');
      }
    }

    function updateConnectionStatus(connected) {
      const statusEl = document.getElementById('connectionStatus');
      const userStatusEl = document.getElementById('userStatus');
      const connectionTextEl = document.getElementById('connectionText');

      if (connected) {
        statusEl.className = 'connection-status connected';
        statusEl.innerHTML = '<span class="connection-dot"></span><span class="desktop-only">Connected</span>';
        if (userStatusEl) userStatusEl.style.color = 'var(--success)';
        if (connectionTextEl) connectionTextEl.textContent = 'Available';
      } else {
        statusEl.className = 'connection-status disconnected';
        statusEl.innerHTML = '<span class="connection-dot"></span><span class="desktop-only">Disconnected</span>';
        if (userStatusEl) userStatusEl.style.color = 'var(--gray-400)';
        if (connectionTextEl) connectionTextEl.textContent = 'Offline';
      }
    }

    // Timer
    function startTimer() {
      callStartTime = new Date();
      timerInterval = setInterval(updateTimer, 1000);
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    function updateTimer() {
      if (!callStartTime) return;
      const elapsed = Math.floor((new Date() - callStartTime) / 1000);
      const mins = Math.floor(elapsed / 60);
      const secs = elapsed % 60;
      document.getElementById('callTimer').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Transcript
    function addTranscriptMessage(speaker, text, timestamp) {
      const container = document.getElementById('transcriptContainer');

      // Remove empty state if present
      const emptyState = container.querySelector('.empty-state');
      if (emptyState) emptyState.remove();

      // Remove any interim indicator when adding final message
      const interimIndicator = container.querySelector('.interim-transcript');
      if (interimIndicator) interimIndicator.remove();

      const speakerLabel = speaker === 'rep' ? 'You' : 'Customer';
      const messageDiv = document.createElement('div');
      messageDiv.className = `transcript-message ${speaker === 'rep' ? 'rep' : 'customer'}`;
      messageDiv.innerHTML = `
        <div class="speaker-label">${speakerLabel}</div>
        ${text}
        <div class="transcript-time">${formatTime(timestamp)}</div>
      `;

      container.appendChild(messageDiv);
      container.scrollTop = container.scrollHeight;
    }

    // Show interim transcript as a typing indicator (updates in place)
    function showInterimTranscript(speaker, text) {
      const container = document.getElementById('transcriptContainer');

      // Remove empty state if present
      const emptyState = container.querySelector('.empty-state');
      if (emptyState) emptyState.remove();

      // Find or create interim indicator
      let interimIndicator = container.querySelector('.interim-transcript');
      if (!interimIndicator) {
        interimIndicator = document.createElement('div');
        interimIndicator.className = `transcript-message interim-transcript ${speaker === 'rep' ? 'rep' : 'customer'}`;
        interimIndicator.style.opacity = '0.6';
        interimIndicator.style.fontStyle = 'italic';
        container.appendChild(interimIndicator);
      }

      // Update the interim text
      interimIndicator.className = `transcript-message interim-transcript ${speaker === 'rep' ? 'rep' : 'customer'}`;
      interimIndicator.innerHTML = `${text} <span style="color: var(--gray-400);">...</span>`;
      container.scrollTop = container.scrollHeight;
    }

    function showSpeakingIndicator(speaker) {
      const indicator = document.getElementById('speakingIndicator');
      const text = document.getElementById('speakingText');
      text.textContent = speaker === 'customer' ? 'Customer is speaking...' : 'You are speaking...';
      indicator.classList.remove('hidden');
    }

    function hideSpeakingIndicator() {
      document.getElementById('speakingIndicator').classList.add('hidden');
    }

    // AI Coaching Panel Functions
    function addAICoachingTip(type, text, script = null) {
      const container = document.getElementById('aiCoachingContent');

      // Remove empty state if present
      const emptyState = container.querySelector('.ai-empty-state');
      if (emptyState) emptyState.remove();

      // Determine tip category and icon
      const typeConfig = {
        suggestion: { icon: '', label: 'Suggestion' },
        objection: { icon: '', label: 'Objection Detected' },
        success: { icon: '', label: 'Good Job' },
        signal: { icon: '', label: 'Buying Signal' }
      };

      const config = typeConfig[type] || typeConfig.suggestion;

      const tipDiv = document.createElement('div');
      tipDiv.className = `ai-tip-card ${type}`;
      tipDiv.innerHTML = `
        <div class="ai-tip-header">${config.icon} ${config.label}</div>
        <div class="ai-tip-text">${text}</div>
        ${script ? `<div class="ai-tip-script">"${script}"</div>` : ''}
      `;

      // Add to top of container (newest first)
      container.insertBefore(tipDiv, container.firstChild);

      // Keep only last 10 tips to prevent overflow
      const tips = container.querySelectorAll('.ai-tip-card');
      if (tips.length > 10) {
        tips[tips.length - 1].remove();
      }
    }

    // Legacy function for backwards compatibility
    function showAICoaching(suggestion) {
      // Determine type based on content
      let type = 'suggestion';
      if (suggestion.toLowerCase().includes('objection') || suggestion.toLowerCase().includes('expensive') || suggestion.toLowerCase().includes('too much')) {
        type = 'objection';
      } else if (suggestion.toLowerCase().includes('good') || suggestion.toLowerCase().includes('great') || suggestion.toLowerCase().includes('nice')) {
        type = 'success';
      } else if (suggestion.toLowerCase().includes('interest') || suggestion.toLowerCase().includes('signal') || suggestion.toLowerCase().includes('buying')) {
        type = 'signal';
      }

      addAICoachingTip(type, suggestion);
    }

    function clearAICoachingPanel() {
      const container = document.getElementById('aiCoachingContent');
      container.innerHTML = `
        <div class="ai-empty-state" id="aiEmptyState">
          <div class="ai-empty-icon"></div>
          <div class="ai-empty-title">AI Coach Ready</div>
          <div class="ai-empty-text">Start a call to receive real-time coaching tips and objection handling suggestions.</div>
        </div>
      `;
    }

    // Show a script card from the knowledge base
    function showScriptCard(data) {
      const container = document.getElementById('aiCoachingContent');

      // Remove empty state if present
      const emptyState = container.querySelector('.ai-empty-state');
      if (emptyState) emptyState.remove();

      // Category icons and labels
      const categoryConfig = {
        objection: { icon: '', label: 'Objection Handler', color: 'objection' },
        story: { icon: '', label: 'Story', color: 'story' },
        close: { icon: '', label: 'Close', color: 'close' },
        opener: { icon: '', label: 'Opener', color: 'opener' },
        rebuttall: { icon: '', label: 'Rebuttal', color: 'objection' }
      };

      const config = categoryConfig[data.category] || categoryConfig.objection;
      const scriptId = data.scriptId;

      const cardDiv = document.createElement('div');
      cardDiv.className = `ai-tip-card script-match ${config.color}`;
      cardDiv.dataset.scriptId = scriptId;
      cardDiv.innerHTML = `
        <div class="script-header">
          <span class="script-category">${config.icon} ${config.label}</span>
          <span class="script-title">${data.title}</span>
        </div>
        <div class="script-body">
          <div class="script-text-box">
            <p class="script-text">${data.scriptText}</p>
            <button class="copy-script-btn" onclick="copyScript(this, '${scriptId}')" title="Copy to clipboard"></button>
          </div>
          ${data.storyText ? `
            <div class="script-story">
              <button class="story-toggle" onclick="toggleStory(this)"> Show Story</button>
              <div class="story-content hidden">
                <p>${data.storyText}</p>
              </div>
            </div>
          ` : ''}
          ${data.tips ? `
            <div class="script-tips">
              <span class="tips-label"> Tip:</span> ${data.tips}
            </div>
          ` : ''}
        </div>
        <div class="script-feedback">
          <button class="feedback-btn used" onclick="markScriptUsed('${scriptId}')" title="I used this script">
             Used This
          </button>
          <button class="feedback-btn helpful" onclick="markScriptHelpful('${scriptId}', true)" title="Helpful">
            
          </button>
          <button class="feedback-btn not-helpful" onclick="markScriptHelpful('${scriptId}', false)" title="Not helpful">
            
          </button>
        </div>
      `;

      // Add to top of container (newest first)
      container.insertBefore(cardDiv, container.firstChild);

      // Keep only last 8 cards to prevent overflow
      const cards = container.querySelectorAll('.ai-tip-card');
      if (cards.length > 8) {
        cards[cards.length - 1].remove();
      }

      // Animate entrance
      cardDiv.style.animation = 'slideIn 0.3s ease-out';
    }

    // Copy script text to clipboard
    async function copyScript(button, scriptId) {
      const card = button.closest('.ai-tip-card');
      const scriptText = card.querySelector('.script-text').textContent;

      try {
        await navigator.clipboard.writeText(scriptText);
        button.textContent = '';
        button.classList.add('copied');
        setTimeout(() => {
          button.textContent = '';
          button.classList.remove('copied');
        }, 2000);
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    }

    // Toggle story visibility
    function toggleStory(button) {
      const storyContent = button.nextElementSibling;
      const isHidden = storyContent.classList.contains('hidden');

      storyContent.classList.toggle('hidden');
      button.textContent = isHidden ? ' Hide Story' : ' Show Story';
    }

    // Mark script as used
    async function markScriptUsed(scriptId) {
      try {
        await fetch(`/api/scripts/${scriptId}/used`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ callSid: currentCallSid })
        });

        // Update button state
        const card = document.querySelector(`[data-script-id="${scriptId}"]`);
        if (card) {
          const btn = card.querySelector('.feedback-btn.used');
          btn.classList.add('active');
          btn.textContent = ' Used';
        }

        showNotification('Script marked as used', 'success');
      } catch (error) {
        console.error('Failed to mark script as used:', error);
      }
    }

    // Mark script as helpful or not
    async function markScriptHelpful(scriptId, helpful) {
      try {
        await fetch(`/api/scripts/${scriptId}/feedback`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            callSid: currentCallSid,
            helpful: helpful
          })
        });

        // Update button states
        const card = document.querySelector(`[data-script-id="${scriptId}"]`);
        if (card) {
          const helpfulBtn = card.querySelector('.feedback-btn.helpful');
          const notHelpfulBtn = card.querySelector('.feedback-btn.not-helpful');

          if (helpful) {
            helpfulBtn.classList.add('active');
            notHelpfulBtn.classList.remove('active');
          } else {
            notHelpfulBtn.classList.add('active');
            helpfulBtn.classList.remove('active');
          }
        }
      } catch (error) {
        console.error('Failed to record feedback:', error);
      }
    }

    // Transcript Search
    function searchTranscript(query) {
      const container = document.getElementById('transcriptContainer');
      const messages = container.querySelectorAll('.transcript-message');

      query = query.toLowerCase().trim();

      messages.forEach(msg => {
        if (!query) {
          msg.style.display = '';
          msg.innerHTML = msg.innerHTML.replace(/<mark class="search-highlight">(.*?)<\/mark>/gi, '$1');
        } else {
          const text = msg.textContent.toLowerCase();
          if (text.includes(query)) {
            msg.style.display = '';
            // Highlight matching text
            const regex = new RegExp(`(${query})`, 'gi');
            const originalHTML = msg.innerHTML.replace(/<mark class="search-highlight">(.*?)<\/mark>/gi, '$1');
            msg.innerHTML = originalHTML.replace(regex, '<mark class="search-highlight">$1</mark>');
          } else {
            msg.style.display = 'none';
          }
        }
      });
    }

    // Scripts
    function showScript(scriptId) {
      const script = scripts[scriptId];
      if (!script) return;

      document.getElementById('scriptTitle').textContent = script.title;
      document.getElementById('scriptContent').innerHTML = script.content.replace(/\n/g, '<br>');
      document.getElementById('scriptModal').classList.add('active');
    }

    function closeScriptModal() {
      document.getElementById('scriptModal').classList.remove('active');
    }

    // Customer History
    async function loadCustomerHistory(phoneNumber) {
      if (!companyId) {
        console.log('No company ID, skipping customer history load');
        return;
      }

      if (!phoneNumber) {
        console.log('No phone number provided, skipping customer history load');
        return;
      }

      try {
        // Clean the phone number for searching
        const cleanedPhone = phoneNumber.replace(/\D/g, '');

        // Find contact by phone number
        const { data: contacts, error: contactError } = await supabase
          .from('contacts')
          .select('id, first_name, last_name, email, phone, business_name, tags, lead_source')
          .eq('company_id', companyId)
          .or(`phone.ilike.%${cleanedPhone}%,phone.ilike.%${phoneNumber}%`)
          .limit(1);

        if (contactError) {
          console.error('Error loading contact:', contactError);
          return;
        }

        let history = {
          contact: null,
          calls: [],
          totalCalls: 0,
          lastCall: null,
          lastNote: null
        };

        if (contacts && contacts.length > 0) {
          const contact = contacts[0];
          history.contact = contact;
          currentContactId = contact.id;

          // Update contact info display
          updateContactDisplay(contact);

          // Load call history for this contact
          const { data: calls, error: callsError } = await supabase
            .from('calls')
            .select('id, started_at, duration_seconds, outcome')
            .eq('company_id', companyId)
            .eq('contact_id', contact.id)
            .order('started_at', { ascending: false })
            .limit(10);

          if (!callsError && calls) {
            history.calls = calls.map(c => ({ ...c, duration: c.duration_seconds }));
            history.totalCalls = calls.length;
            if (calls.length > 0) {
              history.lastCall = calls[0].started_at;
              history.lastNote = null; // Notes not stored in calls table
            }
          }
        }

        renderCustomerHistory(history);
      } catch (error) {
        console.error('Error loading customer history:', error);
      }
    }

    function updateContactDisplay(contact) {
      // Update customer name display if we have contact info
      const nameEl = document.getElementById('customerName');
      const businessEl = document.getElementById('customerBusiness');

      if (nameEl && contact) {
        const name = [contact.first_name, contact.last_name].filter(Boolean).join(' ');
        nameEl.textContent = name || 'Unknown Contact';
      }

      if (businessEl && contact?.business_name) {
        businessEl.textContent = contact.business_name;
        businessEl.style.display = 'block';
      }
    }

    function renderCustomerHistory(history) {
      const container = document.getElementById('customerHistory');

      if (!history || history.calls.length === 0) {
        // Show contact info if available even without call history
        if (history?.contact) {
          const contact = history.contact;
          const name = [contact.first_name, contact.last_name].filter(Boolean).join(' ');
          container.innerHTML = `
            <div class="text-sm mb-2">
              <strong>Contact:</strong> ${escapeHtml(name) || 'Unknown'}
            </div>
            ${contact.email ? `
              <div class="text-sm mb-2">
                <strong>Email:</strong> ${escapeHtml(contact.email)}
              </div>
            ` : ''}
            ${contact.business_name ? `
              <div class="text-sm mb-2">
                <strong>Business:</strong> ${escapeHtml(contact.business_name)}
              </div>
            ` : ''}
            <div class="text-sm text-muted">No previous call history</div>
          `;
        } else {
          container.innerHTML = '<div class="text-sm text-muted">No previous history with this customer</div>';
        }
        return;
      }

      const contact = history.contact;
      const name = contact ? [contact.first_name, contact.last_name].filter(Boolean).join(' ') : null;

      container.innerHTML = `
        ${name ? `
          <div class="text-sm mb-2">
            <strong>Contact:</strong> ${escapeHtml(name)}
          </div>
        ` : ''}
        ${contact?.business_name ? `
          <div class="text-sm mb-2">
            <strong>Business:</strong> ${escapeHtml(contact.business_name)}
          </div>
        ` : ''}
        ${contact?.email ? `
          <div class="text-sm mb-2">
            <strong>Email:</strong> ${escapeHtml(contact.email)}
          </div>
        ` : ''}
        <div class="text-sm mb-2">
          <strong>Last call:</strong> ${formatDate(history.lastCall)}
        </div>
        <div class="text-sm mb-2">
          <strong>Total calls:</strong> ${history.totalCalls}
        </div>
        ${history.lastNote ? `
          <div class="text-sm">
            <strong>Previous notes:</strong><br>
            <span class="text-muted">"${escapeHtml(history.lastNote)}"</span>
          </div>
        ` : ''}
      `;
    }

    // Outcome Handling
    function selectOutcome(outcome) {
      selectedOutcome = outcome;

      document.querySelectorAll('.outcome-btn').forEach(btn => {
        btn.classList.remove('selected');
        if (btn.dataset.outcome === outcome) {
          btn.classList.add('selected');
        }
      });

      // Show callback scheduler if callback selected
      const scheduler = document.getElementById('callbackScheduler');
      if (outcome === 'callback') {
        scheduler.classList.remove('hidden');
        // Set default date to tomorrow
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        document.getElementById('callbackDate').value = tomorrow.toISOString().split('T')[0];
        document.getElementById('callbackTime').value = '14:00';
      } else {
        scheduler.classList.add('hidden');
      }
    }

    async function saveOutcome() {
      if (!selectedOutcome) {
        alert('Please select an outcome');
        return;
      }

      const notes = document.getElementById('outcomeNotes').value || document.getElementById('callNotes').value;

      const data = {
        callSid: currentCallSid,
        outcome: selectedOutcome,
        notes: notes
      };

      if (selectedOutcome === 'callback') {
        data.callbackDate = document.getElementById('callbackDate').value;
        data.callbackTime = document.getElementById('callbackTime').value;
        data.callbackReason = document.getElementById('callbackReason').value;
      }

      // Save outcome to Supabase
      try {
        // Update call record with outcome
        await updateCallRecord({
          outcome: selectedOutcome
        });

        // Save notes to call_notes table if provided
        if (notes && notes.trim() && currentCallRecordId && companyId) {
          const { error: notesError } = await supabase
            .from('call_notes')
            .insert({
              call_id: currentCallRecordId,
              contact_id: currentContactId,
              author_id: currentUser.id,
              content: notes.trim(),
              note_type: 'manual'
            });
          if (notesError) {
            console.error('Failed to save notes:', notesError);
          } else {
            console.log('Notes saved successfully');
          }
        }

        // Also save lead source if set
        if (leadSourceData.source) {
          await sendLeadSourceToServer();
        }

        // If callback selected, create callback record in Supabase
        if (selectedOutcome === 'callback' && data.callbackDate && data.callbackTime) {
          await saveCallbackToSupabase({
            date: data.callbackDate,
            time: data.callbackTime,
            reason: data.callbackReason
          });
        }

        // Update contact with last call info
        // Security: Filter by both id AND company_id to ensure ownership
        if (currentContactId && companyId) {
          await supabase
            .from('contacts')
            .update({
              last_call_at: new Date().toISOString(),
              last_call_outcome: selectedOutcome,
              updated_at: new Date().toISOString()
            })
            .eq('id', currentContactId)
            .eq('company_id', companyId);
        }

        console.log('Outcome saved to Supabase');

        // Track booking for session tracking
        if (selectedOutcome === 'booked') {
          sessionTracker.onBooking();
        }

        // Show brief success feedback
        updateCallState('Saved ');
      } catch (error) {
        console.error('Failed to save outcome to Supabase:', error);
        alert('Warning: Could not save to database. ' + error.message);
      }

      // Also send to original API endpoint for backwards compatibility
      try {
        await fetch('/api/call-outcome', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
      } catch (error) {
        console.error('Failed to save outcome to API:', error);
      }

      // Mark queue item as complete
      markCurrentQueueItemComplete(selectedOutcome);
      saveQueueToStorage();

      // Check if we should auto-dial next
      console.log('Auto-dial check:', { autoDialEnabled, hasPending: callQueue.some(i => i.status === 'pending') });
      if (autoDialEnabled && callQueue.some(i => i.status === 'pending')) {
        // Get delay setting BEFORE resetting UI
        const delay = parseInt(document.getElementById('dialDelay').value) * 1000;
        const delaySeconds = delay / 1000;
        console.log('Auto-dial will continue with delay:', delay);

        // Find next pending contact for display
        const nextContact = callQueue.find(i => i.status === 'pending');

        // Reset UI for next call
        resetForNextCall();

        // Show auto-dial countdown
        if (delay > 0) {
          // Show the countdown overlay
          showCountdown(delaySeconds, nextContact);

          // Clear any existing timeout
          if (autoDialTimeout) {
            clearTimeout(autoDialTimeout);
          }

          autoDialTimeout = setTimeout(() => {
            console.log('Auto-dial timeout fired, calling dialNextInQueue');
            hideCountdown();
            dialNextInQueue();
          }, delay);
        } else {
          // No delay, dial immediately
          dialNextInQueue();
        }
      } else {
        // No auto-dial, go back to dashboard or stay on page
        if (!callQueue.some(i => i.status === 'pending')) {
          // Queue empty, could go to dashboard
          // window.location.href = '/dashboard';
          resetForNextCall();
        } else {
          resetForNextCall();
        }
      }
    }

    function skipOutcome() {
      // Mark as no_answer/skipped if in queue
      if (currentQueueIndex >= 0) {
        markCurrentQueueItemComplete('skipped');
        saveQueueToStorage();
      }

      // Check if we should auto-dial next
      console.log('Skip - Auto-dial check:', { autoDialEnabled, hasPending: callQueue.some(i => i.status === 'pending') });
      if (autoDialEnabled && callQueue.some(i => i.status === 'pending')) {
        const delay = parseInt(document.getElementById('dialDelay').value) * 1000;
        const delaySeconds = delay / 1000;
        console.log('Skip - Auto-dial will continue with delay:', delay);

        // Find next pending contact for display
        const nextContact = callQueue.find(i => i.status === 'pending');

        resetForNextCall();

        if (delay > 0) {
          // Show the countdown overlay
          showCountdown(delaySeconds, nextContact);

          // Clear any existing timeout
          if (autoDialTimeout) {
            clearTimeout(autoDialTimeout);
          }

          autoDialTimeout = setTimeout(() => {
            console.log('Skip - Auto-dial timeout fired, calling dialNextInQueue');
            hideCountdown();
            dialNextInQueue();
          }, delay);
        } else {
          dialNextInQueue();
        }
      } else {
        resetForNextCall();
      }
    }

    function resetForNextCall() {
      // Reset the UI for the next call
      selectedOutcome = null;
      currentCallSid = null;

      // Reset Supabase state for next call
      currentCallRecordId = null;
      currentContactId = null;

      // Hide outcome panel
      document.getElementById('outcomePanel').classList.add('hidden');

      // Reset outcome buttons
      document.querySelectorAll('.outcome-btn').forEach(btn => {
        btn.classList.remove('selected');
      });

      // Clear notes
      document.getElementById('outcomeNotes').value = '';
      document.getElementById('callNotes').value = '';
      document.getElementById('callbackScheduler').classList.add('hidden');

      // Reset call display
      document.getElementById('phoneNumber').textContent = 'Enter number to call';
      document.getElementById('callTimer').textContent = '0:00';
      document.getElementById('callState').textContent = 'Ready';
      document.getElementById('callState').className = 'call-state';

      // Show dial pad, hide call controls
      hideCallUI();

      // Clear transcript
      document.getElementById('transcriptContainer').innerHTML = `
        <div class="empty-state">
          <div class="empty-state-icon"></div>
          <div class="empty-state-title">No transcript yet</div>
          <div class="empty-state-text">Start a call to see real-time transcription</div>
        </div>
      `;

      // Clear AI coaching panel
      clearAICoachingPanel();

      // Clear search
      document.getElementById('transcriptSearchInput').value = '';

      document.getElementById('transcriptStatus').textContent = 'Waiting for call';
      document.getElementById('transcriptStatus').className = 'badge badge-info';

      // Hide customer info and scripts
      const customerInfoCard = document.getElementById('customerInfoCard');
      const scriptsCard = document.getElementById('scriptsCard');
      if (customerInfoCard) customerInfoCard.style.display = 'none';
      if (scriptsCard) scriptsCard.style.display = 'none';

      // Hide AI coach
      document.getElementById('aiCoachBox')?.classList.add('hidden');

      // Reset lead source
      resetLeadSource();
    }

    // Event Listeners
    function setupEventListeners() {
      // Dial pad buttons
      document.querySelectorAll('.dial-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const digit = btn.dataset.digit;
          const input = document.getElementById('phoneInput');
          input.value += digit;

          // Send DTMF if in call
          if (connection) {
            connection.sendDigits(digit);
          }
        });
      });

      // Phone input formatting
      document.getElementById('phoneInput').addEventListener('input', (e) => {
        let value = e.target.value.replace(/\D/g, '');
        if (value.length > 0) {
          if (value.length <= 3) {
            value = `(${value}`;
          } else if (value.length <= 6) {
            value = `(${value.slice(0, 3)}) ${value.slice(3)}`;
          } else {
            value = `(${value.slice(0, 3)}) ${value.slice(3, 6)}-${value.slice(6, 10)}`;
          }
        }
        e.target.value = value;
      });

      // Enter key to call
      document.getElementById('phoneInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          makeCall();
        }
      });

      // Call button
      document.getElementById('callBtn').addEventListener('click', makeCall);

      // End call button
      document.getElementById('endCallBtn').addEventListener('click', endCall);

      // Mute button
      document.getElementById('muteBtn').addEventListener('click', toggleMute);

      // Hold button
      document.getElementById('holdBtn').addEventListener('click', toggleHold);

      // Incoming call buttons
      document.getElementById('answerCallBtn').addEventListener('click', answerIncomingCall);
      document.getElementById('declineCallBtn').addEventListener('click', declineIncomingCall);

      // Outcome buttons
      document.querySelectorAll('.outcome-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          selectOutcome(btn.dataset.outcome);
        });
      });

      // Close modal on overlay click
      document.getElementById('scriptModal').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
          closeScriptModal();
        }
      });

      // Escape key to close modal or decline incoming call
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          // If incoming call modal is open, decline the call
          if (document.getElementById('incomingCallModal').classList.contains('active')) {
            declineIncomingCall();
          } else {
            closeScriptModal();
          }
        }
        // Enter key to answer incoming call
        if (e.key === 'Enter' && document.getElementById('incomingCallModal').classList.contains('active')) {
          answerIncomingCall();
        }
      });

      // Click outside incoming call modal to decline
      document.getElementById('incomingCallModal').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
          declineIncomingCall();
        }
      });
    }

    // Check URL params for incoming call or pre-filled number
    function checkUrlParams() {
      const params = new URLSearchParams(window.location.search);

      const number = params.get('number');
      if (number) {
        document.getElementById('phoneInput').value = formatPhoneNumber(number);
        document.getElementById('phoneNumber').textContent = formatPhoneNumber(number);

        // If coming from callbacks page, auto-dial after device is ready
        const callback = params.get('callback');
        if (callback) {
          console.log('Callback mode - will auto-dial:', number);
          // Wait for Twilio device to be ready, then auto-dial
          const autoDialCheck = setInterval(() => {
            if (device && device.state === 'registered') {
              clearInterval(autoDialCheck);
              console.log('Device ready, auto-dialing callback number...');
              setTimeout(() => makeCall(), 500);
            }
          }, 500);
          // Timeout after 10 seconds
          setTimeout(() => clearInterval(autoDialCheck), 10000);
        }
      }

      const incoming = params.get('incoming');
      if (incoming) {
        // Handle incoming call redirect
        console.log('Incoming call:', incoming);
      }
    }

    // Helper functions
    function formatPhoneNumber(number) {
      if (!number) return '';
      const cleaned = number.replace(/\D/g, '');
      if (cleaned.length === 11 && cleaned[0] === '1') {
        return `+1 (${cleaned.slice(1, 4)}) ${cleaned.slice(4, 7)}-${cleaned.slice(7)}`;
      }
      if (cleaned.length === 10) {
        return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
      }
      return number;
    }

    function formatTime(timestamp) {
      if (!timestamp) return '';
      const date = new Date(timestamp);
      return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: true });
    }

    function formatDate(dateStr) {
      if (!dateStr) return '';
      const date = new Date(dateStr);
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    }

    // Initialize on load
    init();
  </script>
</body>
</html>
