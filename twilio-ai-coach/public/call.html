<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Call - DialPro</title>
  <link rel="stylesheet" href="css/styles.css">
  <!-- Supabase JS SDK (local) -->
  <script src="js/supabase.min.js"></script>
  <script src="js/supabase-config.js"></script>
  <!-- Twilio Voice SDK (v2.x) - local copy -->
  <script src="js/twilio.min.js"></script>
  <style>
    /* Call-specific styles */
    .call-page {
      display: grid;
      grid-template-columns: 280px 320px 1fr;
      gap: var(--spacing-lg);
      height: 100%;
      overflow: hidden;
    }

    /* Call Mode Toggle */
    .call-mode-toggle {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      padding: var(--spacing-sm) var(--spacing-md);
      background: var(--gray-100);
      border-radius: var(--radius-md);
      font-size: 0.75rem;
    }

    .call-mode-toggle .mode-label {
      font-weight: 500;
      color: var(--gray-700);
    }

    .call-mode-toggle .mode-status {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .call-mode-toggle .mode-status.basic {
      color: var(--gray-600);
    }

    .call-mode-toggle .mode-status.advanced {
      color: var(--primary);
    }

    .call-mode-toggle .mode-status.error {
      color: var(--danger);
    }

    .mode-indicator-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--gray-400);
    }

    .mode-indicator-dot.active {
      background: var(--success);
      animation: pulse 2s infinite;
    }

    .mode-indicator-dot.error {
      background: var(--danger);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Reconnecting overlay */
    .reconnecting-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .reconnecting-overlay.hidden {
      display: none;
    }

    .reconnecting-box {
      background: white;
      padding: var(--spacing-xl);
      border-radius: var(--radius-lg);
      text-align: center;
      max-width: 300px;
    }

    .reconnecting-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--gray-200);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto var(--spacing-md);
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Auto-Dialer Queue Panel */
    .queue-panel {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

    .queue-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--spacing-md);
      border-bottom: 1px solid var(--gray-200);
      background: var(--gray-50);
    }

    .queue-header h3 {
      font-size: 0.875rem;
      font-weight: 600;
      margin: 0;
    }

    .queue-controls {
      display: flex;
      gap: var(--spacing-xs);
    }

    .queue-stats {
      display: flex;
      gap: var(--spacing-md);
      padding: var(--spacing-sm) var(--spacing-md);
      background: var(--gray-100);
      font-size: 0.75rem;
    }

    .queue-stat {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .queue-stat-value {
      font-weight: 600;
    }

    .queue-list {
      flex: 1;
      overflow-y: auto;
      padding: var(--spacing-sm);
    }

    .queue-item {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all var(--transition-fast);
      margin-bottom: var(--spacing-xs);
    }

    .queue-item:hover {
      background: var(--gray-100);
    }

    .queue-item.active {
      background: var(--primary-light);
      border-left: 3px solid var(--primary);
    }

    .queue-item.completed {
      opacity: 0.6;
    }

    .queue-item.completed .queue-item-status {
      color: var(--success);
    }

    .queue-item.skipped .queue-item-status {
      color: var(--gray-400);
    }

    .queue-item-number {
      font-size: 0.875rem;
      font-weight: 500;
      flex: 1;
    }

    .queue-item-name {
      font-size: 0.75rem;
      color: var(--gray-500);
    }

    .queue-item-status {
      font-size: 0.75rem;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .queue-item-actions {
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity var(--transition-fast);
    }

    .queue-item:hover .queue-item-actions {
      opacity: 1;
    }

    .queue-action-btn {
      width: 24px;
      height: 24px;
      border: none;
      background: var(--gray-200);
      border-radius: var(--radius-sm);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
    }

    .queue-action-btn:hover {
      background: var(--gray-300);
    }

    .queue-empty {
      text-align: center;
      padding: var(--spacing-xl);
      color: var(--gray-500);
    }

    .queue-empty-icon {
      font-size: 2rem;
      margin-bottom: var(--spacing-sm);
    }

    .queue-add-section {
      padding: var(--spacing-md);
      border-top: 1px solid var(--gray-200);
      background: var(--gray-50);
    }

    .queue-add-input {
      display: flex;
      gap: var(--spacing-xs);
    }

    .queue-add-input input {
      flex: 1;
    }

    .auto-dial-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--spacing-sm) var(--spacing-md);
      background: linear-gradient(135deg, var(--primary-light), #e0e7ff);
      border-radius: var(--radius-md);
      margin: var(--spacing-sm);
    }

    .auto-dial-toggle label {
      font-size: 0.875rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      cursor: pointer;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
      position: absolute;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--gray-300);
      transition: 0.3s;
      border-radius: 24px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    .toggle-switch input:checked + .toggle-slider {
      background-color: var(--primary);
    }

    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(20px);
    }

    .delay-setting {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-xs) var(--spacing-md);
      font-size: 0.75rem;
      color: var(--gray-600);
    }

    .delay-setting select {
      padding: 2px 6px;
      font-size: 0.75rem;
      border-radius: var(--radius-sm);
    }

    .call-sidebar {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-lg);
      overflow-y: auto;
      padding-bottom: var(--spacing-lg);
    }

    /* Ensure dial pad card shows all content */
    .call-sidebar .card {
      overflow: visible;
      flex-shrink: 0;
    }

    .call-sidebar .card-body {
      padding-bottom: var(--spacing-xl);
    }

    .call-main {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--spacing-md);
      height: 100%;
      overflow: hidden;
    }

    /* AI Coaching Panel (Left) */
    .ai-coaching-panel {
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--gray-50);
      border-radius: var(--radius-lg);
      border: 1px solid var(--gray-200);
    }

    .ai-coaching-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-md);
      border-bottom: 1px solid var(--gray-200);
      background: var(--gray-100);
    }

    .ai-coaching-header h3 {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--gray-900);
    }

    .ai-coaching-header h3 .ai-icon {
      font-size: 1.1rem;
    }

    .knowledge-base-select {
      font-size: 0.75rem;
      padding: 4px 8px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--gray-300);
      background: white;
    }

    .ai-coaching-content {
      flex: 1;
      overflow-y: auto;
      padding: var(--spacing-md);
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
    }

    .ai-tip-card {
      padding: var(--spacing-md);
      border-radius: var(--radius-md);
      border-left: 4px solid var(--primary);
      background: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .ai-tip-card.suggestion {
      border-left-color: #f59e0b;
      background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
    }

    .ai-tip-card.objection {
      border-left-color: #ef4444;
      background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
    }

    .ai-tip-card.success {
      border-left-color: #22c55e;
      background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
    }

    .ai-tip-card.signal {
      border-left-color: #8b5cf6;
      background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%);
    }

    .ai-tip-header {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: var(--spacing-xs);
      color: var(--gray-600);
    }

    .ai-tip-card.suggestion .ai-tip-header { color: #b45309; }
    .ai-tip-card.objection .ai-tip-header { color: #dc2626; }
    .ai-tip-card.success .ai-tip-header { color: #16a34a; }
    .ai-tip-card.signal .ai-tip-header { color: #7c3aed; }

    .ai-tip-text {
      font-size: 0.875rem;
      line-height: 1.5;
      color: var(--gray-800);
    }

    .ai-tip-script {
      margin-top: var(--spacing-sm);
      padding: var(--spacing-sm);
      background: rgba(0,0,0,0.05);
      border-radius: var(--radius-sm);
      font-size: 0.8rem;
      font-style: italic;
      color: var(--gray-700);
    }

    .ai-empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--gray-500);
      text-align: center;
      padding: var(--spacing-xl);
    }

    .ai-empty-state .ai-empty-icon {
      font-size: 2.5rem;
      margin-bottom: var(--spacing-md);
    }

    /* Script Match Cards */
    .ai-tip-card.script-match {
      border-left-color: #10b981;
      background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
      padding: 0;
      overflow: hidden;
    }

    .ai-tip-card.script-match.story {
      border-left-color: #3b82f6;
      background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
    }

    .ai-tip-card.script-match.close {
      border-left-color: #8b5cf6;
      background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%);
    }

    .ai-tip-card.script-match.opener {
      border-left-color: #f59e0b;
      background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
    }

    .script-header {
      display: flex;
      flex-direction: column;
      gap: 2px;
      padding: var(--spacing-sm) var(--spacing-md);
      background: rgba(0,0,0,0.05);
      border-bottom: 1px solid rgba(0,0,0,0.1);
    }

    .script-category {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      color: #059669;
    }

    .script-match.story .script-category { color: #2563eb; }
    .script-match.close .script-category { color: #7c3aed; }
    .script-match.opener .script-category { color: #d97706; }

    .script-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--gray-800);
    }

    .script-body {
      padding: var(--spacing-md);
    }

    .script-text-box {
      position: relative;
      background: white;
      border-radius: var(--radius-md);
      padding: var(--spacing-md);
      padding-right: calc(var(--spacing-md) + 32px);
      border: 1px solid rgba(0,0,0,0.1);
    }

    .script-text {
      font-size: 0.9rem;
      line-height: 1.6;
      color: var(--gray-800);
      margin: 0;
    }

    .copy-script-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 28px;
      height: 28px;
      border: none;
      background: var(--gray-100);
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }

    .copy-script-btn:hover {
      background: var(--gray-200);
    }

    .copy-script-btn.copied {
      background: #10b981;
      color: white;
    }

    .script-story {
      margin-top: var(--spacing-sm);
    }

    .story-toggle {
      background: none;
      border: 1px dashed var(--gray-300);
      padding: var(--spacing-xs) var(--spacing-sm);
      border-radius: var(--radius-sm);
      font-size: 0.75rem;
      color: var(--gray-600);
      cursor: pointer;
      width: 100%;
      text-align: left;
    }

    .story-toggle:hover {
      background: rgba(0,0,0,0.03);
    }

    .story-content {
      margin-top: var(--spacing-sm);
      padding: var(--spacing-sm);
      background: rgba(59, 130, 246, 0.1);
      border-radius: var(--radius-sm);
      font-size: 0.8rem;
      line-height: 1.5;
      color: var(--gray-700);
      font-style: italic;
    }

    .story-content p {
      margin: 0;
    }

    .script-tips {
      margin-top: var(--spacing-sm);
      padding: var(--spacing-sm);
      background: rgba(245, 158, 11, 0.1);
      border-radius: var(--radius-sm);
      font-size: 0.75rem;
      color: var(--gray-700);
    }

    .tips-label {
      font-weight: 600;
    }

    .script-feedback {
      display: flex;
      gap: var(--spacing-xs);
      padding: var(--spacing-sm) var(--spacing-md);
      background: rgba(0,0,0,0.03);
      border-top: 1px solid rgba(0,0,0,0.05);
    }

    .feedback-btn {
      flex: 1;
      padding: var(--spacing-xs) var(--spacing-sm);
      border: 1px solid var(--gray-300);
      background: white;
      border-radius: var(--radius-sm);
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .feedback-btn:hover {
      background: var(--gray-100);
    }

    .feedback-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .feedback-btn.used.active {
      background: #10b981;
      border-color: #10b981;
    }

    .feedback-btn.helpful.active {
      background: #22c55e;
      border-color: #22c55e;
    }

    .feedback-btn.not-helpful.active {
      background: #ef4444;
      border-color: #ef4444;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Transcript Panel (Right) */
    .transcript-panel {
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--gray-50);
      border-radius: var(--radius-lg);
      border: 1px solid var(--gray-200);
    }

    .transcript-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-md);
      border-bottom: 1px solid var(--gray-200);
      background: var(--gray-100);
    }

    .transcript-header h3 {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--gray-900);
    }

    .transcript-search {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      padding: var(--spacing-xs) var(--spacing-md);
      border-bottom: 1px solid var(--gray-200);
    }

    .transcript-search input {
      flex: 1;
      border: none;
      background: white;
      padding: var(--spacing-xs) var(--spacing-sm);
      border-radius: var(--radius-sm);
      font-size: 0.8rem;
    }

    .transcript-search input:focus {
      outline: 2px solid var(--primary);
    }

    .transcript-scroll {
      flex: 1;
      overflow-y: auto;
      padding: var(--spacing-md);
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
    }

    .transcript-message {
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--radius-md);
      font-size: 0.875rem;
      line-height: 1.5;
      position: relative;
    }

    .transcript-message.rep {
      background: #e0f2fe;
      border-left: 3px solid #3b82f6;
      margin-right: 20%;
    }

    .transcript-message.customer {
      background: #f3e8ff;
      border-left: 3px solid #8b5cf6;
      margin-right: 20%;
    }

    .transcript-message .speaker-label {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 2px;
    }

    .transcript-message.rep .speaker-label {
      color: #2563eb;
    }

    .transcript-message.customer .speaker-label {
      color: #7c3aed;
    }

    .transcript-time {
      font-size: 0.65rem;
      color: var(--gray-500);
      margin-top: 4px;
    }

    .search-highlight {
      background: #fef08a;
      padding: 0 2px;
      border-radius: 2px;
    }

    .speaking-indicator {
      background: var(--gray-100);
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--radius-md);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      font-size: 0.875rem;
      color: var(--gray-600);
    }

    .speaking-indicator .dots {
      display: flex;
      gap: 3px;
    }

    .speaking-indicator .dot {
      width: 6px;
      height: 6px;
      background: var(--primary);
      border-radius: 50%;
      animation: bounce 1.4s infinite ease-in-out both;
    }

    .speaking-indicator .dot:nth-child(1) { animation-delay: -0.32s; }
    .speaking-indicator .dot:nth-child(2) { animation-delay: -0.16s; }

    @keyframes bounce {
      0%, 80%, 100% { transform: scale(0); }
      40% { transform: scale(1); }
    }

    .outcome-panel {
      background: var(--gray-50);
      border-top: 1px solid var(--gray-200);
      padding: var(--spacing-lg);
    }

    .outcome-buttons {
      display: flex;
      gap: var(--spacing-sm);
      flex-wrap: wrap;
      margin-bottom: var(--spacing-md);
    }

    .outcome-btn {
      flex: 1;
      min-width: 120px;
      padding: var(--spacing-md);
      border: 2px solid var(--gray-200);
      border-radius: var(--radius-md);
      background: white;
      cursor: pointer;
      text-align: center;
      transition: all var(--transition-fast);
    }

    .outcome-btn:hover {
      border-color: var(--primary);
    }

    .outcome-btn.selected {
      border-color: var(--primary);
      background: var(--primary-light);
    }

    .outcome-btn .icon {
      font-size: 1.5rem;
      margin-bottom: var(--spacing-xs);
    }

    .outcome-btn .label {
      font-size: 0.75rem;
      font-weight: 500;
    }

    .customer-info-card {
      background: var(--gray-50);
    }

    .scripts-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--spacing-xs);
    }

    @media (max-width: 1200px) {
      .call-page {
        grid-template-columns: 280px 1fr;
      }

      .call-sidebar {
        display: none;
      }
    }

    @media (max-width: 900px) {
      .call-page {
        grid-template-columns: 1fr;
      }

      .queue-panel {
        display: none;
      }
    }

    /* Queue panel collapsed state */
    .queue-panel.collapsed {
      width: 48px;
      min-width: 48px;
    }

    .queue-panel.collapsed .queue-header h3,
    .queue-panel.collapsed .queue-stats,
    .queue-panel.collapsed .queue-list,
    .queue-panel.collapsed .queue-add-section,
    .queue-panel.collapsed .auto-dial-toggle,
    .queue-panel.collapsed .delay-setting {
      display: none;
    }

    /* =====================================================
       TIME TRACKING PANEL STYLES
       ===================================================== */
    .time-tracking-panel {
      background: white;
      border-radius: var(--radius-lg);
      border: 1px solid var(--gray-200);
      margin-bottom: var(--spacing-md);
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .time-tracking-panel.collapsed .time-tracking-body {
      display: none;
    }

    .time-tracking-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--spacing-sm) var(--spacing-md);
      background: linear-gradient(135deg, var(--primary-light), #e0e7ff);
      border-bottom: 1px solid var(--gray-200);
      cursor: pointer;
    }

    .time-tracking-header:hover {
      background: linear-gradient(135deg, #ddd6fe, #c7d2fe);
    }

    .time-tracking-title {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--gray-800);
    }

    .time-tracking-title .session-status {
      font-size: 0.75rem;
      padding: 2px 8px;
      border-radius: var(--radius-full);
      font-weight: 500;
    }

    .time-tracking-title .session-status.active {
      background: var(--success-light);
      color: var(--success);
    }

    .time-tracking-title .session-status.paused {
      background: var(--warning-light);
      color: #b45309;
    }

    .time-tracking-title .session-status.inactive {
      background: var(--gray-100);
      color: var(--gray-500);
    }

    .time-tracking-collapse-btn {
      background: none;
      border: none;
      font-size: 0.75rem;
      color: var(--gray-500);
      cursor: pointer;
      padding: 4px;
      transition: transform 0.2s;
    }

    .time-tracking-panel.collapsed .time-tracking-collapse-btn {
      transform: rotate(180deg);
    }

    .time-tracking-body {
      padding: var(--spacing-md);
    }

    /* Main Timer Display */
    .session-main-timer {
      text-align: center;
      padding: var(--spacing-md) 0;
      border-bottom: 1px solid var(--gray-100);
      margin-bottom: var(--spacing-md);
    }

    .session-main-timer .timer-label {
      font-size: 0.75rem;
      color: var(--gray-500);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }

    .session-main-timer .timer-value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--gray-900);
      font-variant-numeric: tabular-nums;
      font-family: ui-monospace, monospace;
    }

    .session-main-timer .timer-value.on-call {
      color: var(--success);
    }

    /* Session Stats Grid */
    .session-stats-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-md);
    }

    .session-stat-item {
      text-align: center;
      padding: var(--spacing-sm);
      background: var(--gray-50);
      border-radius: var(--radius-md);
    }

    .session-stat-item .stat-value {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--gray-900);
      font-variant-numeric: tabular-nums;
    }

    .session-stat-item .stat-value.talk-time {
      color: var(--success);
    }

    .session-stat-item .stat-value.idle-time {
      color: var(--warning);
    }

    .session-stat-item .stat-value.break-time {
      color: var(--gray-500);
    }

    .session-stat-item .stat-label {
      font-size: 0.625rem;
      color: var(--gray-500);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Productivity Bar */
    .productivity-bar-container {
      margin-bottom: var(--spacing-md);
    }

    .productivity-bar-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: var(--gray-500);
      margin-bottom: 4px;
    }

    .productivity-bar {
      height: 8px;
      background: var(--gray-200);
      border-radius: var(--radius-full);
      overflow: hidden;
      display: flex;
    }

    .productivity-segment {
      height: 100%;
      transition: width 0.3s ease;
    }

    .productivity-segment.talk {
      background: var(--success);
    }

    .productivity-segment.idle {
      background: var(--warning);
    }

    .productivity-segment.break {
      background: var(--gray-400);
    }

    /* Call Metrics Row */
    .call-metrics-row {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--spacing-sm);
      padding-top: var(--spacing-sm);
      border-top: 1px solid var(--gray-100);
      margin-bottom: var(--spacing-md);
    }

    .call-metric {
      text-align: center;
    }

    .call-metric .metric-value {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--gray-900);
    }

    .call-metric .metric-label {
      font-size: 0.625rem;
      color: var(--gray-500);
      text-transform: uppercase;
    }

    /* Session Controls */
    .session-controls {
      display: flex;
      gap: var(--spacing-sm);
    }

    .session-controls .btn {
      flex: 1;
      padding: var(--spacing-sm);
      font-size: 0.75rem;
    }

    .session-controls .btn-pause {
      background: var(--warning-light);
      color: #b45309;
      border: 1px solid #fcd34d;
    }

    .session-controls .btn-pause:hover {
      background: #fde68a;
    }

    .session-controls .btn-end {
      background: var(--danger-light);
      color: var(--danger);
      border: 1px solid #fecaca;
    }

    .session-controls .btn-end:hover {
      background: #fee2e2;
    }

    /* Break Warning Modal */
    .break-warning-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .break-warning-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .break-warning-modal {
      background: white;
      border-radius: var(--radius-xl);
      padding: var(--spacing-xl);
      text-align: center;
      max-width: 320px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    .break-warning-icon {
      font-size: 3rem;
      margin-bottom: var(--spacing-md);
    }

    .break-warning-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--gray-900);
      margin-bottom: var(--spacing-sm);
    }

    .break-warning-text {
      font-size: 0.875rem;
      color: var(--gray-500);
      margin-bottom: var(--spacing-lg);
    }

    .break-warning-actions {
      display: flex;
      gap: var(--spacing-sm);
    }

    .break-warning-actions .btn {
      flex: 1;
    }

    /* Incoming Call Modal */
    .incoming-call-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .incoming-call-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .incoming-call-modal {
      background: white;
      border-radius: var(--radius-xl);
      padding: var(--spacing-xl);
      text-align: center;
      max-width: 320px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .incoming-call-overlay.active .incoming-call-modal {
      transform: scale(1);
    }

    .incoming-call-icon {
      width: 80px;
      height: 80px;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto var(--spacing-lg);
      animation: ring-pulse 1.5s ease-in-out infinite;
    }

    .incoming-call-icon svg {
      width: 40px;
      height: 40px;
      color: white;
      animation: ring-shake 0.5s ease-in-out infinite;
    }

    @keyframes ring-pulse {
      0%, 100% {
        box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4);
      }
      50% {
        box-shadow: 0 0 0 20px rgba(16, 185, 129, 0);
      }
    }

    @keyframes ring-shake {
      0%, 100% { transform: rotate(-10deg); }
      50% { transform: rotate(10deg); }
    }

    .incoming-call-label {
      font-size: 0.875rem;
      color: var(--gray-500);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: var(--spacing-xs);
    }

    .incoming-call-number {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--gray-900);
      margin-bottom: var(--spacing-lg);
    }

    .incoming-call-actions {
      display: flex;
      gap: var(--spacing-md);
      justify-content: center;
    }

    .incoming-call-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .incoming-call-btn svg {
      width: 28px;
      height: 28px;
      color: white;
    }

    .incoming-call-btn.answer {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    }

    .incoming-call-btn.answer:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4);
    }

    .incoming-call-btn.decline {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    }

    .incoming-call-btn.decline:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 20px rgba(239, 68, 68, 0.4);
    }

    .incoming-call-btn-label {
      font-size: 0.75rem;
      color: var(--gray-600);
      margin-top: var(--spacing-xs);
    }

    .incoming-call-btn-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
  </style>
</head>
<body>
  <div class="app-layout">
    <!-- Sidebar Overlay (mobile) -->
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebar()"></div>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <a href="dashboard.html" class="sidebar-logo">
          <div class="sidebar-logo-icon">AI</div>
          <span class="sidebar-logo-text">DialPro</span>
        </a>
        <button class="sidebar-toggle" onclick="toggleSidebar()" title="Toggle sidebar">
          <span>‚óÄ</span>
        </button>
      </div>

      <nav class="sidebar-nav">
        <!-- Main Section -->
        <div class="sidebar-nav-section">
          <a href="dashboard.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon">üìä</span>
            <span class="sidebar-nav-label">Dashboard</span>
          </a>
          <a href="newsfeed.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon">üì∞</span>
            <span class="sidebar-nav-label">Newsfeed</span>
          </a>
          <a href="activity.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon">‚ö°</span>
            <span class="sidebar-nav-label">Activity</span>
          </a>
        </div>

        <!-- Contacts Section -->
        <div class="sidebar-nav-section">
          <div class="sidebar-nav-section-title">Contacts</div>
          <a href="contacts.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon">üë•</span>
            <span class="sidebar-nav-label">All Contacts</span>
          </a>
          <a href="contacts-import.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon">üì•</span>
            <span class="sidebar-nav-label">Import</span>
          </a>
        </div>

        <!-- Communication Section -->
        <div class="sidebar-nav-section">
          <div class="sidebar-nav-section-title">Communication</div>
          <a href="sms.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon">üí¨</span>
            <span class="sidebar-nav-label">SMS</span>
            <span class="sidebar-nav-badge">3</span>
          </a>
          <a href="call.html" class="sidebar-nav-item active">
            <span class="sidebar-nav-icon">üìû</span>
            <span class="sidebar-nav-label">Make Call</span>
          </a>
          <a href="history.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon">üìã</span>
            <span class="sidebar-nav-label">History</span>
          </a>
          <a href="callbacks.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon">üîî</span>
            <span class="sidebar-nav-label">Callbacks</span>
          </a>
        </div>

        <!-- AI Agent Section -->
        <div class="sidebar-nav-section">
          <div class="sidebar-nav-section-title">AI Agent</div>
          <a href="agent-queue.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon">üìã</span>
            <span class="sidebar-nav-label">Call Queue</span>
            <span class="sidebar-nav-badge" id="queueBadge">0</span>
          </a>
          <a href="agent-monitor.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon">ü§ñ</span>
            <span class="sidebar-nav-label">Live Monitor</span>
          </a>
        </div>

        <!-- Sales Section -->
        <div class="sidebar-nav-section">
          <div class="sidebar-nav-section-title">Sales</div>
          <a href="pipeline.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon">üìà</span>
            <span class="sidebar-nav-label">Pipeline</span>
          </a>
        </div>

        <!-- Team Section -->
        <div class="sidebar-nav-section">
          <div class="sidebar-nav-section-title">Team</div>
          <a href="supervisor.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon">üëÅÔ∏è</span>
            <span class="sidebar-nav-label">Supervisor</span>
          </a>
          <a href="supervisor-mockup.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon">üìä</span>
            <span class="sidebar-nav-label">Team Overview</span>
          </a>
        </div>

        <!-- Settings -->
        <div class="sidebar-nav-section" style="margin-top: auto;">
          <a href="settings.html" class="sidebar-nav-item">
            <span class="sidebar-nav-icon">‚öôÔ∏è</span>
            <span class="sidebar-nav-label">Settings</span>
          </a>
        </div>
      </nav>

      <!-- User Section -->
      <div class="sidebar-user">
        <div class="sidebar-user-avatar" id="userAvatar">SR</div>
        <div class="sidebar-user-info">
          <div class="sidebar-user-name">Sales Rep</div>
          <div class="sidebar-user-status" id="userStatus">
            <span class="status-dot"></span>
            <span id="connectionText">Connecting...</span>
          </div>
        </div>
      </div>
    </aside>

    <!-- Main Content Wrapper -->
    <div class="main-wrapper">
      <!-- Top Header -->
      <header class="top-header">
        <div class="top-header-left">
          <button class="mobile-menu-btn" onclick="openSidebar()">‚ò∞</button>
          <h1 class="page-title">Call</h1>
        </div>
        <div class="top-header-right">
          <!-- Call Mode Selector -->
          <div class="call-mode-toggle desktop-only">
            <span class="mode-label">Mode:</span>
            <select class="input" id="callModeSelect" style="width: 150px; font-size: 0.75rem;">
              <option value="basic">Basic (Post-call)</option>
              <option value="advanced">Deepgram (Live)</option>
              <option value="twilio-realtime">Twilio (Live)</option>
            </select>
          </div>
          <select class="input desktop-only" id="audioDevice" style="width: 180px; font-size: 0.75rem;">
            <option value="">Loading devices...</option>
          </select>
          <div class="connection-status disconnected" id="connectionStatus">
            <span class="connection-dot"></span>
            <span class="desktop-only">Disconnected</span>
          </div>
        </div>
      </header>

      <!-- Main Content Area -->
      <main class="main-content-area" style="padding: var(--spacing-md);">
        <div class="call-page">
        <!-- Auto-Dialer Queue Panel -->
        <div class="card queue-panel" id="queuePanel">
          <div class="queue-header">
            <h3>Call Queue</h3>
            <div class="queue-controls">
              <button class="btn btn-sm btn-secondary" onclick="clearQueue()" title="Clear Queue">Clear</button>
            </div>
          </div>

          <!-- Auto-Dial Toggle -->
          <div class="auto-dial-toggle">
            <span id="autoDialLabel">Auto-Dial</span>
            <div style="display: flex; align-items: center; gap: 8px;">
              <button class="btn btn-sm" id="pauseBtn" onclick="togglePause()" style="display: none; padding: 4px 8px; font-size: 0.75rem;">‚è∏Ô∏è Pause</button>
              <label class="toggle-switch" for="autoDialToggle">
                <input type="checkbox" id="autoDialToggle" onchange="handleAutoDialToggle(this.checked)">
                <span class="toggle-slider"></span>
              </label>
            </div>
          </div>

          <div class="delay-setting">
            <span>Delay between calls:</span>
            <select id="dialDelay">
              <option value="0">None</option>
              <option value="3" selected>3 sec</option>
              <option value="5">5 sec</option>
              <option value="10">10 sec</option>
            </select>
          </div>

          <!-- Queue Stats -->
          <div class="queue-stats">
            <div class="queue-stat">
              <span>Total:</span>
              <span class="queue-stat-value" id="queueTotal">0</span>
            </div>
            <div class="queue-stat">
              <span>Done:</span>
              <span class="queue-stat-value" id="queueCompleted">0</span>
            </div>
            <div class="queue-stat">
              <span>Left:</span>
              <span class="queue-stat-value" id="queueRemaining">0</span>
            </div>
          </div>

          <!-- Queue List -->
          <div class="queue-list" id="queueList">
            <div class="queue-empty">
              <div class="queue-empty-icon">üìã</div>
              <div>No numbers in queue</div>
              <div style="font-size: 0.75rem; margin-top: 4px;">Add numbers below to get started</div>
            </div>
          </div>

          <!-- Add to Queue Section -->
          <div class="queue-add-section">
            <div class="queue-add-input">
              <input type="tel" class="input input-sm" id="queuePhoneInput" placeholder="Add number...">
              <button class="btn btn-sm btn-primary" onclick="addToQueue()">+</button>
            </div>
            <div style="margin-top: var(--spacing-sm);">
              <button class="btn btn-sm btn-secondary" style="width: 100%;" onclick="showBulkAddModal()">
                Bulk Add Numbers
              </button>
            </div>
          </div>

          <!-- Time Tracking Panel -->
          <div class="time-tracking-panel" id="timeTrackingPanel">
            <div class="time-tracking-header" onclick="toggleTimeTrackingPanel()">
              <div class="time-tracking-title">
                <span>Session Stats</span>
                <span class="session-status inactive" id="sessionStatusBadge">Not Started</span>
              </div>
              <button class="time-tracking-collapse-btn" title="Collapse">&#9660;</button>
            </div>
            <div class="time-tracking-body">
              <!-- Main Working Time Timer -->
              <div class="session-main-timer">
                <div class="timer-label">Working Time</div>
                <div class="timer-value" id="sessionWorkingTime">0:00:00</div>
              </div>

              <!-- Time Stats Grid (Talk, Idle, Break) -->
              <div class="session-stats-grid">
                <div class="session-stat-item">
                  <div class="stat-value talk-time" id="sessionTalkTime">0:00</div>
                  <div class="stat-label">Talk Time</div>
                </div>
                <div class="session-stat-item">
                  <div class="stat-value idle-time" id="sessionIdleTime">0:00</div>
                  <div class="stat-label">Idle Time</div>
                </div>
                <div class="session-stat-item">
                  <div class="stat-value break-time" id="sessionBreakTime">0:00</div>
                  <div class="stat-label">Break Time</div>
                </div>
              </div>

              <!-- Productivity Bar -->
              <div class="productivity-bar-container">
                <div class="productivity-bar-label">
                  <span>Productivity</span>
                  <span id="productivityPercent">0%</span>
                </div>
                <div class="productivity-bar">
                  <div class="productivity-segment talk" id="productivityTalk" style="width: 0%"></div>
                  <div class="productivity-segment idle" id="productivityIdle" style="width: 0%"></div>
                  <div class="productivity-segment break" id="productivityBreak" style="width: 0%"></div>
                </div>
              </div>

              <!-- Call Metrics -->
              <div class="call-metrics-row">
                <div class="call-metric">
                  <div class="metric-value" id="sessionTotalCalls">0</div>
                  <div class="metric-label">Calls Made</div>
                </div>
                <div class="call-metric">
                  <div class="metric-value" id="sessionConnectedCalls">0</div>
                  <div class="metric-label">Connected</div>
                </div>
                <div class="call-metric">
                  <div class="metric-value" id="sessionCallsPerHour">0.0</div>
                  <div class="metric-label">Calls/Hour</div>
                </div>
              </div>

              <!-- Session Controls -->
              <div class="session-controls">
                <button class="btn btn-pause" id="sessionPauseBtn" onclick="toggleSessionPause()">
                  <span id="pauseBtnIcon">&#9616;&#9616;</span> <span id="pauseBtnText">Break</span>
                </button>
                <button class="btn btn-end" id="sessionEndBtn" onclick="endSession()">
                  End Session
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Center Sidebar (Dial Pad & Controls) -->
        <div class="call-sidebar">
          <!-- Call Status Card -->
          <div class="card">
            <div class="card-body">
              <div class="call-status-display">
                <div id="phoneNumber" style="font-size: 1.25rem; font-weight: 600; color: var(--gray-700); margin-bottom: var(--spacing-md);">
                  Enter number to call
                </div>
                <div class="call-timer" id="callTimer">0:00</div>
                <div class="call-state" id="callState">Ready</div>
              </div>

              <!-- Dial Pad (shown when not in call) -->
              <div id="dialPadContainer">
                <input type="tel" class="input input-lg mt-4" id="phoneInput" placeholder="+1 (___) ___-____">
                <div class="dial-pad mt-3">
                  <button class="dial-btn" data-digit="1">1</button>
                  <button class="dial-btn" data-digit="2">2</button>
                  <button class="dial-btn" data-digit="3">3</button>
                  <button class="dial-btn" data-digit="4">4</button>
                  <button class="dial-btn" data-digit="5">5</button>
                  <button class="dial-btn" data-digit="6">6</button>
                  <button class="dial-btn" data-digit="7">7</button>
                  <button class="dial-btn" data-digit="8">8</button>
                  <button class="dial-btn" data-digit="9">9</button>
                  <button class="dial-btn" data-digit="*">*</button>
                  <button class="dial-btn" data-digit="0">0</button>
                  <button class="dial-btn" data-digit="#">#</button>
                </div>
              </div>

              <!-- Call Controls -->
              <div class="call-controls mt-4">
                <button class="call-control-btn mute hidden" id="muteBtn" title="Mute">
                  üîá
                </button>
                <button class="call-control-btn call" id="callBtn" title="Call">
                  üìû
                </button>
                <button class="call-control-btn end-call hidden" id="endCallBtn" title="End Call">
                  üìµ
                </button>
                <button class="call-control-btn mute hidden" id="holdBtn" title="Hold">
                  ‚è∏Ô∏è
                </button>
              </div>
            </div>
          </div>

          <!-- Lead Source Card -->
          <div class="lead-source-card" id="leadSourceCard">
            <div class="lead-source-header">
              <h3 class="lead-source-title">
                <span>üìç</span> Lead Source
              </h3>
              <button class="btn btn-sm btn-secondary" id="toggleLeadSourceBtn" onclick="toggleLeadSourceEdit()">Edit</button>
            </div>
            <div class="lead-source-body">
              <!-- Compact Display (default view) -->
              <div id="leadSourceDisplay">
                <div class="lead-source-display" id="leadSourceSummary">
                  <span class="source-icon">‚ùì</span>
                  <div class="source-info">
                    <div class="source-name">Not set</div>
                    <div class="source-category">Click edit to set lead source</div>
                  </div>
                </div>
              </div>

              <!-- Edit Mode (hidden by default) -->
              <div id="leadSourceEdit" class="hidden">
                <!-- Source Selection Grid -->
                <div class="lead-source-grid">
                  <button class="lead-source-btn facebook" data-source="facebook" onclick="selectLeadSource('facebook')">
                    <span class="source-icon">üìò</span>
                    <span class="source-label">Facebook</span>
                  </button>
                  <button class="lead-source-btn google" data-source="google" onclick="selectLeadSource('google')">
                    <span class="source-icon">üîç</span>
                    <span class="source-label">Google</span>
                  </button>
                  <button class="lead-source-btn instagram" data-source="instagram" onclick="selectLeadSource('instagram')">
                    <span class="source-icon">üì∑</span>
                    <span class="source-label">Instagram</span>
                  </button>
                  <button class="lead-source-btn tiktok" data-source="tiktok" onclick="selectLeadSource('tiktok')">
                    <span class="source-icon">üéµ</span>
                    <span class="source-label">TikTok</span>
                  </button>
                  <button class="lead-source-btn linkedin" data-source="linkedin" onclick="selectLeadSource('linkedin')">
                    <span class="source-icon">üíº</span>
                    <span class="source-label">LinkedIn</span>
                  </button>
                  <button class="lead-source-btn referral" data-source="referral" onclick="selectLeadSource('referral')">
                    <span class="source-icon">ü§ù</span>
                    <span class="source-label">Referral</span>
                  </button>
                  <button class="lead-source-btn website" data-source="website" onclick="selectLeadSource('website')">
                    <span class="source-icon">üåê</span>
                    <span class="source-label">Website</span>
                  </button>
                  <button class="lead-source-btn cold-call" data-source="cold-call" onclick="selectLeadSource('cold-call')">
                    <span class="source-icon">üìû</span>
                    <span class="source-label">Cold Call</span>
                  </button>
                  <button class="lead-source-btn other" data-source="other" onclick="selectLeadSource('other')">
                    <span class="source-icon">üìã</span>
                    <span class="source-label">Other</span>
                  </button>
                </div>

                <!-- Custom Source Input (shown when "Other" selected) -->
                <div class="lead-custom-source hidden" id="customSourceInput">
                  <input type="text" class="input" id="customSourceName" placeholder="Enter custom source...">
                </div>

                <!-- Category Section -->
                <div class="lead-category-section" id="leadCategorySection">
                  <div class="lead-category-label">Category</div>
                  <div class="lead-category-chips" id="leadCategoryChips">
                    <button class="lead-category-chip" data-category="ad" onclick="selectLeadCategory('ad')">Paid Ad</button>
                    <button class="lead-category-chip" data-category="organic" onclick="selectLeadCategory('organic')">Organic</button>
                    <button class="lead-category-chip" data-category="direct" onclick="selectLeadCategory('direct')">Direct</button>
                    <button class="lead-category-chip" data-category="retargeting" onclick="selectLeadCategory('retargeting')">Retargeting</button>
                    <button class="lead-category-chip" data-category="email" onclick="selectLeadCategory('email')">Email</button>
                    <button class="lead-category-chip" data-category="sms" onclick="selectLeadCategory('sms')">SMS</button>
                  </div>
                </div>

                <!-- Campaign/Ad Details -->
                <div class="lead-campaign-section" id="leadCampaignSection">
                  <div class="lead-campaign-row">
                    <div class="form-group">
                      <label class="form-label">Campaign Name</label>
                      <input type="text" class="input" id="leadCampaignName" placeholder="e.g., Summer 2025">
                    </div>
                    <div class="form-group">
                      <label class="form-label">Ad Set / Ad Name</label>
                      <input type="text" class="input" id="leadAdName" placeholder="e.g., Video Ad 1">
                    </div>
                  </div>
                </div>

                <!-- Save Button -->
                <div class="mt-3 flex gap-2 justify-end">
                  <button class="btn btn-secondary" onclick="cancelLeadSourceEdit()">Cancel</button>
                  <button class="btn btn-primary" onclick="saveLeadSource()">Save</button>
                </div>
              </div>
            </div>
          </div>

          <!-- Customer History Card -->
          <div class="card customer-info-card" id="customerInfoCard" style="display: none;">
            <div class="card-header">
              <h3 class="card-title">Customer History</h3>
            </div>
            <div class="card-body">
              <div id="customerHistory">
                <div class="text-sm text-muted">No previous history</div>
              </div>
              <div class="mt-3">
                <label class="form-label">Notes</label>
                <textarea class="input" id="callNotes" rows="3" placeholder="Add notes about this call..."></textarea>
              </div>
            </div>
          </div>

          <!-- Quick Scripts Card -->
          <div class="card" id="scriptsCard" style="display: none;">
            <div class="card-header">
              <h3 class="card-title">Quick Scripts</h3>
            </div>
            <div class="card-body">
              <div class="scripts-grid">
                <button class="btn btn-secondary btn-sm" onclick="showScript('intro')">Intro</button>
                <button class="btn btn-secondary btn-sm" onclick="showScript('pricing')">Pricing</button>
                <button class="btn btn-secondary btn-sm" onclick="showScript('objections')">Objections</button>
                <button class="btn btn-secondary btn-sm" onclick="showScript('close')">Close</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Main Panel - AI Coaching + Transcript (50/50 split) -->
        <div class="call-main">
          <!-- AI Coaching Panel (Left - 50%) -->
          <div class="ai-coaching-panel" id="aiCoachingPanel">
            <div class="ai-coaching-header">
              <h3><span class="ai-icon">ü§ñ</span> AI Coach</h3>
              <select class="knowledge-base-select" id="knowledgeBaseSelect">
                <option value="general">General Sales</option>
                <option value="cleaning">Cleaning Services</option>
                <option value="solar">Solar Sales</option>
                <option value="insurance">Insurance</option>
              </select>
            </div>
            <div class="ai-coaching-content" id="aiCoachingContent">
              <div class="ai-empty-state" id="aiEmptyState">
                <div class="ai-empty-icon">üí°</div>
                <div class="ai-empty-title">AI Coach Ready</div>
                <div class="ai-empty-text">Start a call to receive real-time coaching tips and objection handling suggestions.</div>
              </div>
            </div>
          </div>

          <!-- Transcript Panel (Right - 50%) -->
          <div class="transcript-panel">
            <div class="transcript-header">
              <h3>Live Transcript</h3>
              <div id="transcriptStatus" class="badge badge-info">Waiting for call</div>
            </div>
            <div class="transcript-search">
              <span>üîç</span>
              <input type="text" id="transcriptSearchInput" placeholder="Search transcript..." onkeyup="searchTranscript(this.value)">
            </div>
            <div class="transcript-scroll" id="transcriptContainer">
              <div class="empty-state">
                <div class="empty-state-icon">üí¨</div>
                <div class="empty-state-title">No transcript yet</div>
                <div class="empty-state-text">Start a call to see real-time transcription</div>
              </div>
            </div>

            <!-- Speaking Indicator -->
            <div class="speaking-indicator hidden" id="speakingIndicator">
              <div class="dots">
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
              </div>
              <span id="speakingText">Customer is speaking...</span>
            </div>
          </div>

          <!-- Call Outcome Panel (shown after call ends) -->
          <div class="outcome-panel hidden" id="outcomePanel">
            <h4 class="mb-3">How did this call go?</h4>
            <div class="outcome-buttons">
              <button class="outcome-btn" data-outcome="booked">
                <div class="icon">‚úÖ</div>
                <div class="label">Booked</div>
              </button>
              <button class="outcome-btn" data-outcome="callback">
                <div class="icon">üìÖ</div>
                <div class="label">Callback</div>
              </button>
              <button class="outcome-btn" data-outcome="not_interested">
                <div class="icon">‚ùå</div>
                <div class="label">Not Interested</div>
              </button>
              <button class="outcome-btn" data-outcome="no_answer">
                <div class="icon">üìµ</div>
                <div class="label">No Answer</div>
              </button>
            </div>

            <!-- Callback Scheduling -->
            <div class="hidden" id="callbackScheduler">
              <div class="grid-2 mb-3">
                <div class="form-group">
                  <label class="form-label">Date</label>
                  <input type="date" class="input" id="callbackDate">
                </div>
                <div class="form-group">
                  <label class="form-label">Time</label>
                  <input type="time" class="input" id="callbackTime">
                </div>
              </div>
              <div class="form-group">
                <label class="form-label">Reason</label>
                <input type="text" class="input" id="callbackReason" placeholder="e.g., Follow up on quote">
              </div>
            </div>

            <div class="form-group">
              <label class="form-label">Notes</label>
              <textarea class="input" id="outcomeNotes" rows="2" placeholder="Add notes about this call..."></textarea>
            </div>

            <div class="flex gap-2 justify-end">
              <button class="btn btn-secondary" onclick="skipOutcome()">Skip</button>
              <button class="btn btn-primary" onclick="saveOutcome()">Save & Close</button>
            </div>
          </div>
        </div>
      </div>
      </main>
    </div>

    <!-- Mobile Bottom Nav -->
    <nav class="mobile-bottom-nav">
      <div class="mobile-nav-items">
        <a href="dashboard.html" class="mobile-nav-item">
          <span class="mobile-nav-icon">üìä</span>
          <span>Dashboard</span>
        </a>
        <a href="newsfeed.html" class="mobile-nav-item">
          <span class="mobile-nav-icon">üì∞</span>
          <span>Feed</span>
        </a>
        <a href="history.html" class="mobile-nav-item">
          <span class="mobile-nav-icon">üìã</span>
          <span>History</span>
        </a>
        <a href="callbacks.html" class="mobile-nav-item">
          <span class="mobile-nav-icon">üîî</span>
          <span>Callbacks</span>
        </a>
      </div>
    </nav>
  </div>

  <!-- Mobile Call Screen -->
  <div class="mobile-call-screen" id="mobileCallScreen">
    <div class="mobile-call-header">
      <button class="mobile-call-back" onclick="minimizeMobileCall()">‚óÄ</button>
      <span class="mobile-call-status" id="mobileCallStatus">Calling...</span>
      <button class="mobile-call-more">‚ãØ</button>
    </div>

    <div class="mobile-call-contact">
      <div class="mobile-call-avatar" id="mobileCallAvatar">?</div>
      <div class="mobile-call-name" id="mobileCallName">Unknown</div>
      <div class="mobile-call-number" id="mobileCallNumber"></div>
      <div class="mobile-call-timer" id="mobileCallTimer">0:00</div>
    </div>

    <!-- AI Coach -->
    <div class="mobile-ai-coach" id="mobileAiCoach" style="display: none;">
      <div class="mobile-ai-coach-header">AI Coach</div>
      <div class="mobile-ai-coach-text" id="mobileAiCoachText">Suggestion will appear here...</div>
    </div>

    <div class="mobile-call-actions">
      <div class="mobile-call-actions-grid">
        <button class="mobile-action-btn" onclick="toggleMobileMute(this)">
          <div class="icon-circle">üîá</div>
          <span class="label">Mute</span>
        </button>
        <button class="mobile-action-btn" onclick="toggleMobileHold(this)">
          <div class="icon-circle">‚è∏Ô∏è</div>
          <span class="label">Hold</span>
        </button>
        <button class="mobile-action-btn">
          <div class="icon-circle">üîä</div>
          <span class="label">Speaker</span>
        </button>
        <button class="mobile-action-btn" onclick="showMobileKeypad()">
          <div class="icon-circle">‚å®Ô∏è</div>
          <span class="label">Keypad</span>
        </button>
        <button class="mobile-action-btn">
          <div class="icon-circle">üí¨</div>
          <span class="label">SMS</span>
        </button>
        <button class="mobile-action-btn">
          <div class="icon-circle">üìù</div>
          <span class="label">Notes</span>
        </button>
      </div>
      <div class="mobile-call-main-actions">
        <button class="mobile-end-call" onclick="endMobileCall()">üìµ</button>
      </div>
    </div>
  </div>

  <!-- Bulk Add Modal -->
  <div class="modal-overlay" id="bulkAddModal">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">Bulk Add Numbers</h3>
        <button class="modal-close" onclick="closeBulkAddModal()">&times;</button>
      </div>
      <div class="modal-body">
        <p style="font-size: 0.875rem; color: var(--gray-600); margin-bottom: var(--spacing-md);">
          Enter phone numbers, one per line. You can also paste from a spreadsheet.
        </p>
        <textarea
          class="input"
          id="bulkNumbersInput"
          rows="10"
          placeholder="(555) 123-4567&#10;555-987-6543&#10;+1 555 456 7890"
          style="font-family: monospace;"
        ></textarea>
        <div style="margin-top: var(--spacing-md); display: flex; gap: var(--spacing-sm); justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeBulkAddModal()">Cancel</button>
          <button class="btn btn-primary" onclick="processBulkAdd()">Add to Queue</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Script Modal -->
  <div class="modal-overlay" id="scriptModal">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title" id="scriptTitle">Script</h3>
        <button class="modal-close" onclick="closeScriptModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div id="scriptContent"></div>
      </div>
    </div>
  </div>

  <!-- Incoming Call Modal -->
  <div class="incoming-call-overlay" id="incomingCallModal">
    <div class="incoming-call-modal">
      <div class="incoming-call-icon">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z" />
        </svg>
      </div>
      <div class="incoming-call-label">Incoming Call</div>
      <div class="incoming-call-number" id="incomingCallNumber">Unknown</div>
      <div class="incoming-call-actions">
        <div class="incoming-call-btn-wrapper">
          <button class="incoming-call-btn decline" id="declineCallBtn" title="Decline">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
          <span class="incoming-call-btn-label">Decline</span>
        </div>
        <div class="incoming-call-btn-wrapper">
          <button class="incoming-call-btn answer" id="answerCallBtn" title="Answer">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z" />
            </svg>
          </button>
          <span class="incoming-call-btn-label">Answer</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Reconnecting Overlay -->
  <div class="reconnecting-overlay hidden" id="reconnectingOverlay">
    <div class="reconnecting-box">
      <div class="reconnecting-spinner"></div>
      <h4 id="reconnectingTitle">Reconnecting...</h4>
      <p id="reconnectingMessage" style="color: var(--gray-600); font-size: 0.875rem;">
        Attempting to restore connection. Please wait.
      </p>
      <button class="btn btn-secondary mt-3" onclick="cancelReconnect()">Switch to Basic Mode</button>
    </div>
  </div>

  <!-- Auto-Dial Countdown Overlay -->
  <div class="countdown-overlay hidden" id="countdownOverlay">
    <div class="countdown-box">
      <div class="countdown-circle">
        <span class="countdown-number" id="countdownNumber">3</span>
      </div>
      <h4 class="countdown-title">Next Call In...</h4>
      <p class="countdown-contact" id="countdownContact">Loading next contact...</p>
      <button class="btn btn-secondary" onclick="cancelCountdown()">Cancel Auto-Dial</button>
    </div>
  </div>

  <!-- Break Warning Modal -->
  <div class="break-warning-overlay" id="breakWarningModal">
    <div class="break-warning-modal">
      <div class="break-warning-icon">&#9749;</div>
      <div class="break-warning-title">Are you on a break?</div>
      <div class="break-warning-text">You've been idle for a while. Let us know if you're taking a break so we can track your time accurately.</div>
      <div class="break-warning-actions">
        <button class="btn btn-secondary" onclick="dismissBreakWarning()">Back to Work</button>
        <button class="btn btn-primary" onclick="confirmBreak()">Yes, On Break</button>
      </div>
    </div>
  </div>

  <style>
    .countdown-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    .countdown-overlay.hidden {
      display: none;
    }
    .countdown-box {
      background: var(--gray-900, #1a1a2e);
      border-radius: 16px;
      padding: 40px;
      text-align: center;
      border: 1px solid var(--gray-700, #333);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }
    .countdown-circle {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary, #6366f1), var(--primary-dark, #4f46e5));
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 20px;
      animation: pulse 1s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    .countdown-number {
      font-size: 48px;
      font-weight: bold;
      color: white;
    }
    .countdown-title {
      color: white;
      margin-bottom: 8px;
      font-size: 1.25rem;
    }
    .countdown-contact {
      color: var(--gray-400, #9ca3af);
      margin-bottom: 24px;
      font-size: 0.95rem;
    }
  </style>

  <script>
    // State
    let device = null;
    let connection = null;
    let callStartTime = null;
    let timerInterval = null;
    let ws = null;
    let currentCallSid = null;
    let selectedOutcome = null;
    // Use fixed identity so incoming calls can reach this browser
    const repIdentity = 'sales-rep';

    // Supabase State
    let currentUser = null;
    let companyId = null;
    let currentCallRecordId = null;  // ID of the call record in Supabase
    let currentContactId = null;     // ID of the contact being called

    // Advanced Mode State
    let advancedModeEnabled = false;  // Whether user wants advanced mode
    let advancedModeActive = false;   // Whether it's actually working
    let wsReconnectAttempts = 0;
    let wsReconnectTimer = null;
    let wsMaxReconnectAttempts = 5;
    let wsReconnectDelay = 2000;  // Start with 2 seconds
    let wsLastConnectedTime = null;
    let fallbackToBasicMode = false;

    // Advanced Mode Features
    const ADVANCED_FEATURES = {
      liveTranscription: true,
      aiCoaching: true,
      speakingIndicator: true
    };

    // Knowledge Base State
    let selectedKnowledgeBaseId = null;
    let knowledgeBases = [];

    // Lead Source State
    let leadSourceData = {
      source: null,
      customSource: null,
      category: null,
      campaignName: null,
      adName: null
    };
    let leadSourceEditMode = false;

    // Queue State
    let callQueue = [];
    let currentQueueIndex = -1;
    let autoDialEnabled = false;
    let autoDialPaused = false;
    let autoDialTimeout = null;
    let countdownInterval = null;
    let pausedSecondsRemaining = 0;
    let pausedNextContact = null;

    // =====================================================
    // SESSION TRACKER - Time Tracking for Sales Reps
    // =====================================================
    const sessionTracker = {
      // Session state
      sessionId: null,
      status: 'inactive', // inactive, active, paused, completed
      startedAt: null,

      // Time tracking (in seconds)
      totalDuration: 0,
      talkTime: 0,
      idleTime: 0,
      breakTime: 0,

      // Call metrics
      totalCalls: 0,
      connectedCalls: 0,
      bookedCalls: 0,

      // Internal timers
      updateInterval: null,
      currentMode: 'idle', // 'talk', 'idle', 'break'
      modeStartTime: null,
      lastActivityAt: null,

      // Settings
      breakDetectionEnabled: false,
      breakDetectionMinutes: 5,
      breakWarningShown: false,

      // Initialize the tracker
      async init() {
        console.log('SessionTracker: Initializing...');
        await this.loadSettings();
        await this.recoverSession();
        this.updateUI();
      },

      // Load company settings for break detection
      async loadSettings() {
        try {
          const { data: { user } } = await supabase.auth.getUser();
          if (!user) return;

          // Get company_id from company_members
          const { data: memberData } = await supabase
            .from('company_members')
            .select('company_id')
            .eq('user_id', user.id)
            .limit(1)
            .maybeSingle();

          if (memberData?.company_id) {
            const { data: settings } = await supabase
              .from('company_settings')
              .select('break_detection_enabled, break_detection_minutes')
              .eq('company_id', memberData.company_id)
              .limit(1)
              .maybeSingle();

            if (settings) {
              this.breakDetectionEnabled = settings.break_detection_enabled || false;
              this.breakDetectionMinutes = settings.break_detection_minutes || 5;
            }
          }
        } catch (error) {
          console.error('SessionTracker: Error loading settings', error);
        }
      },

      // Recover session from localStorage (for page refresh resilience)
      async recoverSession() {
        try {
          const saved = localStorage.getItem('sessionTracker');
          if (!saved) return;

          const data = JSON.parse(saved);

          // Check if session is from today
          const savedDate = new Date(data.startedAt).toDateString();
          const today = new Date().toDateString();

          if (savedDate !== today) {
            // Session from previous day, clear it
            localStorage.removeItem('sessionTracker');
            return;
          }

          // Restore state
          this.sessionId = data.sessionId;
          this.status = data.status;
          this.startedAt = new Date(data.startedAt);
          this.totalDuration = data.totalDuration || 0;
          this.talkTime = data.talkTime || 0;
          this.idleTime = data.idleTime || 0;
          this.breakTime = data.breakTime || 0;
          this.totalCalls = data.totalCalls || 0;
          this.connectedCalls = data.connectedCalls || 0;
          this.bookedCalls = data.bookedCalls || 0;
          this.currentMode = data.currentMode || 'idle';
          this.lastActivityAt = data.lastActivityAt ? new Date(data.lastActivityAt) : null;

          // If session was active, resume it
          if (this.status === 'active') {
            // Calculate time passed since last save
            const lastSaveTime = new Date(data.savedAt);
            const elapsedSeconds = Math.floor((Date.now() - lastSaveTime.getTime()) / 1000);

            // Add elapsed time to appropriate category
            if (this.currentMode === 'talk') {
              this.talkTime += elapsedSeconds;
            } else if (this.currentMode === 'break') {
              this.breakTime += elapsedSeconds;
            } else {
              this.idleTime += elapsedSeconds;
            }

            // Recalculate total duration
            this.totalDuration = Math.floor((Date.now() - this.startedAt.getTime()) / 1000);

            this.startUpdateLoop();
            console.log('SessionTracker: Recovered session', this.sessionId);
          }
        } catch (error) {
          console.error('SessionTracker: Error recovering session', error);
          localStorage.removeItem('sessionTracker');
        }
      },

      // Save session to localStorage
      saveToLocalStorage() {
        const data = {
          sessionId: this.sessionId,
          status: this.status,
          startedAt: this.startedAt?.toISOString(),
          totalDuration: this.totalDuration,
          talkTime: this.talkTime,
          idleTime: this.idleTime,
          breakTime: this.breakTime,
          totalCalls: this.totalCalls,
          connectedCalls: this.connectedCalls,
          bookedCalls: this.bookedCalls,
          currentMode: this.currentMode,
          lastActivityAt: this.lastActivityAt?.toISOString(),
          savedAt: new Date().toISOString()
        };
        localStorage.setItem('sessionTracker', JSON.stringify(data));
      },

      // Auto-start session when first call is made
      async startSession() {
        if (this.status === 'active') return; // Already active

        console.log('SessionTracker: Starting new session');

        try {
          const { data: { user } } = await supabase.auth.getUser();
          if (!user) {
            console.error('SessionTracker: No user for session start');
            return;
          }

          // Get company_id
          const { data: memberData } = await supabase
            .from('company_members')
            .select('company_id')
            .eq('user_id', user.id)
            .limit(1)
            .maybeSingle();

          const companyId = memberData?.company_id;

          // Create session in database
          const { data: session, error } = await supabase
            .from('rep_sessions')
            .insert({
              rep_id: user.id,
              company_id: companyId,
              status: 'active',
              started_at: new Date().toISOString()
            })
            .select('id')
            .single();

          if (error) {
            console.error('SessionTracker: Error creating session', error);
            return;
          }

          this.sessionId = session.id;
          this.status = 'active';
          this.startedAt = new Date();
          this.currentMode = 'idle';
          this.modeStartTime = Date.now();
          this.lastActivityAt = new Date();

          // Log session start event
          await this.logEvent('session_start');

          this.startUpdateLoop();
          this.updateUI();
          this.saveToLocalStorage();

          console.log('SessionTracker: Session started', this.sessionId);
        } catch (error) {
          console.error('SessionTracker: Error starting session', error);
        }
      },

      // Called when a call starts (dialing)
      async onCallStarted() {
        // Auto-start session if not already active
        if (this.status !== 'active') {
          await this.startSession();
        }

        this.totalCalls++;
        this.lastActivityAt = new Date();
        this.breakWarningShown = false;

        // Switch to talk mode
        this.switchMode('talk');

        await this.logEvent('call_start');
        this.updateUI();
        this.saveToLocalStorage();
      },

      // Called when a call connects
      async onCallConnected() {
        this.connectedCalls++;
        this.lastActivityAt = new Date();

        await this.logEvent('call_connected');
        this.updateUI();
        this.saveToLocalStorage();
      },

      // Called when a call ends
      async onCallEnded(callSid) {
        // Calculate call duration for the event
        let callDuration = 0;
        if (this.currentMode === 'talk' && this.modeStartTime) {
          callDuration = Math.floor((Date.now() - this.modeStartTime) / 1000);
        }

        // Switch to idle mode
        this.switchMode('idle');
        this.lastActivityAt = new Date();

        await this.logEvent('call_end', { call_sid: callSid, duration_seconds: callDuration });
        this.updateUI();
        this.saveToLocalStorage();
      },

      // Called when a booking is made
      onBooking() {
        this.bookedCalls++;
        this.updateUI();
        this.saveToLocalStorage();
      },

      // Switch between modes (talk, idle, break)
      switchMode(newMode) {
        if (this.currentMode === newMode) return;

        // Calculate time spent in current mode
        if (this.modeStartTime) {
          const elapsed = Math.floor((Date.now() - this.modeStartTime) / 1000);

          if (this.currentMode === 'talk') {
            this.talkTime += elapsed;
          } else if (this.currentMode === 'idle') {
            this.idleTime += elapsed;
          } else if (this.currentMode === 'break') {
            this.breakTime += elapsed;
          }
        }

        this.currentMode = newMode;
        this.modeStartTime = Date.now();
      },

      // Toggle pause/break
      async togglePause() {
        if (this.status === 'active' && this.currentMode !== 'break') {
          // Start break
          this.status = 'paused';
          this.switchMode('break');
          await this.logEvent('session_pause');
        } else if (this.status === 'paused' || this.currentMode === 'break') {
          // End break
          this.status = 'active';
          this.switchMode('idle');
          await this.logEvent('session_resume');
          this.breakWarningShown = false;
        }

        this.updateUI();
        this.saveToLocalStorage();
      },

      // End the session
      async endSession() {
        if (this.status !== 'active' && this.status !== 'paused') return;

        console.log('SessionTracker: Ending session');

        // Stop update loop
        this.stopUpdateLoop();

        // Finalize any current mode time
        this.switchMode('idle');

        // Calculate final total duration
        this.totalDuration = Math.floor((Date.now() - this.startedAt.getTime()) / 1000);

        // Update database
        try {
          const { data: { user } } = await supabase.auth.getUser();
          if (!user) return;

          // Validate session exists and user owns it
          const { data: existingSession } = await supabase
            .from('rep_sessions')
            .select('id, rep_id')
            .eq('id', this.sessionId)
            .eq('rep_id', user.id)
            .limit(1)
            .maybeSingle();

          if (!existingSession) {
            console.error('SessionTracker: Session not found or not owned by user');
            return;
          }

          await supabase
            .from('rep_sessions')
            .update({
              status: 'completed',
              ended_at: new Date().toISOString(),
              total_duration_seconds: this.totalDuration,
              talk_time_seconds: this.talkTime,
              idle_time_seconds: this.idleTime,
              break_time_seconds: this.breakTime,
              total_calls: this.totalCalls,
              connected_calls: this.connectedCalls,
              booked_calls: this.bookedCalls,
              updated_at: new Date().toISOString()
            })
            .eq('id', this.sessionId);

          await this.logEvent('session_end');
        } catch (error) {
          console.error('SessionTracker: Error ending session', error);
        }

        // Reset state
        this.status = 'completed';
        localStorage.removeItem('sessionTracker');

        // Show summary
        this.showEndSessionSummary();

        // Reset for new session
        this.resetState();
        this.updateUI();
      },

      // Reset state for new session
      resetState() {
        this.sessionId = null;
        this.status = 'inactive';
        this.startedAt = null;
        this.totalDuration = 0;
        this.talkTime = 0;
        this.idleTime = 0;
        this.breakTime = 0;
        this.totalCalls = 0;
        this.connectedCalls = 0;
        this.bookedCalls = 0;
        this.currentMode = 'idle';
        this.modeStartTime = null;
        this.lastActivityAt = null;
        this.breakWarningShown = false;
      },

      // Show end session summary
      showEndSessionSummary() {
        const hours = Math.floor(this.totalDuration / 3600);
        const mins = Math.floor((this.totalDuration % 3600) / 60);
        const talkPercent = this.totalDuration > 0
          ? Math.round((this.talkTime / this.totalDuration) * 100)
          : 0;
        const callsPerHour = this.totalDuration > 0
          ? (this.totalCalls / (this.totalDuration / 3600)).toFixed(1)
          : 0;

        const message = `Session Complete!\n\n` +
          `Duration: ${hours}h ${mins}m\n` +
          `Calls Made: ${this.totalCalls}\n` +
          `Connected: ${this.connectedCalls}\n` +
          `Bookings: ${this.bookedCalls}\n` +
          `Talk Time: ${talkPercent}%\n` +
          `Calls/Hour: ${callsPerHour}`;

        alert(message);
      },

      // Log event to database
      async logEvent(eventType, metadata = {}) {
        if (!this.sessionId) return;

        try {
          const { data: { user } } = await supabase.auth.getUser();
          if (!user) return;

          // Get company_id
          const { data: memberData } = await supabase
            .from('company_members')
            .select('company_id')
            .eq('user_id', user.id)
            .limit(1)
            .maybeSingle();

          await supabase
            .from('rep_session_events')
            .insert({
              session_id: this.sessionId,
              rep_id: user.id,
              company_id: memberData?.company_id,
              event_type: eventType,
              call_sid: metadata.call_sid || null,
              duration_seconds: metadata.duration_seconds || null,
              metadata: metadata
            });
        } catch (error) {
          console.error('SessionTracker: Error logging event', error);
        }
      },

      // Save current state to database (periodic sync)
      async syncToDatabase() {
        if (!this.sessionId || this.status === 'inactive') return;

        try {
          const { data: { user } } = await supabase.auth.getUser();
          if (!user) return;

          await supabase
            .from('rep_sessions')
            .update({
              total_duration_seconds: this.totalDuration,
              talk_time_seconds: this.talkTime,
              idle_time_seconds: this.idleTime,
              break_time_seconds: this.breakTime,
              total_calls: this.totalCalls,
              connected_calls: this.connectedCalls,
              booked_calls: this.bookedCalls,
              last_activity_at: this.lastActivityAt?.toISOString(),
              updated_at: new Date().toISOString()
            })
            .eq('id', this.sessionId)
            .eq('rep_id', user.id);
        } catch (error) {
          console.error('SessionTracker: Error syncing to database', error);
        }
      },

      // Start the update loop
      startUpdateLoop() {
        if (this.updateInterval) return;

        this.updateInterval = setInterval(() => {
          this.tick();
        }, 1000);
      },

      // Stop the update loop
      stopUpdateLoop() {
        if (this.updateInterval) {
          clearInterval(this.updateInterval);
          this.updateInterval = null;
        }
      },

      // Tick function called every second
      tick() {
        if (this.status !== 'active' && this.status !== 'paused') return;

        // Update total duration
        this.totalDuration = Math.floor((Date.now() - this.startedAt.getTime()) / 1000);

        // Update current mode time
        if (this.modeStartTime) {
          const elapsed = Math.floor((Date.now() - this.modeStartTime) / 1000);

          // Calculate running totals (base + current mode elapsed)
          const runningTalkTime = this.currentMode === 'talk'
            ? this.talkTime + elapsed
            : this.talkTime;
          const runningIdleTime = this.currentMode === 'idle'
            ? this.idleTime + elapsed
            : this.idleTime;
          const runningBreakTime = this.currentMode === 'break'
            ? this.breakTime + elapsed
            : this.breakTime;

          // Update UI with running totals
          this.updateUIWithTimes(runningTalkTime, runningIdleTime, runningBreakTime);
        }

        // Check for break warning
        this.checkBreakWarning();

        // Save to localStorage every 5 seconds
        if (this.totalDuration % 5 === 0) {
          this.saveToLocalStorage();
        }

        // Sync to database every 30 seconds
        if (this.totalDuration % 30 === 0) {
          this.syncToDatabase();
        }
      },

      // Check if we should show break warning
      checkBreakWarning() {
        if (!this.breakDetectionEnabled) return;
        if (this.breakWarningShown) return;
        if (this.currentMode !== 'idle') return;
        if (this.status !== 'active') return;

        const idleMinutes = Math.floor((Date.now() - this.modeStartTime) / 60000);

        if (idleMinutes >= this.breakDetectionMinutes) {
          this.breakWarningShown = true;
          showBreakWarning();
        }
      },

      // Update UI with specific times (for running display)
      updateUIWithTimes(talkTime, idleTime, breakTime) {
        // Working time
        document.getElementById('sessionWorkingTime').textContent =
          this.formatDuration(this.totalDuration);

        // Add on-call class when in talk mode
        const workingTimeEl = document.getElementById('sessionWorkingTime');
        if (this.currentMode === 'talk') {
          workingTimeEl.classList.add('on-call');
        } else {
          workingTimeEl.classList.remove('on-call');
        }

        // Time stats
        document.getElementById('sessionTalkTime').textContent =
          this.formatDurationShort(talkTime);
        document.getElementById('sessionIdleTime').textContent =
          this.formatDurationShort(idleTime);
        document.getElementById('sessionBreakTime').textContent =
          this.formatDurationShort(breakTime);

        // Productivity bar
        const total = talkTime + idleTime + breakTime;
        if (total > 0) {
          const talkPercent = (talkTime / total) * 100;
          const idlePercent = (idleTime / total) * 100;
          const breakPercent = (breakTime / total) * 100;

          document.getElementById('productivityTalk').style.width = talkPercent + '%';
          document.getElementById('productivityIdle').style.width = idlePercent + '%';
          document.getElementById('productivityBreak').style.width = breakPercent + '%';
          document.getElementById('productivityPercent').textContent =
            Math.round(talkPercent) + '%';
        }

        // Call metrics
        document.getElementById('sessionTotalCalls').textContent = this.totalCalls;
        document.getElementById('sessionConnectedCalls').textContent = this.connectedCalls;

        // Calls per hour
        const hours = this.totalDuration / 3600;
        const callsPerHour = hours > 0 ? (this.totalCalls / hours).toFixed(1) : '0.0';
        document.getElementById('sessionCallsPerHour').textContent = callsPerHour;
      },

      // Update UI
      updateUI() {
        // Status badge
        const statusBadge = document.getElementById('sessionStatusBadge');
        if (this.status === 'active') {
          statusBadge.textContent = 'Active';
          statusBadge.className = 'session-status active';
        } else if (this.status === 'paused') {
          statusBadge.textContent = 'On Break';
          statusBadge.className = 'session-status paused';
        } else {
          statusBadge.textContent = 'Not Started';
          statusBadge.className = 'session-status inactive';
        }

        // Pause button
        const pauseBtn = document.getElementById('sessionPauseBtn');
        const pauseBtnIcon = document.getElementById('pauseBtnIcon');
        const pauseBtnText = document.getElementById('pauseBtnText');

        if (this.status === 'paused' || this.currentMode === 'break') {
          pauseBtnIcon.innerHTML = '&#9658;'; // Play icon
          pauseBtnText.textContent = 'Resume';
          pauseBtn.classList.remove('btn-pause');
          pauseBtn.classList.add('btn-primary');
        } else {
          pauseBtnIcon.innerHTML = '&#9616;&#9616;'; // Pause icon
          pauseBtnText.textContent = 'Break';
          pauseBtn.classList.add('btn-pause');
          pauseBtn.classList.remove('btn-primary');
        }

        // Update times
        this.updateUIWithTimes(this.talkTime, this.idleTime, this.breakTime);
      },

      // Format duration as H:MM:SS
      formatDuration(seconds) {
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = seconds % 60;
        return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
      },

      // Format duration as M:SS
      formatDurationShort(seconds) {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m}:${s.toString().padStart(2, '0')}`;
      }
    };

    // Time Tracking Panel UI Functions
    function toggleTimeTrackingPanel() {
      const panel = document.getElementById('timeTrackingPanel');
      panel.classList.toggle('collapsed');
    }

    function toggleSessionPause() {
      sessionTracker.togglePause();
    }

    async function endSession() {
      if (confirm('Are you sure you want to end your session? This will save your stats.')) {
        await sessionTracker.endSession();
      }
    }

    // Break Warning Functions
    function showBreakWarning() {
      document.getElementById('breakWarningModal').classList.add('active');
    }

    function hideBreakWarning() {
      document.getElementById('breakWarningModal').classList.remove('active');
    }

    function dismissBreakWarning() {
      hideBreakWarning();
      sessionTracker.lastActivityAt = new Date();
      sessionTracker.breakWarningShown = false;
    }

    function confirmBreak() {
      hideBreakWarning();
      sessionTracker.togglePause();
    }

    // Pause/Resume functions
    function togglePause() {
      if (!autoDialEnabled) return;

      const pauseBtn = document.getElementById('pauseBtn');
      const label = document.getElementById('autoDialLabel');

      if (autoDialPaused) {
        // Resume
        autoDialPaused = false;
        pauseBtn.textContent = '‚è∏Ô∏è Pause';
        pauseBtn.style.background = '';
        label.textContent = 'Auto-Dial: ON';
        label.style.color = 'var(--success, #22c55e)';

        // Resume the countdown if we have time remaining
        if (pausedSecondsRemaining > 0 && pausedNextContact) {
          showCountdown(pausedSecondsRemaining, pausedNextContact);
          autoDialTimeout = setTimeout(() => {
            hideCountdown();
            dialNextInQueue();
          }, pausedSecondsRemaining * 1000);
        } else if (callQueue.some(i => i.status === 'pending')) {
          // No countdown was active, start fresh
          dialNextInQueue();
        }

        showNotification('Auto-dial resumed', 'info');
      } else {
        // Pause
        autoDialPaused = true;
        pauseBtn.textContent = '‚ñ∂Ô∏è Resume';
        pauseBtn.style.background = 'var(--warning, #f59e0b)';
        label.textContent = 'Auto-Dial: PAUSED';
        label.style.color = 'var(--warning, #f59e0b)';

        // Save current countdown state
        const countdownEl = document.getElementById('countdownNumber');
        if (countdownEl && !document.getElementById('countdownOverlay').classList.contains('hidden')) {
          pausedSecondsRemaining = parseInt(countdownEl.textContent) || 0;
          pausedNextContact = callQueue.find(i => i.status === 'pending');
        }

        // Clear timeout and hide countdown
        if (autoDialTimeout) {
          clearTimeout(autoDialTimeout);
          autoDialTimeout = null;
        }
        hideCountdown();

        showNotification('Auto-dial paused - click Resume to continue', 'warning');
      }
    }

    function updatePauseButtonVisibility() {
      const pauseBtn = document.getElementById('pauseBtn');
      if (autoDialEnabled) {
        pauseBtn.style.display = 'inline-block';
      } else {
        pauseBtn.style.display = 'none';
        autoDialPaused = false;
        pausedSecondsRemaining = 0;
        pausedNextContact = null;
      }
    }

    // Countdown overlay functions
    function showCountdown(seconds, nextContact) {
      // Don't show countdown if paused
      if (autoDialPaused) return;

      console.log('showCountdown called:', seconds, nextContact);
      const overlay = document.getElementById('countdownOverlay');
      const numberEl = document.getElementById('countdownNumber');
      const contactEl = document.getElementById('countdownContact');

      // Set initial values
      numberEl.textContent = seconds;
      contactEl.textContent = nextContact ? `Calling: ${nextContact.name || nextContact.displayNumber}` : 'Next contact';

      // Show overlay
      overlay.classList.remove('hidden');

      // Clear any existing interval
      if (countdownInterval) {
        clearInterval(countdownInterval);
      }

      // Update countdown every second
      let remaining = seconds;
      countdownInterval = setInterval(() => {
        remaining--;
        console.log('Countdown:', remaining);
        if (remaining > 0) {
          numberEl.textContent = remaining;
        } else {
          numberEl.textContent = '0';
          clearInterval(countdownInterval);
          countdownInterval = null;
        }
      }, 1000);
    }

    function hideCountdown() {
      console.log('hideCountdown called');
      const overlay = document.getElementById('countdownOverlay');
      overlay.classList.add('hidden');

      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
    }

    function cancelCountdown() {
      console.log('cancelCountdown called');
      // Clear the timeout that would dial next
      if (autoDialTimeout) {
        clearTimeout(autoDialTimeout);
        autoDialTimeout = null;
      }

      // Hide the overlay
      hideCountdown();

      // Disable auto-dial
      autoDialEnabled = false;
      document.getElementById('autoDialToggle').checked = false;

      // Update visual feedback
      const toggleLabel = document.querySelector('.auto-dial-toggle span');
      if (toggleLabel) {
        toggleLabel.textContent = 'Auto-Dial';
        toggleLabel.style.color = '';
      }

      showNotification('Auto-dial cancelled', 'info');
    }

    // Auto-dial toggle handler (inline for reliability)
    function handleAutoDialToggle(checked) {
      console.log('Auto-dial toggled:', checked);
      autoDialEnabled = checked;
      autoDialPaused = false; // Reset pause state when toggling

      // Update pause button visibility
      updatePauseButtonVisibility();

      // Visual feedback
      const toggleLabel = document.getElementById('autoDialLabel');
      if (toggleLabel) {
        toggleLabel.textContent = checked ? 'Auto-Dial: ON' : 'Auto-Dial';
        toggleLabel.style.color = checked ? 'var(--success, #22c55e)' : '';
      }

      // Reset pause button state
      const pauseBtn = document.getElementById('pauseBtn');
      if (pauseBtn) {
        pauseBtn.textContent = '‚è∏Ô∏è Pause';
        pauseBtn.style.background = '';
      }

      // Clear any existing timeout and hide countdown
      if (autoDialTimeout) {
        clearTimeout(autoDialTimeout);
        autoDialTimeout = null;
      }
      hideCountdown();

      // Start dialing if enabled and not in a call
      if (autoDialEnabled && !connection && callQueue.some(item => item.status === 'pending')) {
        const delay = parseInt(document.getElementById('dialDelay').value) * 1000;
        const delaySeconds = delay / 1000;

        // Find next pending contact for display
        const nextContact = callQueue.find(i => i.status === 'pending');

        if (delay > 0) {
          // Show countdown overlay
          showCountdown(delaySeconds, nextContact);
          autoDialTimeout = setTimeout(() => {
            hideCountdown();
            dialNextInQueue();
          }, delay);
        } else {
          dialNextInQueue();
        }
      }
    }

    // Scripts
    const scripts = {
      intro: {
        title: 'Introduction',
        content: `Hi, this is [Your Name] from [Company]. How are you doing today?

I'm calling because [reason for call]. Do you have a moment to chat?

Great! Let me tell you a little about what we offer...`
      },
      pricing: {
        title: 'Pricing Discussion',
        content: `Our pricing is based on [factors].

For your specific needs, I'd estimate around [price range].

This includes:
‚Ä¢ [Feature 1]
‚Ä¢ [Feature 2]
‚Ä¢ [Feature 3]

How does that sound to you?`
      },
      objections: {
        title: 'Handling Objections',
        content: `"It's too expensive"
‚Üí I understand budget is important. Let me share how our customers typically see ROI within [timeframe]...

"I need to think about it"
‚Üí Of course! What specific aspects would you like to consider? I'd be happy to provide more information.

"I'm happy with my current provider"
‚Üí That's great to hear. Out of curiosity, what do you like most about them? Many of our customers actually switched from similar providers because...`
      },
      close: {
        title: 'Closing the Sale',
        content: `Based on what we've discussed, it sounds like [product/service] would be a great fit for you.

Would you like to move forward with [specific next step]?

I can get you started right now, and you'll [benefit].

What do you say?`
      }
    };

    // ==========================================
    // QUEUE MANAGEMENT FUNCTIONS
    // ==========================================

    function addToQueue(number = null, name = null) {
      const input = document.getElementById('queuePhoneInput');
      const phoneNumber = number || input.value.trim();

      if (!phoneNumber) return;

      // Clean the number
      let cleaned = phoneNumber.replace(/\D/g, '');
      if (cleaned.length < 10) {
        alert('Please enter a valid phone number');
        return;
      }

      // Format with country code
      if (cleaned.length === 10) {
        cleaned = '+1' + cleaned;
      } else if (!cleaned.startsWith('+')) {
        cleaned = '+' + cleaned;
      }

      // Check for duplicates
      if (callQueue.some(item => item.number === cleaned && item.status === 'pending')) {
        alert('This number is already in the queue');
        return;
      }

      callQueue.push({
        id: Date.now() + Math.random(),
        number: cleaned,
        displayNumber: formatPhoneNumber(cleaned),
        name: name || null,
        status: 'pending', // pending, calling, completed, skipped, no_answer
        outcome: null,
        addedAt: new Date()
      });

      input.value = '';
      renderQueue();
      updateQueueStats();
      saveQueueToStorage();
    }

    function removeFromQueue(id) {
      callQueue = callQueue.filter(item => item.id !== id);
      renderQueue();
      updateQueueStats();
      saveQueueToStorage();
    }

    function skipQueueItem(id) {
      const item = callQueue.find(i => i.id === id);
      if (item) {
        item.status = 'skipped';
        renderQueue();
        updateQueueStats();
        saveQueueToStorage();
      }
    }

    function retryQueueItem(id) {
      const item = callQueue.find(i => i.id === id);
      if (item) {
        item.status = 'pending';
        item.outcome = null;
        renderQueue();
        updateQueueStats();
        saveQueueToStorage();
        showNotification('Contact moved back to queue', 'info');
      }
    }

    function clearQueue() {
      if (callQueue.length === 0) return;
      if (confirm('Clear all numbers from the queue?')) {
        callQueue = [];
        currentQueueIndex = -1;
        renderQueue();
        updateQueueStats();
        saveQueueToStorage();
      }
    }

    function renderQueue() {
      const container = document.getElementById('queueList');

      if (callQueue.length === 0) {
        container.innerHTML = `
          <div class="queue-empty">
            <div class="queue-empty-icon">üìã</div>
            <div>No numbers in queue</div>
            <div style="font-size: 0.75rem; margin-top: 4px;">Add numbers below to get started</div>
          </div>
        `;
        return;
      }

      container.innerHTML = callQueue.map((item, index) => {
        let statusIcon = '';
        let statusClass = '';

        switch (item.status) {
          case 'calling':
            statusIcon = 'üìû';
            statusClass = 'active';
            break;
          case 'completed':
            statusIcon = item.outcome === 'booked' ? '‚úÖ' : item.outcome === 'callback' ? 'üìÖ' : '‚úì';
            statusClass = 'completed';
            break;
          case 'skipped':
            statusIcon = '‚è≠Ô∏è';
            statusClass = 'skipped';
            break;
          case 'no_answer':
            statusIcon = 'üìµ';
            statusClass = 'completed';
            break;
          default:
            statusIcon = '';
        }

        // Determine which action buttons to show
        let actionButtons = '';
        if (item.status === 'pending') {
          actionButtons = `
            <div class="queue-item-actions">
              <button class="queue-action-btn" onclick="event.stopPropagation(); skipQueueItem(${item.id})" title="Skip">‚è≠Ô∏è</button>
              <button class="queue-action-btn" onclick="event.stopPropagation(); removeFromQueue(${item.id})" title="Remove">‚úï</button>
            </div>
          `;
        } else if (item.status === 'skipped' || item.status === 'no_answer') {
          actionButtons = `
            <div class="queue-item-actions">
              <button class="queue-action-btn" onclick="event.stopPropagation(); retryQueueItem(${item.id})" title="Retry">üîÑ</button>
              <button class="queue-action-btn" onclick="event.stopPropagation(); removeFromQueue(${item.id})" title="Remove">‚úï</button>
            </div>
          `;
        }

        return `
          <div class="queue-item ${statusClass}" data-id="${item.id}" onclick="callFromQueue(${item.id})">
            <div style="flex: 1;">
              <div class="queue-item-number">${item.displayNumber}</div>
              ${item.name ? `<div class="queue-item-name">${item.name}</div>` : ''}
            </div>
            <div class="queue-item-status">${statusIcon}</div>
            ${actionButtons}
          </div>
        `;
      }).join('');
    }

    function updateQueueStats() {
      const total = callQueue.length;
      const completed = callQueue.filter(i => ['completed', 'no_answer', 'skipped'].includes(i.status)).length;
      const remaining = callQueue.filter(i => i.status === 'pending').length;

      document.getElementById('queueTotal').textContent = total;
      document.getElementById('queueCompleted').textContent = completed;
      document.getElementById('queueRemaining').textContent = remaining;
    }

    function callFromQueue(id) {
      console.log('callFromQueue called with id:', id);
      const item = callQueue.find(i => i.id === id);
      if (!item) {
        console.log('callFromQueue: item not found');
        return;
      }

      // Allow calling pending, skipped, or no_answer items
      if (!['pending', 'skipped', 'no_answer'].includes(item.status)) {
        console.log('callFromQueue: item already completed', { status: item.status });
        return;
      }

      // Mark as calling
      item.status = 'calling';
      item.outcome = null; // Reset outcome for retry
      currentQueueIndex = callQueue.findIndex(i => i.id === id);
      renderQueue();

      // Load lead source data if exists for this queue item
      loadLeadSourceForQueueItem(item);

      // Set the phone input and make the call
      console.log('callFromQueue: Setting phone input to:', item.displayNumber);
      document.getElementById('phoneInput').value = item.displayNumber;
      makeCall();
    }

    function dialNextInQueue() {
      console.log('dialNextInQueue called, queue:', callQueue.map(i => ({ id: i.id, status: i.status })));
      const nextItem = callQueue.find(i => i.status === 'pending');
      if (nextItem) {
        console.log('Found next pending item:', nextItem.id, nextItem.displayNumber);
        callFromQueue(nextItem.id);
      } else {
        // Queue complete
        console.log('Queue complete, disabling auto-dial');
        autoDialEnabled = false;
        document.getElementById('autoDialToggle').checked = false;
        showNotification('Call queue completed!', 'info');
      }
    }

    function markCurrentQueueItemComplete(outcome) {
      if (currentQueueIndex >= 0 && currentQueueIndex < callQueue.length) {
        const item = callQueue[currentQueueIndex];
        item.status = outcome === 'no_answer' ? 'no_answer' : 'completed';
        item.outcome = outcome;
        renderQueue();
        updateQueueStats();
      }
    }

    // Bulk Add Functions
    function showBulkAddModal() {
      document.getElementById('bulkAddModal').classList.add('active');
      document.getElementById('bulkNumbersInput').focus();
    }

    function closeBulkAddModal() {
      document.getElementById('bulkAddModal').classList.remove('active');
      document.getElementById('bulkNumbersInput').value = '';
    }

    function processBulkAdd() {
      const input = document.getElementById('bulkNumbersInput').value;
      const lines = input.split('\n').filter(line => line.trim());

      let addedCount = 0;
      lines.forEach(line => {
        // Try to extract phone number and optional name
        // Format could be: "555-123-4567" or "John Doe, 555-123-4567" or "555-123-4567, John Doe"
        const cleaned = line.trim();
        if (cleaned) {
          // Extract numbers
          const numbers = cleaned.match(/[\d\s\-\(\)\+]+/g);
          if (numbers) {
            const phoneNumber = numbers.join('').replace(/\s/g, '');
            if (phoneNumber.replace(/\D/g, '').length >= 10) {
              // Try to get name (anything that's not the phone number)
              let name = cleaned.replace(phoneNumber, '').replace(/[,\-]/g, '').trim();
              addToQueue(phoneNumber, name || null);
              addedCount++;
            }
          }
        }
      });

      closeBulkAddModal();
      if (addedCount > 0) {
        console.log(`Added ${addedCount} numbers to queue`);
      }
    }

    // ==========================================
    // END QUEUE MANAGEMENT
    // ==========================================

    // ==========================================
    // LEAD SOURCE FUNCTIONS
    // ==========================================

    const sourceConfig = {
      facebook: { icon: 'üìò', label: 'Facebook', color: '#1877f2' },
      google: { icon: 'üîç', label: 'Google', color: '#ea4335' },
      instagram: { icon: 'üì∑', label: 'Instagram', color: '#e4405f' },
      tiktok: { icon: 'üéµ', label: 'TikTok', color: '#000000' },
      linkedin: { icon: 'üíº', label: 'LinkedIn', color: '#0077b5' },
      referral: { icon: 'ü§ù', label: 'Referral', color: '#10b981' },
      website: { icon: 'üåê', label: 'Website', color: '#2563eb' },
      'cold-call': { icon: 'üìû', label: 'Cold Call', color: '#f59e0b' },
      other: { icon: 'üìã', label: 'Other', color: '#6b7280' }
    };

    const categoryLabels = {
      ad: 'Paid Ad',
      organic: 'Organic',
      direct: 'Direct',
      retargeting: 'Retargeting',
      email: 'Email',
      sms: 'SMS'
    };

    function toggleLeadSourceEdit() {
      leadSourceEditMode = !leadSourceEditMode;

      const displayEl = document.getElementById('leadSourceDisplay');
      const editEl = document.getElementById('leadSourceEdit');
      const toggleBtn = document.getElementById('toggleLeadSourceBtn');

      if (leadSourceEditMode) {
        displayEl.classList.add('hidden');
        editEl.classList.remove('hidden');
        toggleBtn.textContent = 'Cancel';

        // Restore current values if any
        if (leadSourceData.source) {
          selectLeadSource(leadSourceData.source, false);
        }
        if (leadSourceData.category) {
          selectLeadCategory(leadSourceData.category, false);
        }
        if (leadSourceData.campaignName) {
          document.getElementById('leadCampaignName').value = leadSourceData.campaignName;
        }
        if (leadSourceData.adName) {
          document.getElementById('leadAdName').value = leadSourceData.adName;
        }
        if (leadSourceData.customSource) {
          document.getElementById('customSourceName').value = leadSourceData.customSource;
        }
      } else {
        displayEl.classList.remove('hidden');
        editEl.classList.add('hidden');
        toggleBtn.textContent = 'Edit';
      }
    }

    function selectLeadSource(source, clearOthers = true) {
      // Update buttons
      document.querySelectorAll('.lead-source-btn').forEach(btn => {
        btn.classList.remove('selected');
      });

      const selectedBtn = document.querySelector(`.lead-source-btn[data-source="${source}"]`);
      if (selectedBtn) {
        selectedBtn.classList.add('selected');
      }

      leadSourceData.source = source;

      // Show/hide custom source input
      const customInput = document.getElementById('customSourceInput');
      if (source === 'other') {
        customInput.classList.remove('hidden');
        document.getElementById('customSourceName').focus();
      } else {
        customInput.classList.add('hidden');
        leadSourceData.customSource = null;
      }
    }

    function selectLeadCategory(category, clearOthers = true) {
      // Update chips
      document.querySelectorAll('.lead-category-chip').forEach(chip => {
        chip.classList.remove('selected');
      });

      const selectedChip = document.querySelector(`.lead-category-chip[data-category="${category}"]`);
      if (selectedChip) {
        selectedChip.classList.add('selected');
      }

      leadSourceData.category = category;
    }

    function saveLeadSource() {
      // Get values
      leadSourceData.campaignName = document.getElementById('leadCampaignName').value.trim() || null;
      leadSourceData.adName = document.getElementById('leadAdName').value.trim() || null;

      if (leadSourceData.source === 'other') {
        leadSourceData.customSource = document.getElementById('customSourceName').value.trim() || null;
      }

      // Validate
      if (!leadSourceData.source) {
        alert('Please select a lead source');
        return;
      }

      // Update display
      updateLeadSourceDisplay();

      // Save to current queue item if applicable
      if (currentQueueIndex >= 0 && currentQueueIndex < callQueue.length) {
        callQueue[currentQueueIndex].leadSource = { ...leadSourceData };
        saveQueueToStorage();
      }

      // Exit edit mode
      toggleLeadSourceEdit();

      // Send to server if in a call
      if (currentCallSid) {
        sendLeadSourceToServer();
      }
    }

    function cancelLeadSourceEdit() {
      // Just toggle back without saving
      leadSourceEditMode = true; // Will be toggled to false
      toggleLeadSourceEdit();
    }

    function updateLeadSourceDisplay() {
      const summaryEl = document.getElementById('leadSourceSummary');

      if (!leadSourceData.source) {
        summaryEl.innerHTML = `
          <span class="source-icon">‚ùì</span>
          <div class="source-info">
            <div class="source-name">Not set</div>
            <div class="source-category">Click edit to set lead source</div>
          </div>
        `;
        return;
      }

      const config = sourceConfig[leadSourceData.source];
      const sourceName = leadSourceData.source === 'other' && leadSourceData.customSource
        ? leadSourceData.customSource
        : config.label;

      let categoryText = '';
      if (leadSourceData.category) {
        categoryText = categoryLabels[leadSourceData.category] || leadSourceData.category;
      }

      let campaignText = '';
      if (leadSourceData.campaignName) {
        campaignText = leadSourceData.campaignName;
        if (leadSourceData.adName) {
          campaignText += ` / ${leadSourceData.adName}`;
        }
      }

      summaryEl.innerHTML = `
        <span class="source-icon">${config.icon}</span>
        <div class="source-info">
          <div class="source-name">${sourceName}</div>
          ${categoryText ? `<div class="source-category">${categoryText}</div>` : ''}
          ${campaignText ? `<div class="source-campaign">${campaignText}</div>` : ''}
        </div>
      `;
    }

    function resetLeadSource() {
      leadSourceData = {
        source: null,
        customSource: null,
        category: null,
        campaignName: null,
        adName: null
      };

      // Reset UI
      document.querySelectorAll('.lead-source-btn').forEach(btn => btn.classList.remove('selected'));
      document.querySelectorAll('.lead-category-chip').forEach(chip => chip.classList.remove('selected'));
      document.getElementById('leadCampaignName').value = '';
      document.getElementById('leadAdName').value = '';
      document.getElementById('customSourceName').value = '';
      document.getElementById('customSourceInput').classList.add('hidden');

      updateLeadSourceDisplay();

      // Make sure we're in display mode
      if (leadSourceEditMode) {
        leadSourceEditMode = false;
        document.getElementById('leadSourceDisplay').classList.remove('hidden');
        document.getElementById('leadSourceEdit').classList.add('hidden');
        document.getElementById('toggleLeadSourceBtn').textContent = 'Edit';
      }
    }

    function loadLeadSourceForQueueItem(queueItem) {
      if (queueItem && queueItem.leadSource) {
        leadSourceData = { ...queueItem.leadSource };
        updateLeadSourceDisplay();
      } else {
        resetLeadSource();
      }
    }

    async function sendLeadSourceToServer() {
      if (!currentCallSid || !leadSourceData.source) return;

      // Update contact with lead source if not already set
      // Security: Filter by both id AND company_id to ensure ownership
      if (currentContactId && companyId) {
        try {
          await supabase
            .from('contacts')
            .update({
              lead_source: leadSourceData.source,
              updated_at: new Date().toISOString()
            })
            .eq('id', currentContactId)
            .eq('company_id', companyId)
            .is('lead_source', null);  // Only update if not already set
        } catch (error) {
          console.log('Could not update contact lead source:', error);
        }
      }

      // Also send to original API endpoint for backwards compatibility
      try {
        await fetch('/api/call-lead-source', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            callSid: currentCallSid,
            leadSource: leadSourceData
          })
        });
      } catch (error) {
        console.log('Could not save lead source to server:', error);
      }
    }

    // ==========================================
    // END LEAD SOURCE FUNCTIONS
    // ==========================================

    // ==========================================
    // SIDEBAR FUNCTIONS
    // ==========================================

    let sidebarCollapsed = false;

    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      sidebarCollapsed = !sidebarCollapsed;
      sidebar.classList.toggle('collapsed', sidebarCollapsed);
      localStorage.setItem('sidebarCollapsed', sidebarCollapsed);
    }

    function openSidebar() {
      document.getElementById('sidebar').classList.add('mobile-open');
      document.getElementById('sidebarOverlay').classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function closeSidebar() {
      document.getElementById('sidebar').classList.remove('mobile-open');
      document.getElementById('sidebarOverlay').classList.remove('active');
      document.body.style.overflow = '';
    }

    // Mobile call screen functions
    function showMobileCallScreen() {
      if (window.innerWidth <= 768) {
        const phoneInput = document.getElementById('phoneInput');
        document.getElementById('mobileCallNumber').textContent = formatPhoneNumber(phoneInput.value);
        document.getElementById('mobileCallScreen').classList.add('active');
      }
    }

    function minimizeMobileCall() {
      document.getElementById('mobileCallScreen').classList.remove('active');
    }

    function endMobileCall() {
      endCall();
      document.getElementById('mobileCallScreen').classList.remove('active');
    }

    function toggleMobileMute(btn) {
      btn.classList.toggle('active');
      toggleMute();
    }

    function toggleMobileHold(btn) {
      btn.classList.toggle('active');
      toggleHold();
    }

    function showMobileKeypad() {
      // Show keypad overlay
    }

    function updateMobileCallTimer() {
      const mobileTimer = document.getElementById('mobileCallTimer');
      const desktopTimer = document.getElementById('callTimer');
      if (mobileTimer && desktopTimer) {
        mobileTimer.textContent = desktopTimer.textContent;
      }
    }

    // Initialize
    async function init() {
      // Initialize page with auth check
      await initPage({
        requireAuth: true,
        onReady: async (user) => {
          currentUser = user;

          // Get company membership
          const { companyId: cId, error } = await getCompanyMembership();
          if (error) {
            console.error('Failed to get company membership:', error);
            showError('#main', 'Failed to load user data. Please refresh.');
            return;
          }
          companyId = cId;

          // Continue with original initialization
          await initializeCallPage();
        },
        onError: (error) => {
          console.error('Page initialization failed:', error);
        }
      });
    }

    async function initializeCallPage() {
      // Restore sidebar state
      const savedCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
      if (savedCollapsed && window.innerWidth > 1024) {
        sidebarCollapsed = true;
        document.getElementById('sidebar').classList.add('collapsed');
      }

      // Restore call mode preference
      const savedMode = localStorage.getItem('callMode') || 'basic';
      document.getElementById('callModeSelect').value = savedMode;
      advancedModeEnabled = savedMode === 'advanced' || savedMode === 'twilio-realtime';

      // Set up Call Mode selector listener
      setupCallModeSelector();

      // Load and set up knowledge bases
      await loadKnowledgeBases();
      setupKnowledgeBaseSelector();

      // Initialize based on mode
      if (advancedModeEnabled) {
        connectWebSocket();
      } else {
        updateAdvancedModeStatus('basic');
      }

      await initializeTwilioDevice();
      setupEventListeners();
      setupQueueEventListeners();
      checkUrlParams();
      loadQueueFromStorage();
      loadImportedContacts();

      // Initialize session tracker for time tracking
      await sessionTracker.init();
    }

    function setupCallModeSelector() {
      const select = document.getElementById('callModeSelect');

      select.addEventListener('change', (e) => {
        const selectedMode = e.target.value;
        advancedModeEnabled = selectedMode === 'advanced' || selectedMode === 'twilio-realtime';
        localStorage.setItem('callMode', selectedMode);

        if (advancedModeEnabled) {
          // Enable advanced mode
          fallbackToBasicMode = false;
          wsReconnectAttempts = 0;
          wsLastConnectedTime = null;
          connectWebSocket();
          showNotification('Advanced Mode enabled. Live transcription and AI coaching will be available.', 'info');
        } else {
          // Disable advanced mode
          disconnectWebSocket();
          updateAdvancedModeStatus('basic');
          showNotification('Basic Mode enabled. Calls will still be recorded with post-call analysis.', 'info');
        }
      });
    }

    // Load knowledge bases from API
    async function loadKnowledgeBases() {
      try {
        const response = await fetch('/api/knowledge-bases');
        const result = await response.json();

        if (result.success && result.knowledgeBases) {
          knowledgeBases = result.knowledgeBases;
          const select = document.getElementById('knowledgeBaseSelect');

          // Clear existing options and populate with real data
          select.innerHTML = knowledgeBases.map(kb =>
            `<option value="${kb.id}" ${kb.is_default ? 'selected' : ''}>${kb.name}</option>`
          ).join('');

          // Set the selected knowledge base ID
          const defaultKB = knowledgeBases.find(kb => kb.is_default) || knowledgeBases[0];
          if (defaultKB) {
            selectedKnowledgeBaseId = defaultKB.id;
            localStorage.setItem('selectedKnowledgeBaseId', selectedKnowledgeBaseId);
          }

          console.log('Knowledge bases loaded:', knowledgeBases.length);
        }
      } catch (error) {
        console.error('Failed to load knowledge bases:', error);
      }
    }

    // Set up knowledge base selector event listener
    function setupKnowledgeBaseSelector() {
      const select = document.getElementById('knowledgeBaseSelect');

      select.addEventListener('change', (e) => {
        selectedKnowledgeBaseId = e.target.value;
        localStorage.setItem('selectedKnowledgeBaseId', selectedKnowledgeBaseId);

        const selectedKB = knowledgeBases.find(kb => kb.id === selectedKnowledgeBaseId);
        console.log('Knowledge base changed to:', selectedKB?.name);

        // Notify server via WebSocket if connected
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'set_knowledge_base',
            knowledgeBaseId: selectedKnowledgeBaseId,
            callSid: currentCallSid
          }));
        }
      });

      // Restore saved selection
      const savedKBId = localStorage.getItem('selectedKnowledgeBaseId');
      if (savedKBId) {
        selectedKnowledgeBaseId = savedKBId;
        select.value = savedKBId;
      }
    }

    function setupQueueEventListeners() {
      // Auto-dial toggle is handled by inline onchange="handleAutoDialToggle(this.checked)"
      // which properly handles the delay setting

      // Enter key to add to queue
      document.getElementById('queuePhoneInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          addToQueue();
        }
      });

      // Save queue to localStorage on changes
      const originalRenderQueue = renderQueue;
      // Already handles this in addToQueue/removeFromQueue
    }

    function loadQueueFromStorage() {
      try {
        const saved = localStorage.getItem('callQueue');
        if (saved) {
          callQueue = JSON.parse(saved);
          // Reset any "calling" status to pending
          callQueue.forEach(item => {
            if (item.status === 'calling') {
              item.status = 'pending';
            }
          });
          renderQueue();
          updateQueueStats();
        }
      } catch (e) {
        console.log('Could not load queue from storage');
      }
    }

    // Load contacts imported from contacts page via URL params
    function loadImportedContacts() {
      try {
        const params = new URLSearchParams(window.location.search);
        const importData = params.get('import');
        if (!importData) return;

        const entries = decodeURIComponent(importData).split(',');
        let addedCount = 0;

        entries.forEach(entry => {
          const [phone, name] = entry.split('|');
          if (phone && !callQueue.some(item => item.number === phone && item.status === 'pending')) {
            callQueue.push({
              id: Date.now() + Math.random(),
              number: phone,
              displayNumber: formatPhoneNumber(phone),
              name: name || null,
              status: 'pending',
              outcome: null,
              addedAt: new Date()
            });
            addedCount++;
          }
        });

        if (addedCount > 0) {
          renderQueue();
          updateQueueStats();
          saveQueueToStorage();
          showNotification(`Added ${addedCount} contacts to your call queue`, 'success');
        }

        // Clear URL params to prevent re-import on refresh
        window.history.replaceState({}, document.title, '/call.html');

      } catch (e) {
        console.error('Error loading imported contacts:', e);
      }
    }

    function saveQueueToStorage() {
      try {
        localStorage.setItem('callQueue', JSON.stringify(callQueue));
      } catch (e) {
        console.log('Could not save queue to storage');
      }
    }

    // WebSocket Connection with Reconnection Logic
    async function connectWebSocket() {
      if (!advancedModeEnabled) {
        console.log('Advanced mode disabled, skipping WebSocket connection');
        return;
      }

      // Security: Get auth token for WebSocket connection
      const { data: { session } } = await supabase.auth.getSession();
      if (!session || !session.access_token) {
        console.error('No auth session for WebSocket connection');
        handleFallbackToBasicMode('Authentication required for live transcription');
        return;
      }

      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/browser?role=rep&identity=${repIdentity}&token=${encodeURIComponent(session.access_token)}`;

      console.log('Connecting to WebSocket with auth token');

      try {
        ws = new WebSocket(wsUrl);
      } catch (error) {
        console.error('WebSocket construction failed:', error);
        handleWebSocketError(error);
        return;
      }

      ws.onopen = () => {
        console.log('Connected to server (Advanced Mode)');
        wsReconnectAttempts = 0;
        wsReconnectDelay = 2000;
        wsLastConnectedTime = Date.now();
        advancedModeActive = true;
        fallbackToBasicMode = false;
        updateConnectionStatus(true);
        updateAdvancedModeStatus('connected');
        hideReconnectingOverlay();

        // Send current knowledge base selection to server
        if (selectedKnowledgeBaseId) {
          ws.send(JSON.stringify({
            type: 'set_knowledge_base',
            knowledgeBaseId: selectedKnowledgeBaseId,
            callSid: currentCallSid
          }));
        }
      };

      ws.onclose = (event) => {
        console.log('WebSocket closed:', event.code, event.reason);
        advancedModeActive = false;
        updateConnectionStatus(false);

        // Only attempt reconnect if advanced mode is still enabled
        if (advancedModeEnabled && !fallbackToBasicMode) {
          attemptReconnect();
        }
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        handleWebSocketError(error);
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleWebSocketMessage(data);
        } catch (e) {
          console.error('Failed to parse WebSocket message:', e);
        }
      };
    }

    function attemptReconnect() {
      if (wsReconnectAttempts >= wsMaxReconnectAttempts) {
        console.log('Max reconnection attempts reached, falling back to basic mode');
        handleFallbackToBasicMode('Connection failed after multiple attempts');
        return;
      }

      wsReconnectAttempts++;
      const delay = Math.min(wsReconnectDelay * Math.pow(1.5, wsReconnectAttempts - 1), 30000);

      console.log(`Reconnect attempt ${wsReconnectAttempts}/${wsMaxReconnectAttempts} in ${delay}ms`);

      showReconnectingOverlay(wsReconnectAttempts, wsMaxReconnectAttempts);
      updateAdvancedModeStatus('reconnecting');

      wsReconnectTimer = setTimeout(() => {
        connectWebSocket();
      }, delay);
    }

    function handleWebSocketError(error) {
      console.error('WebSocket error handler:', error);
      updateAdvancedModeStatus('error');

      // If we've never successfully connected and this is the first attempt,
      // fall back immediately
      if (!wsLastConnectedTime && wsReconnectAttempts === 0) {
        handleFallbackToBasicMode('Could not establish connection to live transcription service');
      }
    }

    function handleFallbackToBasicMode(reason) {
      console.log('Falling back to Basic Mode:', reason);
      fallbackToBasicMode = true;
      advancedModeActive = false;

      // Clear any pending reconnect
      if (wsReconnectTimer) {
        clearTimeout(wsReconnectTimer);
        wsReconnectTimer = null;
      }

      // Close websocket if open
      if (ws && ws.readyState !== WebSocket.CLOSED) {
        ws.close();
      }

      // Update UI
      updateAdvancedModeStatus('fallback');
      hideReconnectingOverlay();

      // Show notification
      showNotification(`Switched to Basic Mode: ${reason}. Call recording and post-call analysis still available.`, 'warning');

      // Update mode selector
      document.getElementById('callModeSelect').value = 'basic';
      advancedModeEnabled = false;
      localStorage.setItem('callMode', 'basic');
    }

    function cancelReconnect() {
      handleFallbackToBasicMode('User cancelled reconnection');
    }

    function showReconnectingOverlay(attempt, maxAttempts) {
      const overlay = document.getElementById('reconnectingOverlay');
      const message = document.getElementById('reconnectingMessage');
      message.textContent = `Attempt ${attempt} of ${maxAttempts}. Please wait...`;
      overlay.classList.remove('hidden');
    }

    function hideReconnectingOverlay() {
      document.getElementById('reconnectingOverlay').classList.add('hidden');
    }

    function updateAdvancedModeStatus(status) {
      const modeStatus = document.getElementById('callModeStatus');
      const modeIndicator = document.getElementById('modeIndicator');
      const modeText = document.getElementById('modeText');

      // Remove all status classes
      modeStatus.classList.remove('basic', 'advanced', 'error');
      modeIndicator.classList.remove('active', 'error');

      switch (status) {
        case 'connected':
          modeStatus.classList.add('advanced');
          modeIndicator.classList.add('active');
          modeText.textContent = 'Advanced (Live AI)';
          break;
        case 'reconnecting':
          modeStatus.classList.add('error');
          modeText.textContent = 'Reconnecting...';
          break;
        case 'error':
          modeStatus.classList.add('error');
          modeIndicator.classList.add('error');
          modeText.textContent = 'Connection Error';
          break;
        case 'fallback':
        case 'basic':
        default:
          modeStatus.classList.add('basic');
          modeText.textContent = 'Basic';
          break;
      }
    }

    function showNotification(message, type = 'info') {
      // Simple notification - could be enhanced with a toast library
      const notification = document.createElement('div');
      notification.className = `notification notification-${type}`;
      notification.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        padding: 12px 20px;
        background: ${type === 'warning' ? 'var(--warning)' : type === 'error' ? 'var(--danger)' : 'var(--primary)'};
        color: ${type === 'warning' ? 'var(--gray-900)' : 'white'};
        border-radius: var(--radius-md);
        z-index: 10000;
        max-width: 350px;
        font-size: 0.875rem;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      `;
      notification.textContent = message;
      document.body.appendChild(notification);

      setTimeout(() => {
        notification.remove();
      }, 5000);
    }

    function disconnectWebSocket() {
      if (wsReconnectTimer) {
        clearTimeout(wsReconnectTimer);
        wsReconnectTimer = null;
      }
      if (ws) {
        ws.close();
        ws = null;
      }
      advancedModeActive = false;
      wsReconnectAttempts = 0;
    }

    function handleWebSocketMessage(data) {
      switch (data.type) {
        case 'transcript':
          // Only show final transcripts to avoid fragmented one-word display
          if (data.isFinal) {
            addTranscriptMessage(data.speaker || 'customer', data.text, data.timestamp);
          } else {
            // Show interim results as a typing indicator (optional visual feedback)
            showInterimTranscript(data.speaker || 'customer', data.text);
          }
          break;
        case 'ai_coaching':
          if (data.type === 'script') {
            showScriptCard(data);
          } else {
            showAICoaching(data.suggestion);
          }
          break;
        case 'speaking_started':
          showSpeakingIndicator(data.speaker);
          break;
        case 'speaking_stopped':
          hideSpeakingIndicator();
          break;
        case 'transcription_status':
          handleTranscriptionStatus(data);
          break;
        case 'call_started':
          console.log('Call started:', data.callSid);
          currentCallSid = data.callSid;
          break;
        case 'call_ended':
          console.log('Call ended:', data.callSid);
          break;
      }
    }

    // Handle transcription status updates from server
    function handleTranscriptionStatus(data) {
      const transcriptStatus = document.getElementById('transcriptStatus');

      switch (data.status) {
        case 'active':
          transcriptStatus.textContent = 'Live Transcription';
          transcriptStatus.className = 'badge badge-success';
          if (data.message && data.message.includes('reconnected')) {
            showNotification('Live transcription restored', 'info');
          }
          break;

        case 'reconnecting':
          transcriptStatus.textContent = `Reconnecting (${data.attempt}/${data.maxAttempts})`;
          transcriptStatus.className = 'badge badge-warning';
          break;

        case 'error':
          transcriptStatus.textContent = 'Transcription Issue';
          transcriptStatus.className = 'badge badge-warning';
          break;

        case 'failed':
          transcriptStatus.textContent = 'Recording Only';
          transcriptStatus.className = 'badge badge-secondary';
          showNotification(data.message || 'Live transcription unavailable. Call recording continues.', 'warning');

          // Update mode status to show degraded state
          const modeStatus = document.getElementById('callModeStatus');
          modeStatus.classList.remove('advanced');
          modeStatus.classList.add('error');
          document.getElementById('modeText').textContent = 'Degraded';
          break;
      }
    }

    // Twilio Device
    async function initializeTwilioDevice() {
      try {
        console.log('Fetching Twilio token for identity:', repIdentity);
        const response = await fetch(`/token?identity=${repIdentity}`);
        const data = await response.json();
        console.log('Token received, initializing device...');

        device = new Twilio.Device(data.token, {
          codecPreferences: ['opus', 'pcmu'],
          logLevel: 1 // Enable debug logging
        });

        device.on('registered', () => {
          console.log('Twilio device registered and ready');
          updateConnectionStatus('connected');
          populateAudioDevices();
        });

        device.on('unregistered', () => {
          console.log('Twilio device unregistered');
          updateConnectionStatus('disconnected');
        });

        device.on('error', (error) => {
          console.error('Twilio device error:', error.message || error);
          updateConnectionStatus('disconnected');
        });

        device.on('incoming', handleIncomingCall);

        // Register the device to receive calls
        console.log('Registering Twilio device...');
        await device.register();
        console.log('Device registration complete');

      } catch (error) {
        console.error('Failed to initialize Twilio:', error);
        updateConnectionStatus('disconnected');
      }
    }

    function updateConnectionStatus(status) {
      const statusEl = document.getElementById('connectionStatus');
      if (!statusEl) return;

      if (status === 'connected') {
        statusEl.className = 'connection-status connected';
        statusEl.innerHTML = '<span class="connection-dot"></span><span class="desktop-only">Connected</span>';
      } else {
        statusEl.className = 'connection-status disconnected';
        statusEl.innerHTML = '<span class="connection-dot"></span><span class="desktop-only">Disconnected</span>';
      }
    }

    async function populateAudioDevices() {
      const select = document.getElementById('audioDevice');
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioOutputs = devices.filter(d => d.kind === 'audiooutput');

        select.innerHTML = audioOutputs.map(d =>
          `<option value="${d.deviceId}">${d.label || 'Speaker ' + d.deviceId.slice(0, 4)}</option>`
        ).join('');

        select.onchange = () => {
          if (device && device.audio) {
            device.audio.speakerDevices.set(select.value);
          }
        };
      } catch (error) {
        select.innerHTML = '<option>Default Speaker</option>';
      }
    }

    // Call Handling
    async function makeCall() {
      if (!device) {
        alert('Phone system not ready. Please wait and try again.');
        return;
      }

      const phoneInput = document.getElementById('phoneInput');
      let number = phoneInput.value.replace(/\D/g, '');

      if (number.length < 10) {
        alert('Please enter a valid phone number');
        return;
      }

      if (number.length === 10) {
        number = '+1' + number;
      } else if (!number.startsWith('+')) {
        number = '+' + number;
      }

      document.getElementById('phoneNumber').textContent = formatPhoneNumber(number);

      // Pass call mode to server - 'basic', 'advanced', or 'twilio-realtime'
      const callMode = document.getElementById('callModeSelect').value;
      const params = {
        To: number,
        CallMode: callMode
      };

      console.log(`Making call in ${callMode} mode to ${number}`);
      updateCallState('Connecting...');
      showCallUI();

      try {
        // New SDK: connect returns a Call object via Promise
        connection = await device.connect({ params });

        // Get the CallSid immediately after connect
        currentCallSid = connection.parameters?.CallSid;
        console.log('Call initiated with SID:', currentCallSid);

        // Create call record immediately when call is initiated
        await createCallRecord(number);

        // Track call start for session tracking (auto-starts session if needed)
        await sessionTracker.onCallStarted();

        // Attach event handlers to the call
        connection.on('accept', () => {
          console.log('Call accept event fired');
          handleCallConnected(connection);
        });

        connection.on('disconnect', () => {
          handleCallDisconnected();
        });

        connection.on('error', (error) => {
          console.error('Call error:', error);
          // Log the error but don't block the UI with an alert
          // The call may still work despite some errors
          showNotification('Call issue: ' + (error.message || error), 'warning');
        });

        connection.on('cancel', () => {
          console.log('Call was cancelled');
          updateCallState('Cancelled');
          hideCallUI();
        });

        connection.on('reject', () => {
          console.log('Call was rejected');
          updateCallState('Rejected');
          hideCallUI();
        });

      } catch (error) {
        console.error('Failed to make call:', error);
        showNotification('Failed to connect call: ' + (error.message || error), 'error');
        hideCallUI();
      }

      // Update transcript panel based on mode
      if (callMode === 'basic') {
        document.getElementById('transcriptStatus').textContent = 'Post-call transcript';
        document.getElementById('transcriptStatus').className = 'badge badge-info';
        document.getElementById('transcriptContainer').innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üìù</div>
            <div class="empty-state-title">Basic Mode Active</div>
            <div class="empty-state-text">
              Transcript and AI analysis will be available after the call ends.
              <br><br>
              <small style="color: var(--gray-500);">
                Switch to Advanced Mode for live transcription and real-time AI coaching.
              </small>
            </div>
          </div>
        `;
      }
    }

    // Incoming call ringtone
    let ringtoneAudio = null;
    let pendingIncomingCall = null;

    function playRingtone() {
      // Create a pleasant two-tone ringtone using Web Audio API
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const gainNode = audioContext.createGain();
        gainNode.connect(audioContext.destination);
        gainNode.gain.value = 0;

        // Create two oscillators for a classic phone ring
        const osc1 = audioContext.createOscillator();
        const osc2 = audioContext.createOscillator();

        osc1.type = 'sine';
        osc2.type = 'sine';
        osc1.frequency.value = 440; // A4
        osc2.frequency.value = 480; // B4 (creates a pleasing interval)

        const mixer = audioContext.createGain();
        mixer.gain.value = 0.15;

        osc1.connect(mixer);
        osc2.connect(mixer);
        mixer.connect(gainNode);

        osc1.start();
        osc2.start();

        // Ring pattern: ring 1s, pause 2s (like a real phone)
        let isRinging = true;
        gainNode.gain.value = 1;

        // Use recursive setTimeout for alternating timing
        let ringTimeout;
        const scheduleRing = () => {
          const duration = isRinging ? 1000 : 2000; // Ring for 1s, pause for 2s
          ringTimeout = setTimeout(() => {
            isRinging = !isRinging;
            gainNode.gain.setTargetAtTime(isRinging ? 1 : 0, audioContext.currentTime, 0.02);
            scheduleRing();
          }, duration);
        };
        scheduleRing();

        ringtoneAudio = { osc1, osc2, gainNode, audioContext, ringTimeout };
      } catch (e) {
        console.log('Could not play ringtone:', e);
      }
    }

    function stopRingtone() {
      if (ringtoneAudio) {
        try {
          if (ringtoneAudio.ringTimeout) clearTimeout(ringtoneAudio.ringTimeout);
          if (ringtoneAudio.osc1) ringtoneAudio.osc1.stop();
          if (ringtoneAudio.osc2) ringtoneAudio.osc2.stop();
          ringtoneAudio.audioContext.close();
        } catch (e) {
          // Ignore errors when stopping
        }
        ringtoneAudio = null;
      }
    }

    function showIncomingCallModal(phoneNumber) {
      document.getElementById('incomingCallNumber').textContent = formatPhoneNumber(phoneNumber);
      document.getElementById('incomingCallModal').classList.add('active');
      playRingtone();
    }

    function hideIncomingCallModal() {
      document.getElementById('incomingCallModal').classList.remove('active');
      stopRingtone();
    }

    function answerIncomingCall() {
      hideIncomingCallModal();
      if (pendingIncomingCall) {
        pendingIncomingCall.accept();
        pendingIncomingCall = null;
      }
    }

    async function declineIncomingCall() {
      hideIncomingCallModal();
      if (pendingIncomingCall) {
        // Capture caller info before rejecting
        const callerNumber = pendingIncomingCall.parameters?.From || 'Unknown';

        // Create a call record for the declined call
        await createDeclinedCallRecord(callerNumber);

        pendingIncomingCall.reject();
        pendingIncomingCall = null;
        hideCallUI();
        updateCallState('READY');
      }
    }

    // Create call record for declined/missed incoming calls
    async function createDeclinedCallRecord(phoneNumber) {
      console.log('createDeclinedCallRecord: Logging declined call from:', phoneNumber);

      if (!companyId || !currentUser) {
        console.error('Cannot create declined call record: missing company or user');
        return;
      }

      try {
        // Find or create contact for the caller
        const contact = await findOrCreateContact(phoneNumber);
        const contactId = contact?.id || null;

        const insertData = {
          company_id: companyId,
          rep_id: currentUser.id,
          contact_id: contactId,
          phone_number: phoneNumber,
          direction: 'inbound',
          status: 'missed',  // Mark as missed since it was declined
          outcome: null,
          started_at: new Date().toISOString(),
          ended_at: new Date().toISOString(),
          duration_seconds: 0
        };

        const { data, error } = await supabase
          .from('calls')
          .insert(insertData)
          .select('id')
          .single();

        if (error) {
          console.error('createDeclinedCallRecord: Failed:', error);
        } else {
          console.log('createDeclinedCallRecord: SUCCESS - Declined call logged:', data.id);
        }
      } catch (error) {
        console.error('createDeclinedCallRecord: Exception:', error);
      }
    }

    function handleIncomingCall(call) {
      try {
        console.log('Incoming call received, handling...');
        connection = call;
        pendingIncomingCall = call;
        const from = call.parameters?.From || 'Unknown';

        const phoneNumberEl = document.getElementById('phoneNumber');
        if (phoneNumberEl) {
          phoneNumberEl.textContent = formatPhoneNumber(from);
        }

        updateCallState('Incoming call...');
        showCallUI();

        // Attach event handlers to the incoming call
        call.on('accept', () => {
          handleCallConnected(call);
        });

        call.on('disconnect', () => {
          handleCallDisconnected();
        });

        call.on('cancel', async () => {
          console.log('Incoming call cancelled (caller hung up)');
          try {
            const callerNumber = call.parameters?.From || 'Unknown';
            await createDeclinedCallRecord(callerNumber);
          } catch (err) {
            console.error('Error logging declined call:', err);
          }

          hideIncomingCallModal();
          hideCallUI();
          updateCallState('READY');
          pendingIncomingCall = null;
        });

        // Show the incoming call modal
        showIncomingCallModal(from);
      } catch (error) {
        console.error('Error handling incoming call:', error);
        // Try to show basic notification even if main handler fails
        try {
          alert('Incoming call from: ' + (call.parameters?.From || 'Unknown'));
        } catch (e) {}
      }
    }

    async function handleCallConnected(conn) {
      console.log('Call connected');
      currentCallSid = conn.parameters.CallSid;
      updateCallState('Connected');
      startTimer();

      // Track call connected for session tracking
      await sessionTracker.onCallConnected();

      document.getElementById('transcriptStatus').textContent = 'Recording';
      document.getElementById('transcriptStatus').className = 'badge badge-success';

      // Clear empty state
      document.getElementById('transcriptContainer').innerHTML = '';

      // Show customer info and scripts
      document.getElementById('customerInfoCard').style.display = 'block';
      document.getElementById('scriptsCard').style.display = 'block';

      const phoneNumber = conn.parameters.To || conn.parameters.From;

      // For incoming calls, create the call record now (outbound calls already have one)
      if (!currentCallRecordId) {
        console.log('Creating call record for incoming call from:', phoneNumber);
        await createCallRecordForIncoming(phoneNumber);
      }

      // Load customer history from Supabase
      await loadCustomerHistory(phoneNumber);

      // Update call status to connected
      await updateCallRecord({ status: 'connected' });
    }

    // Create call record specifically for incoming calls
    async function createCallRecordForIncoming(phoneNumber) {
      console.log('createCallRecordForIncoming: Starting with phoneNumber:', phoneNumber);

      if (!companyId || !currentUser) {
        console.error('Cannot create call record: missing company or user', { companyId, userId: currentUser?.id });
        return;
      }

      try {
        // Find or create contact for the caller
        const contact = await findOrCreateContact(phoneNumber);
        currentContactId = contact?.id || null;
        console.log('createCallRecordForIncoming: contact found/created:', currentContactId);

        const insertData = {
          company_id: companyId,
          rep_id: currentUser.id,
          contact_id: currentContactId,
          phone_number: phoneNumber,
          direction: 'inbound',  // Key difference - this is an incoming call
          status: 'in_progress',
          external_call_id: currentCallSid,
          started_at: new Date().toISOString()
        };
        console.log('createCallRecordForIncoming: Inserting:', insertData);

        const { data, error } = await supabase
          .from('calls')
          .insert(insertData)
          .select('id')
          .single();

        if (error) {
          console.error('createCallRecordForIncoming: Failed to create call record:', error);
        } else {
          currentCallRecordId = data.id;
          console.log('createCallRecordForIncoming: SUCCESS - Call record created:', currentCallRecordId);
        }
      } catch (error) {
        console.error('createCallRecordForIncoming: Exception:', error);
      }
    }

    // ===========================================
    // SUPABASE DATA FUNCTIONS
    // ===========================================

    async function createCallRecord(phoneNumber) {
      console.log('createCallRecord: Starting with phoneNumber:', phoneNumber);
      console.log('createCallRecord: companyId:', companyId, 'currentUser:', currentUser?.id);

      if (!companyId || !currentUser) {
        console.error('Cannot create call record: missing company or user', { companyId, userId: currentUser?.id });
        return;
      }

      try {
        // First, try to find or create a contact for this phone number
        const contact = await findOrCreateContact(phoneNumber);
        currentContactId = contact?.id || null;
        console.log('createCallRecord: contact found/created:', currentContactId);

        const insertData = {
          company_id: companyId,
          rep_id: currentUser.id,
          contact_id: currentContactId,
          phone_number: phoneNumber,
          direction: 'outbound',
          status: 'in_progress',
          external_call_id: currentCallSid,
          started_at: new Date().toISOString()
        };
        console.log('createCallRecord: Inserting:', insertData);

        // Create the call record
        const { data, error } = await supabase
          .from('calls')
          .insert(insertData)
          .select('id')
          .single();

        if (error) {
          console.error('createCallRecord: Failed to create call record:', error);
        } else {
          currentCallRecordId = data.id;
          console.log('createCallRecord: SUCCESS - Call record created:', currentCallRecordId);
        }
      } catch (error) {
        console.error('createCallRecord: Exception:', error);
      }
    }

    async function findOrCreateContact(phoneNumber) {
      if (!companyId) return null;

      try {
        // Clean the phone number for searching
        const cleanedPhone = phoneNumber.replace(/\D/g, '');

        // Try to find existing contact
        const { data: existingContacts, error: searchError } = await supabase
          .from('contacts')
          .select('id, first_name, last_name, email, phone, business_name')
          .eq('company_id', companyId)
          .or(`phone.ilike.%${cleanedPhone}%,phone.ilike.%${phoneNumber}%`)
          .limit(1);

        if (searchError) {
          console.error('Error searching for contact:', searchError);
          return null;
        }

        if (existingContacts && existingContacts.length > 0) {
          return existingContacts[0];
        }

        // No existing contact found, create a new one
        const { data: newContact, error: insertError } = await supabase
          .from('contacts')
          .insert({
            company_id: companyId,
            phone: phoneNumber,
            first_name: 'Unknown',
            created_by: currentUser.id,
            lead_source: leadSourceData.source
          })
          .select('id, first_name, last_name, phone')
          .single();

        if (insertError) {
          console.error('Failed to create contact:', insertError);
          return null;
        }

        return newContact;
      } catch (error) {
        console.error('Error in findOrCreateContact:', error);
        return null;
      }
    }

    async function updateCallRecord(updates) {
      if (!currentCallRecordId || !companyId) return;

      try {
        // Security: Filter by both id AND company_id to ensure ownership
        const { error } = await supabase
          .from('calls')
          .update(updates)
          .eq('id', currentCallRecordId)
          .eq('company_id', companyId);

        if (error) {
          console.error('Failed to update call record:', error);
        }
      } catch (error) {
        console.error('Error updating call record:', error);
      }
    }

    async function saveCallbackToSupabase(callbackData) {
      console.log('saveCallbackToSupabase called with:', callbackData);
      console.log('Current state - companyId:', companyId, 'currentUser:', currentUser?.id);

      if (!companyId || !currentUser) {
        console.error('Cannot save callback: Missing companyId or currentUser');
        alert('Unable to save callback: You may need to log in again.');
        return null;
      }

      try {
        const scheduledFor = new Date(`${callbackData.date}T${callbackData.time}`);
        const phoneNumber = document.getElementById('phoneNumber').textContent || document.getElementById('phoneInput').value;

        console.log('Inserting callback with phone:', phoneNumber, 'scheduled for:', scheduledFor);

        const { data, error } = await supabase
          .from('callbacks')
          .insert({
            company_id: companyId,
            assigned_to: currentUser.id,
            contact_id: currentContactId,
            phone_number: phoneNumber,
            scheduled_at: scheduledFor.toISOString(),
            reason: callbackData.reason,
            status: 'pending',
            original_call_id: currentCallRecordId,
            priority: 'normal'
          })
          .select('id')
          .single();

        if (error) {
          console.error('Failed to save callback:', error);
          // Check for common errors
          if (error.code === '42P01') {
            alert('Callback table not found. Please check your database setup.');
          } else if (error.code === '42703') {
            alert('Callback table column mismatch. Please check your database schema.');
          } else {
            alert('Failed to save callback: ' + (error.message || 'Unknown error'));
          }
          return null;
        }

        console.log('Callback saved successfully:', data);
        alert('Callback scheduled successfully!');
        return data;
      } catch (error) {
        console.error('Error saving callback:', error);
        alert('Error saving callback: ' + error.message);
        return null;
      }
    }

    async function handleCallDisconnected() {
      console.log('Call disconnected');
      connection = null; // Clear connection so auto-dial can detect we're not in a call
      stopTimer();
      updateCallState('Call ended');

      // Hide call control buttons since call is over
      document.getElementById('endCallBtn').classList.add('hidden');
      document.getElementById('muteBtn').classList.add('hidden');
      document.getElementById('holdBtn').classList.add('hidden');

      // Calculate call duration
      const duration = callStartTime ? Math.floor((new Date() - callStartTime) / 1000) : 0;

      // Update call record in Supabase with end time and duration
      await updateCallRecord({
        status: 'completed',
        ended_at: new Date().toISOString(),
        duration_seconds: duration
      });

      // Track call ended for session tracking
      await sessionTracker.onCallEnded(currentCallSid);

      // Update status based on call mode
      const wasBasicMode = !advancedModeEnabled || fallbackToBasicMode;

      if (wasBasicMode) {
        document.getElementById('transcriptStatus').textContent = 'Processing transcript...';
        document.getElementById('transcriptStatus').className = 'badge badge-info';

        // Show processing message for Basic Mode
        document.getElementById('transcriptContainer').innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">‚è≥</div>
            <div class="empty-state-title">Processing Call</div>
            <div class="empty-state-text">
              Your call recording is being transcribed.<br>
              AI analysis will be available shortly in your call history.
            </div>
          </div>
        `;

        // After a delay, update to show completion
        setTimeout(() => {
          document.getElementById('transcriptStatus').textContent = 'Transcript pending';
          document.getElementById('transcriptStatus').className = 'badge badge-warning';
        }, 3000);
      } else {
        document.getElementById('transcriptStatus').textContent = 'Call ended';
        document.getElementById('transcriptStatus').className = 'badge badge-warning';
      }

      // Show outcome panel
      document.getElementById('outcomePanel').classList.remove('hidden');
      document.getElementById('dialPadContainer').classList.add('hidden');

      // If auto-dial is enabled and we're in a queue, prepare for next call
      // Note: Auto-dial will continue after outcome is saved (see saveOutcome)
      if (currentQueueIndex >= 0) {
        // The outcome panel will handle marking the current item complete
        // and triggering the next dial
      }
    }

    function endCall() {
      if (connection) {
        connection.disconnect();
      }
    }

    function toggleMute() {
      if (connection) {
        const isMuted = connection.isMuted;
        connection.mute(!isMuted);
        document.getElementById('muteBtn').classList.toggle('active', !isMuted);
      }
    }

    function toggleHold() {
      // Twilio Voice SDK doesn't have native hold - simulate with mute
      // In a production environment, hold would require server-side TwiML
      if (connection) {
        const holdBtn = document.getElementById('holdBtn');
        const isOnHold = holdBtn.classList.contains('active');

        if (!isOnHold) {
          // Put on hold - mute the call
          connection.mute(true);
          holdBtn.classList.add('active');
          updateCallState('On Hold');
        } else {
          // Resume from hold - unmute
          connection.mute(false);
          holdBtn.classList.remove('active');
          updateCallState('Connected');
          // Also update mute button state
          document.getElementById('muteBtn').classList.remove('active');
        }
      }
    }

    // UI Updates
    function showCallUI() {
      document.getElementById('dialPadContainer').classList.add('hidden');
      document.getElementById('callBtn').classList.add('hidden');
      document.getElementById('muteBtn').classList.remove('hidden');
      document.getElementById('endCallBtn').classList.remove('hidden');
      document.getElementById('holdBtn').classList.remove('hidden');
    }

    function hideCallUI() {
      document.getElementById('dialPadContainer').classList.remove('hidden');
      document.getElementById('callBtn').classList.remove('hidden');
      document.getElementById('muteBtn').classList.add('hidden');
      document.getElementById('endCallBtn').classList.add('hidden');
      document.getElementById('holdBtn').classList.add('hidden');
      document.getElementById('outcomePanel').classList.add('hidden');
    }

    function updateCallState(state) {
      const stateEl = document.getElementById('callState');
      stateEl.textContent = state;
      stateEl.className = 'call-state';

      if (state === 'Connected') {
        stateEl.classList.add('connected');
      } else if (state === 'Connecting...' || state === 'Incoming call...') {
        stateEl.classList.add('ringing');
      }
    }

    function updateConnectionStatus(connected) {
      const statusEl = document.getElementById('connectionStatus');
      const userStatusEl = document.getElementById('userStatus');
      const connectionTextEl = document.getElementById('connectionText');

      if (connected) {
        statusEl.className = 'connection-status connected';
        statusEl.innerHTML = '<span class="connection-dot"></span><span class="desktop-only">Connected</span>';
        if (userStatusEl) userStatusEl.style.color = 'var(--success)';
        if (connectionTextEl) connectionTextEl.textContent = 'Available';
      } else {
        statusEl.className = 'connection-status disconnected';
        statusEl.innerHTML = '<span class="connection-dot"></span><span class="desktop-only">Disconnected</span>';
        if (userStatusEl) userStatusEl.style.color = 'var(--gray-400)';
        if (connectionTextEl) connectionTextEl.textContent = 'Offline';
      }
    }

    // Timer
    function startTimer() {
      callStartTime = new Date();
      timerInterval = setInterval(updateTimer, 1000);
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    function updateTimer() {
      if (!callStartTime) return;
      const elapsed = Math.floor((new Date() - callStartTime) / 1000);
      const mins = Math.floor(elapsed / 60);
      const secs = elapsed % 60;
      document.getElementById('callTimer').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Transcript
    function addTranscriptMessage(speaker, text, timestamp) {
      const container = document.getElementById('transcriptContainer');

      // Remove empty state if present
      const emptyState = container.querySelector('.empty-state');
      if (emptyState) emptyState.remove();

      // Remove any interim indicator when adding final message
      const interimIndicator = container.querySelector('.interim-transcript');
      if (interimIndicator) interimIndicator.remove();

      const speakerLabel = speaker === 'rep' ? 'You' : 'Customer';
      const messageDiv = document.createElement('div');
      messageDiv.className = `transcript-message ${speaker === 'rep' ? 'rep' : 'customer'}`;
      messageDiv.innerHTML = `
        <div class="speaker-label">${speakerLabel}</div>
        ${text}
        <div class="transcript-time">${formatTime(timestamp)}</div>
      `;

      container.appendChild(messageDiv);
      container.scrollTop = container.scrollHeight;
    }

    // Show interim transcript as a typing indicator (updates in place)
    function showInterimTranscript(speaker, text) {
      const container = document.getElementById('transcriptContainer');

      // Remove empty state if present
      const emptyState = container.querySelector('.empty-state');
      if (emptyState) emptyState.remove();

      // Find or create interim indicator
      let interimIndicator = container.querySelector('.interim-transcript');
      if (!interimIndicator) {
        interimIndicator = document.createElement('div');
        interimIndicator.className = `transcript-message interim-transcript ${speaker === 'rep' ? 'rep' : 'customer'}`;
        interimIndicator.style.opacity = '0.6';
        interimIndicator.style.fontStyle = 'italic';
        container.appendChild(interimIndicator);
      }

      // Update the interim text
      interimIndicator.className = `transcript-message interim-transcript ${speaker === 'rep' ? 'rep' : 'customer'}`;
      interimIndicator.innerHTML = `${text} <span style="color: var(--gray-400);">...</span>`;
      container.scrollTop = container.scrollHeight;
    }

    function showSpeakingIndicator(speaker) {
      const indicator = document.getElementById('speakingIndicator');
      const text = document.getElementById('speakingText');
      text.textContent = speaker === 'customer' ? 'Customer is speaking...' : 'You are speaking...';
      indicator.classList.remove('hidden');
    }

    function hideSpeakingIndicator() {
      document.getElementById('speakingIndicator').classList.add('hidden');
    }

    // AI Coaching Panel Functions
    function addAICoachingTip(type, text, script = null) {
      const container = document.getElementById('aiCoachingContent');

      // Remove empty state if present
      const emptyState = container.querySelector('.ai-empty-state');
      if (emptyState) emptyState.remove();

      // Determine tip category and icon
      const typeConfig = {
        suggestion: { icon: 'üí°', label: 'Suggestion' },
        objection: { icon: '‚ö†Ô∏è', label: 'Objection Detected' },
        success: { icon: '‚úì', label: 'Good Job' },
        signal: { icon: 'üìä', label: 'Buying Signal' }
      };

      const config = typeConfig[type] || typeConfig.suggestion;

      const tipDiv = document.createElement('div');
      tipDiv.className = `ai-tip-card ${type}`;
      tipDiv.innerHTML = `
        <div class="ai-tip-header">${config.icon} ${config.label}</div>
        <div class="ai-tip-text">${text}</div>
        ${script ? `<div class="ai-tip-script">"${script}"</div>` : ''}
      `;

      // Add to top of container (newest first)
      container.insertBefore(tipDiv, container.firstChild);

      // Keep only last 10 tips to prevent overflow
      const tips = container.querySelectorAll('.ai-tip-card');
      if (tips.length > 10) {
        tips[tips.length - 1].remove();
      }
    }

    // Legacy function for backwards compatibility
    function showAICoaching(suggestion) {
      // Determine type based on content
      let type = 'suggestion';
      if (suggestion.toLowerCase().includes('objection') || suggestion.toLowerCase().includes('expensive') || suggestion.toLowerCase().includes('too much')) {
        type = 'objection';
      } else if (suggestion.toLowerCase().includes('good') || suggestion.toLowerCase().includes('great') || suggestion.toLowerCase().includes('nice')) {
        type = 'success';
      } else if (suggestion.toLowerCase().includes('interest') || suggestion.toLowerCase().includes('signal') || suggestion.toLowerCase().includes('buying')) {
        type = 'signal';
      }

      addAICoachingTip(type, suggestion);
    }

    function clearAICoachingPanel() {
      const container = document.getElementById('aiCoachingContent');
      container.innerHTML = `
        <div class="ai-empty-state" id="aiEmptyState">
          <div class="ai-empty-icon">üí°</div>
          <div class="ai-empty-title">AI Coach Ready</div>
          <div class="ai-empty-text">Start a call to receive real-time coaching tips and objection handling suggestions.</div>
        </div>
      `;
    }

    // Show a script card from the knowledge base
    function showScriptCard(data) {
      const container = document.getElementById('aiCoachingContent');

      // Remove empty state if present
      const emptyState = container.querySelector('.ai-empty-state');
      if (emptyState) emptyState.remove();

      // Category icons and labels
      const categoryConfig = {
        objection: { icon: 'üõ°Ô∏è', label: 'Objection Handler', color: 'objection' },
        story: { icon: 'üìñ', label: 'Story', color: 'story' },
        close: { icon: 'üéØ', label: 'Close', color: 'close' },
        opener: { icon: 'üëã', label: 'Opener', color: 'opener' },
        rebuttall: { icon: 'üí¨', label: 'Rebuttal', color: 'objection' }
      };

      const config = categoryConfig[data.category] || categoryConfig.objection;
      const scriptId = data.scriptId;

      const cardDiv = document.createElement('div');
      cardDiv.className = `ai-tip-card script-match ${config.color}`;
      cardDiv.dataset.scriptId = scriptId;
      cardDiv.innerHTML = `
        <div class="script-header">
          <span class="script-category">${config.icon} ${config.label}</span>
          <span class="script-title">${data.title}</span>
        </div>
        <div class="script-body">
          <div class="script-text-box">
            <p class="script-text">${data.scriptText}</p>
            <button class="copy-script-btn" onclick="copyScript(this, '${scriptId}')" title="Copy to clipboard">üìã</button>
          </div>
          ${data.storyText ? `
            <div class="script-story">
              <button class="story-toggle" onclick="toggleStory(this)">üìñ Show Story</button>
              <div class="story-content hidden">
                <p>${data.storyText}</p>
              </div>
            </div>
          ` : ''}
          ${data.tips ? `
            <div class="script-tips">
              <span class="tips-label">üí° Tip:</span> ${data.tips}
            </div>
          ` : ''}
        </div>
        <div class="script-feedback">
          <button class="feedback-btn used" onclick="markScriptUsed('${scriptId}')" title="I used this script">
            ‚úì Used This
          </button>
          <button class="feedback-btn helpful" onclick="markScriptHelpful('${scriptId}', true)" title="Helpful">
            üëç
          </button>
          <button class="feedback-btn not-helpful" onclick="markScriptHelpful('${scriptId}', false)" title="Not helpful">
            üëé
          </button>
        </div>
      `;

      // Add to top of container (newest first)
      container.insertBefore(cardDiv, container.firstChild);

      // Keep only last 8 cards to prevent overflow
      const cards = container.querySelectorAll('.ai-tip-card');
      if (cards.length > 8) {
        cards[cards.length - 1].remove();
      }

      // Animate entrance
      cardDiv.style.animation = 'slideIn 0.3s ease-out';
    }

    // Copy script text to clipboard
    async function copyScript(button, scriptId) {
      const card = button.closest('.ai-tip-card');
      const scriptText = card.querySelector('.script-text').textContent;

      try {
        await navigator.clipboard.writeText(scriptText);
        button.textContent = '‚úì';
        button.classList.add('copied');
        setTimeout(() => {
          button.textContent = 'üìã';
          button.classList.remove('copied');
        }, 2000);
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    }

    // Toggle story visibility
    function toggleStory(button) {
      const storyContent = button.nextElementSibling;
      const isHidden = storyContent.classList.contains('hidden');

      storyContent.classList.toggle('hidden');
      button.textContent = isHidden ? 'üìñ Hide Story' : 'üìñ Show Story';
    }

    // Mark script as used
    async function markScriptUsed(scriptId) {
      try {
        await fetch(`/api/scripts/${scriptId}/used`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ callSid: currentCallSid })
        });

        // Update button state
        const card = document.querySelector(`[data-script-id="${scriptId}"]`);
        if (card) {
          const btn = card.querySelector('.feedback-btn.used');
          btn.classList.add('active');
          btn.textContent = '‚úì Used';
        }

        showNotification('Script marked as used', 'success');
      } catch (error) {
        console.error('Failed to mark script as used:', error);
      }
    }

    // Mark script as helpful or not
    async function markScriptHelpful(scriptId, helpful) {
      try {
        await fetch(`/api/scripts/${scriptId}/feedback`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            callSid: currentCallSid,
            helpful: helpful
          })
        });

        // Update button states
        const card = document.querySelector(`[data-script-id="${scriptId}"]`);
        if (card) {
          const helpfulBtn = card.querySelector('.feedback-btn.helpful');
          const notHelpfulBtn = card.querySelector('.feedback-btn.not-helpful');

          if (helpful) {
            helpfulBtn.classList.add('active');
            notHelpfulBtn.classList.remove('active');
          } else {
            notHelpfulBtn.classList.add('active');
            helpfulBtn.classList.remove('active');
          }
        }
      } catch (error) {
        console.error('Failed to record feedback:', error);
      }
    }

    // Transcript Search
    function searchTranscript(query) {
      const container = document.getElementById('transcriptContainer');
      const messages = container.querySelectorAll('.transcript-message');

      query = query.toLowerCase().trim();

      messages.forEach(msg => {
        if (!query) {
          msg.style.display = '';
          msg.innerHTML = msg.innerHTML.replace(/<mark class="search-highlight">(.*?)<\/mark>/gi, '$1');
        } else {
          const text = msg.textContent.toLowerCase();
          if (text.includes(query)) {
            msg.style.display = '';
            // Highlight matching text
            const regex = new RegExp(`(${query})`, 'gi');
            const originalHTML = msg.innerHTML.replace(/<mark class="search-highlight">(.*?)<\/mark>/gi, '$1');
            msg.innerHTML = originalHTML.replace(regex, '<mark class="search-highlight">$1</mark>');
          } else {
            msg.style.display = 'none';
          }
        }
      });
    }

    // Scripts
    function showScript(scriptId) {
      const script = scripts[scriptId];
      if (!script) return;

      document.getElementById('scriptTitle').textContent = script.title;
      document.getElementById('scriptContent').innerHTML = script.content.replace(/\n/g, '<br>');
      document.getElementById('scriptModal').classList.add('active');
    }

    function closeScriptModal() {
      document.getElementById('scriptModal').classList.remove('active');
    }

    // Customer History
    async function loadCustomerHistory(phoneNumber) {
      if (!companyId) {
        console.log('No company ID, skipping customer history load');
        return;
      }

      if (!phoneNumber) {
        console.log('No phone number provided, skipping customer history load');
        return;
      }

      try {
        // Clean the phone number for searching
        const cleanedPhone = phoneNumber.replace(/\D/g, '');

        // Find contact by phone number
        const { data: contacts, error: contactError } = await supabase
          .from('contacts')
          .select('id, first_name, last_name, email, phone, business_name, tags, lead_source')
          .eq('company_id', companyId)
          .or(`phone.ilike.%${cleanedPhone}%,phone.ilike.%${phoneNumber}%`)
          .limit(1);

        if (contactError) {
          console.error('Error loading contact:', contactError);
          return;
        }

        let history = {
          contact: null,
          calls: [],
          totalCalls: 0,
          lastCall: null,
          lastNote: null
        };

        if (contacts && contacts.length > 0) {
          const contact = contacts[0];
          history.contact = contact;
          currentContactId = contact.id;

          // Update contact info display
          updateContactDisplay(contact);

          // Load call history for this contact
          const { data: calls, error: callsError } = await supabase
            .from('calls')
            .select('id, started_at, duration_seconds, outcome')
            .eq('company_id', companyId)
            .eq('contact_id', contact.id)
            .order('started_at', { ascending: false })
            .limit(10);

          if (!callsError && calls) {
            history.calls = calls.map(c => ({ ...c, duration: c.duration_seconds }));
            history.totalCalls = calls.length;
            if (calls.length > 0) {
              history.lastCall = calls[0].started_at;
              history.lastNote = null; // Notes not stored in calls table
            }
          }
        }

        renderCustomerHistory(history);
      } catch (error) {
        console.error('Error loading customer history:', error);
      }
    }

    function updateContactDisplay(contact) {
      // Update customer name display if we have contact info
      const nameEl = document.getElementById('customerName');
      const businessEl = document.getElementById('customerBusiness');

      if (nameEl && contact) {
        const name = [contact.first_name, contact.last_name].filter(Boolean).join(' ');
        nameEl.textContent = name || 'Unknown Contact';
      }

      if (businessEl && contact?.business_name) {
        businessEl.textContent = contact.business_name;
        businessEl.style.display = 'block';
      }
    }

    function renderCustomerHistory(history) {
      const container = document.getElementById('customerHistory');

      if (!history || history.calls.length === 0) {
        // Show contact info if available even without call history
        if (history?.contact) {
          const contact = history.contact;
          const name = [contact.first_name, contact.last_name].filter(Boolean).join(' ');
          container.innerHTML = `
            <div class="text-sm mb-2">
              <strong>Contact:</strong> ${escapeHtml(name) || 'Unknown'}
            </div>
            ${contact.email ? `
              <div class="text-sm mb-2">
                <strong>Email:</strong> ${escapeHtml(contact.email)}
              </div>
            ` : ''}
            ${contact.business_name ? `
              <div class="text-sm mb-2">
                <strong>Business:</strong> ${escapeHtml(contact.business_name)}
              </div>
            ` : ''}
            <div class="text-sm text-muted">No previous call history</div>
          `;
        } else {
          container.innerHTML = '<div class="text-sm text-muted">No previous history with this customer</div>';
        }
        return;
      }

      const contact = history.contact;
      const name = contact ? [contact.first_name, contact.last_name].filter(Boolean).join(' ') : null;

      container.innerHTML = `
        ${name ? `
          <div class="text-sm mb-2">
            <strong>Contact:</strong> ${escapeHtml(name)}
          </div>
        ` : ''}
        ${contact?.business_name ? `
          <div class="text-sm mb-2">
            <strong>Business:</strong> ${escapeHtml(contact.business_name)}
          </div>
        ` : ''}
        ${contact?.email ? `
          <div class="text-sm mb-2">
            <strong>Email:</strong> ${escapeHtml(contact.email)}
          </div>
        ` : ''}
        <div class="text-sm mb-2">
          <strong>Last call:</strong> ${formatDate(history.lastCall)}
        </div>
        <div class="text-sm mb-2">
          <strong>Total calls:</strong> ${history.totalCalls}
        </div>
        ${history.lastNote ? `
          <div class="text-sm">
            <strong>Previous notes:</strong><br>
            <span class="text-muted">"${escapeHtml(history.lastNote)}"</span>
          </div>
        ` : ''}
      `;
    }

    // Outcome Handling
    function selectOutcome(outcome) {
      selectedOutcome = outcome;

      document.querySelectorAll('.outcome-btn').forEach(btn => {
        btn.classList.remove('selected');
        if (btn.dataset.outcome === outcome) {
          btn.classList.add('selected');
        }
      });

      // Show callback scheduler if callback selected
      const scheduler = document.getElementById('callbackScheduler');
      if (outcome === 'callback') {
        scheduler.classList.remove('hidden');
        // Set default date to tomorrow
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        document.getElementById('callbackDate').value = tomorrow.toISOString().split('T')[0];
        document.getElementById('callbackTime').value = '14:00';
      } else {
        scheduler.classList.add('hidden');
      }
    }

    async function saveOutcome() {
      if (!selectedOutcome) {
        alert('Please select an outcome');
        return;
      }

      const notes = document.getElementById('outcomeNotes').value || document.getElementById('callNotes').value;

      const data = {
        callSid: currentCallSid,
        outcome: selectedOutcome,
        notes: notes
      };

      if (selectedOutcome === 'callback') {
        data.callbackDate = document.getElementById('callbackDate').value;
        data.callbackTime = document.getElementById('callbackTime').value;
        data.callbackReason = document.getElementById('callbackReason').value;
      }

      // Save outcome to Supabase
      try {
        // Update call record with outcome
        await updateCallRecord({
          outcome: selectedOutcome
        });

        // Save notes to call_notes table if provided
        if (notes && notes.trim() && currentCallRecordId && companyId) {
          const { error: notesError } = await supabase
            .from('call_notes')
            .insert({
              call_id: currentCallRecordId,
              contact_id: currentContactId,
              author_id: currentUser.id,
              content: notes.trim(),
              note_type: 'manual'
            });
          if (notesError) {
            console.error('Failed to save notes:', notesError);
          } else {
            console.log('Notes saved successfully');
          }
        }

        // Also save lead source if set
        if (leadSourceData.source) {
          await sendLeadSourceToServer();
        }

        // If callback selected, create callback record in Supabase
        if (selectedOutcome === 'callback' && data.callbackDate && data.callbackTime) {
          await saveCallbackToSupabase({
            date: data.callbackDate,
            time: data.callbackTime,
            reason: data.callbackReason
          });
        }

        // Update contact with last call info
        // Security: Filter by both id AND company_id to ensure ownership
        if (currentContactId && companyId) {
          await supabase
            .from('contacts')
            .update({
              last_call_at: new Date().toISOString(),
              last_call_outcome: selectedOutcome,
              updated_at: new Date().toISOString()
            })
            .eq('id', currentContactId)
            .eq('company_id', companyId);
        }

        console.log('Outcome saved to Supabase');

        // Track booking for session tracking
        if (selectedOutcome === 'booked') {
          sessionTracker.onBooking();
        }

        // Show brief success feedback
        updateCallState('Saved ‚úì');
      } catch (error) {
        console.error('Failed to save outcome to Supabase:', error);
        alert('Warning: Could not save to database. ' + error.message);
      }

      // Also send to original API endpoint for backwards compatibility
      try {
        await fetch('/api/call-outcome', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
      } catch (error) {
        console.error('Failed to save outcome to API:', error);
      }

      // Mark queue item as complete
      markCurrentQueueItemComplete(selectedOutcome);
      saveQueueToStorage();

      // Check if we should auto-dial next
      console.log('Auto-dial check:', { autoDialEnabled, hasPending: callQueue.some(i => i.status === 'pending') });
      if (autoDialEnabled && callQueue.some(i => i.status === 'pending')) {
        // Get delay setting BEFORE resetting UI
        const delay = parseInt(document.getElementById('dialDelay').value) * 1000;
        const delaySeconds = delay / 1000;
        console.log('Auto-dial will continue with delay:', delay);

        // Find next pending contact for display
        const nextContact = callQueue.find(i => i.status === 'pending');

        // Reset UI for next call
        resetForNextCall();

        // Show auto-dial countdown
        if (delay > 0) {
          // Show the countdown overlay
          showCountdown(delaySeconds, nextContact);

          // Clear any existing timeout
          if (autoDialTimeout) {
            clearTimeout(autoDialTimeout);
          }

          autoDialTimeout = setTimeout(() => {
            console.log('Auto-dial timeout fired, calling dialNextInQueue');
            hideCountdown();
            dialNextInQueue();
          }, delay);
        } else {
          // No delay, dial immediately
          dialNextInQueue();
        }
      } else {
        // No auto-dial, go back to dashboard or stay on page
        if (!callQueue.some(i => i.status === 'pending')) {
          // Queue empty, could go to dashboard
          // window.location.href = '/dashboard';
          resetForNextCall();
        } else {
          resetForNextCall();
        }
      }
    }

    function skipOutcome() {
      // Mark as no_answer/skipped if in queue
      if (currentQueueIndex >= 0) {
        markCurrentQueueItemComplete('skipped');
        saveQueueToStorage();
      }

      // Check if we should auto-dial next
      console.log('Skip - Auto-dial check:', { autoDialEnabled, hasPending: callQueue.some(i => i.status === 'pending') });
      if (autoDialEnabled && callQueue.some(i => i.status === 'pending')) {
        const delay = parseInt(document.getElementById('dialDelay').value) * 1000;
        const delaySeconds = delay / 1000;
        console.log('Skip - Auto-dial will continue with delay:', delay);

        // Find next pending contact for display
        const nextContact = callQueue.find(i => i.status === 'pending');

        resetForNextCall();

        if (delay > 0) {
          // Show the countdown overlay
          showCountdown(delaySeconds, nextContact);

          // Clear any existing timeout
          if (autoDialTimeout) {
            clearTimeout(autoDialTimeout);
          }

          autoDialTimeout = setTimeout(() => {
            console.log('Skip - Auto-dial timeout fired, calling dialNextInQueue');
            hideCountdown();
            dialNextInQueue();
          }, delay);
        } else {
          dialNextInQueue();
        }
      } else {
        resetForNextCall();
      }
    }

    function resetForNextCall() {
      // Reset the UI for the next call
      selectedOutcome = null;
      currentCallSid = null;

      // Reset Supabase state for next call
      currentCallRecordId = null;
      currentContactId = null;

      // Hide outcome panel
      document.getElementById('outcomePanel').classList.add('hidden');

      // Reset outcome buttons
      document.querySelectorAll('.outcome-btn').forEach(btn => {
        btn.classList.remove('selected');
      });

      // Clear notes
      document.getElementById('outcomeNotes').value = '';
      document.getElementById('callNotes').value = '';
      document.getElementById('callbackScheduler').classList.add('hidden');

      // Reset call display
      document.getElementById('phoneNumber').textContent = 'Enter number to call';
      document.getElementById('callTimer').textContent = '0:00';
      document.getElementById('callState').textContent = 'Ready';
      document.getElementById('callState').className = 'call-state';

      // Show dial pad, hide call controls
      hideCallUI();

      // Clear transcript
      document.getElementById('transcriptContainer').innerHTML = `
        <div class="empty-state">
          <div class="empty-state-icon">üí¨</div>
          <div class="empty-state-title">No transcript yet</div>
          <div class="empty-state-text">Start a call to see real-time transcription</div>
        </div>
      `;

      // Clear AI coaching panel
      clearAICoachingPanel();

      // Clear search
      document.getElementById('transcriptSearchInput').value = '';

      document.getElementById('transcriptStatus').textContent = 'Waiting for call';
      document.getElementById('transcriptStatus').className = 'badge badge-info';

      // Hide customer info and scripts
      document.getElementById('customerInfoCard').style.display = 'none';
      document.getElementById('scriptsCard').style.display = 'none';

      // Hide AI coach
      document.getElementById('aiCoachBox').classList.add('hidden');

      // Reset lead source
      resetLeadSource();
    }

    // Event Listeners
    function setupEventListeners() {
      // Dial pad buttons
      document.querySelectorAll('.dial-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const digit = btn.dataset.digit;
          const input = document.getElementById('phoneInput');
          input.value += digit;

          // Send DTMF if in call
          if (connection) {
            connection.sendDigits(digit);
          }
        });
      });

      // Phone input formatting
      document.getElementById('phoneInput').addEventListener('input', (e) => {
        let value = e.target.value.replace(/\D/g, '');
        if (value.length > 0) {
          if (value.length <= 3) {
            value = `(${value}`;
          } else if (value.length <= 6) {
            value = `(${value.slice(0, 3)}) ${value.slice(3)}`;
          } else {
            value = `(${value.slice(0, 3)}) ${value.slice(3, 6)}-${value.slice(6, 10)}`;
          }
        }
        e.target.value = value;
      });

      // Enter key to call
      document.getElementById('phoneInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          makeCall();
        }
      });

      // Call button
      document.getElementById('callBtn').addEventListener('click', makeCall);

      // End call button
      document.getElementById('endCallBtn').addEventListener('click', endCall);

      // Mute button
      document.getElementById('muteBtn').addEventListener('click', toggleMute);

      // Hold button
      document.getElementById('holdBtn').addEventListener('click', toggleHold);

      // Incoming call buttons
      document.getElementById('answerCallBtn').addEventListener('click', answerIncomingCall);
      document.getElementById('declineCallBtn').addEventListener('click', declineIncomingCall);

      // Outcome buttons
      document.querySelectorAll('.outcome-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          selectOutcome(btn.dataset.outcome);
        });
      });

      // Close modal on overlay click
      document.getElementById('scriptModal').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
          closeScriptModal();
        }
      });

      // Escape key to close modal or decline incoming call
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          // If incoming call modal is open, decline the call
          if (document.getElementById('incomingCallModal').classList.contains('active')) {
            declineIncomingCall();
          } else {
            closeScriptModal();
          }
        }
        // Enter key to answer incoming call
        if (e.key === 'Enter' && document.getElementById('incomingCallModal').classList.contains('active')) {
          answerIncomingCall();
        }
      });

      // Click outside incoming call modal to decline
      document.getElementById('incomingCallModal').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
          declineIncomingCall();
        }
      });
    }

    // Check URL params for incoming call or pre-filled number
    function checkUrlParams() {
      const params = new URLSearchParams(window.location.search);

      const number = params.get('number');
      if (number) {
        document.getElementById('phoneInput').value = formatPhoneNumber(number);
        document.getElementById('phoneNumber').textContent = formatPhoneNumber(number);

        // If coming from callbacks page, auto-dial after device is ready
        const callback = params.get('callback');
        if (callback) {
          console.log('Callback mode - will auto-dial:', number);
          // Wait for Twilio device to be ready, then auto-dial
          const autoDialCheck = setInterval(() => {
            if (device && device.state === 'registered') {
              clearInterval(autoDialCheck);
              console.log('Device ready, auto-dialing callback number...');
              setTimeout(() => makeCall(), 500);
            }
          }, 500);
          // Timeout after 10 seconds
          setTimeout(() => clearInterval(autoDialCheck), 10000);
        }
      }

      const incoming = params.get('incoming');
      if (incoming) {
        // Handle incoming call redirect
        console.log('Incoming call:', incoming);
      }
    }

    // Helper functions
    function formatPhoneNumber(number) {
      if (!number) return '';
      const cleaned = number.replace(/\D/g, '');
      if (cleaned.length === 11 && cleaned[0] === '1') {
        return `+1 (${cleaned.slice(1, 4)}) ${cleaned.slice(4, 7)}-${cleaned.slice(7)}`;
      }
      if (cleaned.length === 10) {
        return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
      }
      return number;
    }

    function formatTime(timestamp) {
      if (!timestamp) return '';
      const date = new Date(timestamp);
      return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: true });
    }

    function formatDate(dateStr) {
      if (!dateStr) return '';
      const date = new Date(dateStr);
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    }

    // Initialize on load
    init();
  </script>
</body>
</html>
